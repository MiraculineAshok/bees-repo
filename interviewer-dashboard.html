<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interviewer Dashboard - Bees Interview Platform</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #ffffff;
            color: #000000;
            line-height: 1.6;
        }

        .dashboard-container {
            display: flex;
            min-height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            width: 250px;
            background: #000000;
            color: white;
            padding: 1.5rem 0;
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            z-index: 1000;
        }

        .sidebar-header {
            padding: 0 1.5rem 2rem;
            border-bottom: 1px solid #333333;
            margin-bottom: 1rem;
        }

        .sidebar-header h2 {
            color: #ffffff;
            font-size: 1.5rem;
            font-weight: 700;
        }

        .sidebar-nav {
            list-style: none;
        }

        .nav-item {
            margin-bottom: 0.25rem;
        }

        .nav-link {
            display: block;
            padding: 0.75rem 1.5rem;
            color: #cccccc;
            text-decoration: none;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
            cursor: pointer;
        }

        .nav-link:hover,
        .nav-link.active {
            background: #333333;
            color: white;
            border-left-color: #ffffff;
        }

        .nav-link i {
            margin-right: 0.75rem;
            width: 20px;
            text-align: center;
        }

        /* Main Content */
        .main-content {
            margin-left: 250px;
            flex: 1;
            padding: 2rem;
        }

        .header {
            background: white;
            padding: 1.5rem 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid #000000;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .home-link {
            color: #000;
            text-decoration: none;
            margin-right: 1rem;
            font-weight: 600;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            transition: background-color 0.2s ease;
        }

        .home-link:hover {
            background-color: #f0f0f0;
            text-decoration: none;
        }

        .header h1 {
            color: #000;
            font-size: 2rem;
            font-weight: 700;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #cccccc;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            background: #000;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .btn {
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
            border: none;
            text-decoration: none;
            display: inline-block;
        }

        .btn-primary {
            background: #000;
            color: white;
        }

        .btn-primary:hover {
            background: #333;
        }

        .btn-sm {
            padding: 0.3rem 0.6rem;
            font-size: 0.8rem;
        }

        /* Content Tabs */
        .content-section {
            display: none;
        }

        .content-section.active {
            display: block;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            border-left: 4px solid #000;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: #000;
            margin-bottom: 0.5rem;
        }

        .stat-label {
            color: #666;
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .section-card {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            border: 1px solid #000;
        }

        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #000;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid #eee;
            padding-bottom: 1rem;
        }

        .table-container {
            overflow-x: auto;
        }

        .table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        .table th, .table td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        .table th {
            background: #f8f8f8;
            font-weight: 600;
            color: #000;
        }

        /* Compact table styling for edit functionality */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }

        .data-table th,
        .data-table td {
            padding: 0.5rem 0.75rem;
            text-align: left;
            border-bottom: 1px solid #e5e7eb;
            vertical-align: middle;
        }

        .data-table th {
            background: #f8fafc;
            font-weight: 600;
            color: #374151;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .data-table tr:hover {
            background: #f9fafb;
        }

        .data-table tr.editing {
            background: #fef3c7;
        }

        /* Icon buttons */
        .icon-btn {
            background: none;
            border: none;
            padding: 0.25rem;
            margin: 0 0.125rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
        }

        .icon-btn:hover {
            background: #f3f4f6;
            transform: scale(1.1);
        }

        .edit-btn {
            color: #2563eb;
        }

        .edit-btn:hover {
            background: #dbeafe;
            color: #1d4ed8;
        }

        .delete-btn {
            color: #dc2626;
        }

        .delete-btn:hover {
            background: #fef2f2;
            color: #b91c1c;
        }

        .save-btn {
            color: #059669;
        }

        .save-btn:hover {
            background: #d1fae5;
            color: #047857;
        }

        .cancel-btn {
            color: #6b7280;
        }

        .cancel-btn:hover {
            background: #f3f4f6;
            color: #374151;
        }

        /* Edit form styling */
        .edit-form {
            display: none;
        }

        .edit-form.active {
            display: block;
        }

        .edit-input {
            width: 100%;
            padding: 0.25rem 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.85rem;
            background: white;
        }

        .edit-input:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
        }

        .edit-select {
            width: 100%;
            padding: 0.25rem 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.85rem;
            background: white;
        }

        /* Bulk edit controls */
        .bulk-edit-controls {
            display: none;
            padding: 1rem;
            background: #f8fafc;
            border-bottom: 1px solid #e5e7eb;
            align-items: center;
            gap: 1rem;
        }

        .bulk-edit-controls.active {
            display: flex;
        }

        .bulk-edit-info {
            color: #6b7280;
            font-size: 0.875rem;
        }

        .bulk-edit-actions {
            display: flex;
            gap: 0.5rem;
        }

        /* Checkbox styling */
        .row-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        /* Modal styling for bulk edit */
        .bulk-edit-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .bulk-edit-modal.active {
            display: flex;
        }

        .bulk-edit-content {
            background: white;
            border-radius: 8px;
            padding: 2rem;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .bulk-edit-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .bulk-edit-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #111827;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6b7280;
        }

        .bulk-edit-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .form-label {
            font-weight: 500;
            color: #374151;
            font-size: 0.875rem;
        }

        .form-input,
        .form-select,
        .form-textarea {
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.875rem;
        }

        .form-input:focus,
        .form-select:focus,
        .form-textarea:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
        }

        .bulk-edit-footer {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid #e5e7eb;
        }

        .btn {
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: #2563eb;
            color: white;
            border: none;
        }

        .btn-primary:hover {
            background: #1d4ed8;
        }

        .btn-secondary {
            background: #6b7280;
            color: white;
            border: none;
        }

        .btn-secondary:hover {
            background: #4b5563;
        }

        .table tbody tr:hover {
            background: #f5f5f5;
        }

        .question-bank-filters {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .question-bank-list {
            max-height: 600px;
            overflow-y: auto;
            border: 1px solid #000;
            border-radius: 5px;
            padding: 1rem;
            background: #fdfdfd;
        }

        .question-item {
            padding: 0.75rem 0;
            border-bottom: 1px dashed #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .question-item:last-child {
            border-bottom: none;
        }

        .question-text {
            flex-grow: 1;
            margin-right: 1rem;
            color: #000;
        }

        .favorite-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.2rem;
            color: #ccc;
            transition: color 0.2s ease;
        }

        .favorite-btn.favorited {
            color: gold;
        }

        .favorite-btn:hover {
            color: orange;
        }

               .loading, .empty-state {
                   text-align: center;
                   padding: 2rem;
                   color: #666;
               }

               /* Detail Panel Styles */
               .detail-panel {
                   position: fixed;
                   top: 0;
                   right: -400px;
                   width: 400px;
                   height: 100vh;
                   background: white;
                   box-shadow: -2px 0 10px rgba(0,0,0,0.1);
                   z-index: 1001;
                   transition: right 0.3s ease;
                   overflow-y: auto;
               }

               .detail-panel.active {
                   right: 0;
               }

               .detail-overlay {
                   position: fixed;
                   top: 0;
                   left: 0;
                   width: 100%;
                   height: 100%;
                   background: rgba(0,0,0,0.5);
                   z-index: 1000;
                   opacity: 0;
                   visibility: hidden;
                   transition: all 0.3s ease;
               }

               .detail-overlay.active {
                   opacity: 1;
                   visibility: visible;
               }

               .detail-panel-header {
                   background: #000000;
                   color: white;
                   padding: 1rem;
                   display: flex;
                   justify-content: space-between;
                   align-items: center;
                   border-bottom: 1px solid #333;
               }

               .detail-panel-header h3 {
                   margin: 0;
                   font-size: 1.2rem;
               }

               .detail-panel-close {
                   background: none;
                   border: none;
                   color: white;
                   font-size: 1.5rem;
                   cursor: pointer;
                   padding: 0;
                   width: 30px;
                   height: 30px;
                   display: flex;
                   align-items: center;
                   justify-content: center;
               }

               .detail-panel-content {
                   padding: 1.5rem;
               }

               .detail-section {
                   margin-bottom: 2rem;
               }

               .detail-section-title {
                   font-size: 1.1rem;
                   font-weight: 600;
                   color: #000000;
                   margin-bottom: 1rem;
                   padding-bottom: 0.5rem;
                   border-bottom: 2px solid #000000;
               }

               .detail-item {
                   display: flex;
                   justify-content: space-between;
                   align-items: flex-start;
                   padding: 0.75rem 0;
                   border-bottom: 1px solid #eee;
               }

               .detail-label {
                   font-weight: 600;
                   color: #666;
                   min-width: 120px;
               }

               .detail-value {
                   color: #000000;
                   text-align: right;
                   flex: 1;
               }

               .question-answer-item {
                   background: #f8f9fa;
                   padding: 1rem;
                   margin-bottom: 1rem;
                   border-radius: 5px;
                   border-left: 4px solid #000000;
               }

               .question-answer-item p {
                   margin: 0.5rem 0;
                   color: #000000;
               }
               
               .question-header, .answer-section {
                   display: flex;
                   justify-content: space-between;
                   align-items: flex-start;
                   margin-bottom: 0.5rem;
               }
               
               .question-header p, .answer-section p {
                   flex: 1;
                   margin: 0;
                   margin-right: 0.5rem;
               }
               
               .question-text-display, .answer-text-display {
                   word-wrap: break-word;
               }
               
               .question-edit-input, .answer-edit-input {
                   width: 100%;
                   padding: 0.5rem;
                   border: 1px solid #d1d5db;
                   border-radius: 4px;
                   font-size: 0.9rem;
                   margin-bottom: 0.5rem;
               }
               
               .edit-actions {
                   display: flex;
                   gap: 0.5rem;
                   margin-top: 0.5rem;
               }
               
               .photo-gallery {
                   display: flex;
                   flex-wrap: wrap;
                   gap: 0.5rem;
                   margin-top: 0.5rem;
               }
               
               .photo-item {
                   position: relative;
                   display: inline-block;
               }
               
               .photo-item img {
                   width: 80px;
                   height: 80px;
                   object-fit: cover;
                   border-radius: 4px;
                   border: 1px solid #d1d5db;
                   cursor: pointer;
               }

               .answer-image {
                   max-width: 100%;
                   height: auto;
                   border-radius: 5px;
                   cursor: pointer;
                   margin-top: 0.5rem;
               }

               /* Image Modal Styles */
               .image-modal {
                   position: fixed;
                   top: 0;
                   left: 0;
                   width: 100%;
                   height: 100%;
                   background: rgba(0,0,0,0.9);
                   z-index: 2000;
                   display: flex;
                   align-items: center;
                   justify-content: center;
                   opacity: 0;
                   visibility: hidden;
                   transition: all 0.3s ease;
               }

               .image-modal.active {
                   opacity: 1;
                   visibility: visible;
               }

               .image-modal-content {
                   position: relative;
                   max-width: 90%;
                   max-height: 90%;
               }

               .image-modal-content img {
                   max-width: 100%;
                   max-height: 100%;
                   border-radius: 5px;
               }

               .image-modal-close {
                   position: absolute;
                   top: -40px;
                   right: 0;
                   color: white;
                   font-size: 2rem;
                   cursor: pointer;
                   background: rgba(0,0,0,0.5);
                   width: 40px;
                   height: 40px;
                   display: flex;
                   align-items: center;
                   justify-content: center;
                   border-radius: 50%;
               }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #000;
        }

        .form-select, .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #000;
            border-radius: 5px;
            font-size: 1rem;
        }

        .hidden {
            display: none !important;
        }

        /* Compact Filter Toggle Button */
        .btn-filter-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: #000000;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.3s ease;
        }

        .btn-filter-toggle:hover {
            background: #333333;
            transform: translateY(-1px);
        }

        .filter-icon {
            font-size: 1rem;
        }

        .filter-text {
            font-weight: 500;
        }

        /* Filter Panel */
        .filter-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: white;
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
            z-index: 1001;
            transition: right 0.3s ease;
            overflow-y: auto;
        }

        .filter-panel.active {
            right: 0;
        }

        .filter-panel-header {
            background: #000000;
            color: white;
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333333;
        }

        .filter-panel-header h3 {
            margin: 0;
            font-size: 1.2rem;
            flex: 1;
        }

        .filter-panel-content {
            padding: 1.5rem;
        }

        /* Filter Panel Overlay - separate from detail panel overlay */
        .filter-panel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 400px; /* Don't cover the filter panel */
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease;
        }

        .filter-panel-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        /* Filter Panel Sections */
        .filter-panel .filter-section,
        .filter-panel .sort-section,
        .filter-panel .group-by-section {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 1rem;
        }

        .filter-panel .filter-section-title {
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #333333;
            font-size: 0.9rem;
        }

        .filter-panel .filter-row {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .filter-panel .filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .filter-panel .filter-group label {
            font-size: 0.8rem;
            font-weight: 500;
            color: #555555;
        }

        .filter-panel .form-input,
        .filter-panel .form-select {
            padding: 0.5rem;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 0.8rem;
            width: 100%;
        }

        .filter-panel .sort-options,
        .filter-panel .group-by-options {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .filter-panel .sort-option {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .filter-panel .group-by-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .filter-panel .group-by-option label {
            font-size: 0.8rem;
            cursor: pointer;
            margin: 0;
        }

        .filter-panel .filter-actions {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #dee2e6;
        }

        .filter-panel .btn-filter,
        .filter-panel .btn-clear,
        .filter-panel .btn-export,
        .filter-panel .btn {
            width: 100%;
            padding: 0.75rem;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-size: 0.875rem;
            transition: background 0.2s;
        }

        /* Enhanced Filter Styles */
        .controls-panel {
            background: #f8f9fa;
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
            border: 1px solid #dee2e6;
        }

        .filter-section {
            margin-bottom: 1.5rem;
        }

        .filter-section-title {
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #495057;
            font-size: 1rem;
            border-bottom: 2px solid #007bff;
            padding-bottom: 0.25rem;
        }

        .filter-row {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            align-items: end;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            min-width: 150px;
        }

        .filter-group label {
            font-weight: 600;
            margin-bottom: 0.25rem;
            color: #495057;
            font-size: 0.875rem;
        }

        .filter-group select,
        .filter-group input {
            padding: 0.5rem;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 0.875rem;
            background: white;
        }

        .filter-group input[type="text"] {
            min-width: 200px;
        }

        .filter-group input[type="number"] {
            min-width: 100px;
        }

        /* Sort Section */
        .sort-section {
            background: #fff3cd;
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 1rem;
        }

        .sort-options {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .sort-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .sort-option select {
            padding: 0.25rem 0.5rem;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 0.875rem;
            min-width: 150px;
        }

        /* Group By Section */
        .group-by-section {
            background: #e9ecef;
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 1rem;
        }

        .group-by-options {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .group-by-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .group-by-option input[type="radio"] {
            margin: 0;
        }

        .group-by-option label {
            margin: 0;
            font-size: 0.875rem;
            cursor: pointer;
        }

        /* Action Buttons */
        .filter-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn-filter {
            background: #007bff;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: background 0.2s;
        }

        .btn-filter:hover {
            background: #0056b3;
        }

        .btn-clear {
            background: #6c757d;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: background 0.2s;
        }

        .btn-clear:hover {
            background: #545b62;
        }

        .btn-export {
            background: #28a745;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: background 0.2s;
        }

        .btn-export:hover {
            background: #1e7e34;
        }

        /* Results Summary */
        .results-summary {
            background: #d1ecf1;
            padding: 0.75rem 1rem;
            border-radius: 4px;
            margin-top: 1rem;
            font-size: 0.875rem;
            color: #0c5460;
        }

        .results-summary strong {
            color: #000000;
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <h2>Interviewer Dashboard</h2>
            </div>
            <nav>
                <ul class="sidebar-nav">
                    <li class="nav-item">
                        <a href="#" class="nav-link active" onclick="showSection('interviews')">
                            <i>📋</i>
                            My Interviews
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="#" class="nav-link" onclick="showSection('questions')">
                            <i>❓</i>
                            Question Analysis
                        </a>
                    </li>
                </ul>
            </nav>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Header -->
            <header class="header">
                <div class="header-left">
                    <a href="/" class="home-link">← Home</a>
                    <h1 id="page-title">My Interviews</h1>
                </div>
                <div class="header-actions" style="position:relative;display:flex;gap:8px;align-items:center">
                    <button id="start-interview-btn" class="btn-primary" style="padding:8px 12px;border-radius:6px;border:1px solid #dc2626;background:#dc2626;color:#fff;cursor:pointer" onclick="window.location.href='/interview'">Start Interview</button>
                    <div class="user-info">
                        <div class="user-avatar" id="user-avatar" style="cursor:pointer">I</div>
                        <div id="avatar-menu" style="position:absolute;right:0;top:52px;background:#fff;border:1px solid #e5e7eb;border-radius:8px;box-shadow:0 10px 20px rgba(0,0,0,0.1);display:none;min-width:140px;z-index:10">
                            <button id="logout-btn" style="width:100%;background:#fff;border:none;text-align:left;padding:10px 12px;cursor:pointer">Logout</button>
                        </div>
                    </div>
                </div>
            </header>

            <!-- My Interviews Section -->
            <section id="interviews-section" class="content-section active">
                <!-- Stats Grid -->
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="total-interviews">0</div>
                        <div class="stat-label">Total Interviews</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="completed-interviews">0</div>
                        <div class="stat-label">Completed Interviews</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="in-progress-interviews">0</div>
                        <div class="stat-label">Interviews In Progress</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="favorite-questions">0</div>
                        <div class="stat-label">Favorite Questions</div>
                    </div>
                </div>


                <!-- Interviews Table -->
                <div class="section-card">
                    <div class="section-header">
                        <h2 class="section-title">My Interviews</h2>
                        <div class="header-actions">
                            <button class="btn-filter-toggle" onclick="toggleFilterPanel('interviews')" title="Filter & Sort Options">
                                <span class="filter-icon">⚙️</span>
                                <span class="filter-text">Filters</span>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Results Summary -->
                    <div id="results-summary" class="results-summary" style="display: none;">
                        <strong>0</strong> interviews found
                    </div>
                    
                    <div class="table-container">
                        <table class="table">
                            <thead>
                                <tr>
                                    <th>Date</th>
                                    <th>Student Name</th>
                                    <th>Zeta ID</th>
                                    <th>Session</th>
                                    <th>Status</th>
                                    <th>Verdict</th>
                                    <th>Duration</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="interviews-table-body">
                                <tr><td colspan="8" class="loading">Loading interviews...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </section>

            <!-- Question Analysis Section -->
            <section id="questions-section" class="content-section">
                <div class="section-card">
                    <div class="section-header">
                        <h2 class="section-title">Question Analysis</h2>
                        <div class="header-actions">
                            <button class="btn btn-success" onclick="openAddQuestionModal()">Add Question</button>
                            <button class="btn btn-info" onclick="openBulkImportModal()">Bulk Import</button>
                            <button class="btn-filter-toggle" onclick="toggleFilterPanel('questions')" title="Filter & Sort Options">
                                <span class="filter-icon">⚙️</span>
                                <span class="filter-text">Filters</span>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Results Summary -->
                    <div id="question-results-summary" class="results-summary" style="display: none;">
                        <strong>0</strong> questions found
                    </div>
                    <div id="question-bank-list" class="question-bank-list">
                        <div class="loading">Loading questions...</div>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <!-- Filter Panel Overlay -->
    <div id="filter-panel-overlay" class="filter-panel-overlay" onclick="closeFilterPanel()"></div>

    <!-- Interview Filter Panel -->
    <div id="filter-panel" class="filter-panel">
        <div class="filter-panel-header">
            <h3>Filter & Sort Options</h3>
            <button class="close-btn" onclick="closeFilterPanel()">✕</button>
        </div>
        <div class="filter-panel-content">
            <!-- Search Section -->
            <div class="filter-section">
                <div class="filter-section-title">🔍 Search & Filter</div>
                <div class="filter-row">
                    <div class="filter-group">
                        <label>Search:</label>
                        <input type="text" id="search-interviews" class="form-input" placeholder="Search by student name, Zeta ID, or session..." onkeyup="applyFilters('interviews')">
                    </div>
                    <div class="filter-group">
                        <label>Status:</label>
                        <select id="status-filter" class="form-select" onchange="applyFilters('interviews')">
                            <option value="">All Statuses</option>
                            <option value="completed">Completed</option>
                            <option value="in_progress">In Progress</option>
                            <option value="cancelled">Cancelled</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>Verdict:</label>
                        <select id="verdict-filter" class="form-select" onchange="applyFilters('interviews')">
                            <option value="">All Verdicts</option>
                            <option value="Tiger">Tiger</option>
                            <option value="Cow">Cow</option>
                            <option value="Cow+">Cow+</option>
                            <option value="Sheep">Sheep</option>
                        </select>
                    </div>
                </div>
                <div class="filter-row">
                    <div class="filter-group">
                        <label>Date From:</label>
                        <input type="date" id="date-from" class="form-input" onchange="applyFilters('interviews')">
                    </div>
                    <div class="filter-group">
                        <label>Date To:</label>
                        <input type="date" id="date-to" class="form-input" onchange="applyFilters('interviews')">
                    </div>
                    <div class="filter-group">
                        <label>Duration (min):</label>
                        <input type="number" id="duration-min" class="form-input" placeholder="Minutes" min="0" onchange="applyFilters('interviews')">
                    </div>
                </div>
            </div>

            <!-- Sort Section -->
            <div class="sort-section">
                <div class="filter-section-title">📊 Sort Options</div>
                <div class="sort-options">
                    <div class="sort-option">
                        <label>Primary Sort:</label>
                        <select id="sort-by" class="form-select" onchange="applyFilters('interviews')">
                            <option value="created_at_desc">Date (Newest First)</option>
                            <option value="created_at_asc">Date (Oldest First)</option>
                            <option value="student_name_asc">Student Name (A-Z)</option>
                            <option value="student_name_desc">Student Name (Z-A)</option>
                            <option value="duration_desc">Duration (Longest First)</option>
                            <option value="duration_asc">Duration (Shortest First)</option>
                            <option value="status_asc">Status (A-Z)</option>
                            <option value="verdict_asc">Verdict (A-Z)</option>
                        </select>
                    </div>
                    <div class="sort-option">
                        <label>Secondary Sort:</label>
                        <select id="sort-by-2" class="form-select" onchange="applyFilters('interviews')">
                            <option value="">None</option>
                            <option value="student_name_asc">Student Name (A-Z)</option>
                            <option value="student_name_desc">Student Name (Z-A)</option>
                            <option value="created_at_desc">Date (Newest First)</option>
                            <option value="created_at_asc">Date (Oldest First)</option>
                            <option value="duration_desc">Duration (Longest First)</option>
                            <option value="duration_asc">Duration (Shortest First)</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Group By Section -->
            <div class="group-by-section">
                <div class="filter-section-title">📋 Group By</div>
                <div class="group-by-options">
                    <div class="group-by-option">
                        <input type="radio" id="group-none" name="group-by" value="" onchange="applyFilters('interviews')" checked>
                        <label for="group-none">No Grouping</label>
                    </div>
                    <div class="group-by-option">
                        <input type="radio" id="group-status" name="group-by" value="status" onchange="applyFilters('interviews')">
                        <label for="group-status">Status</label>
                    </div>
                    <div class="group-by-option">
                        <input type="radio" id="group-verdict" name="group-by" value="verdict" onchange="applyFilters('interviews')">
                        <label for="group-verdict">Verdict</label>
                    </div>
                    <div class="group-by-option">
                        <input type="radio" id="group-date" name="group-by" value="date" onchange="applyFilters('interviews')">
                        <label for="group-date">Date</label>
                    </div>
                    <div class="group-by-option">
                        <input type="radio" id="group-duration" name="group-by" value="duration" onchange="applyFilters('interviews')">
                        <label for="group-duration">Duration Range</label>
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="filter-actions">
                <button class="btn-filter" onclick="applyFilters('interviews', true)">Apply Filters</button>
                <button class="btn-clear" onclick="clearAllFilters()">Clear All</button>
                <button class="btn-export" onclick="exportInterviews()">Export CSV</button>
                <button class="btn btn-secondary" onclick="loadInterviews()">Refresh Data</button>
            </div>
        </div>
    </div>

    <!-- Question Filter Panel -->
    <div id="question-filter-panel" class="filter-panel">
        <div class="filter-panel-header">
            <h3>Question Filter Options</h3>
            <button class="close-btn" onclick="closeQuestionFilterPanel()">✕</button>
        </div>
        <div class="filter-panel-content">
            <!-- Search Section -->
            <div class="filter-section">
                <div class="filter-section-title">🔍 Search & Filter Questions</div>
                <div class="filter-row">
                    <div class="filter-group">
                        <label>Search:</label>
                        <input type="text" id="bank-search-input" class="form-input" placeholder="Search questions by text..." onkeyup="loadQuestions()">
                    </div>
                    <div class="filter-group">
                        <label>Category:</label>
                        <select id="bank-category-select" class="form-select" onchange="loadQuestions()">
                            <option value="">All Categories</option>
                            <option value="Favorites">My Favorites</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>Sort by:</label>
                        <select id="question-sort-by" class="form-select" onchange="loadQuestions()">
                            <option value="popularity">Most Popular</option>
                            <option value="recent">Most Recent</option>
                            <option value="alphabetical">Alphabetical</option>
                            <option value="category">Category</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="filter-actions">
                <button class="btn-filter" onclick="loadQuestions()">Search Questions</button>
                <button class="btn-clear" onclick="clearQuestionFilters()">Clear Filters</button>
                <button class="btn-export" onclick="exportQuestions()">Export Questions</button>
            </div>
        </div>
    </div>

    <script>
        let allInterviews = [];
        let allQuestions = [];
        let favoriteQuestionIds = new Set();
        let currentUser = null;
        let sessions = []; // Add sessions array

        document.addEventListener('DOMContentLoaded', () => {
            checkUserLoginStatus();
            // Debug: Check if functions are available
            console.log('openAddQuestionModal available:', typeof openAddQuestionModal);
            console.log('openBulkImportModal available:', typeof openBulkImportModal);
        });

        async function checkUserLoginStatus() {
            // 1) Prefer URL params (first-time after OAuth redirect)
            const params = new URLSearchParams(window.location.search);
            const urlEmail = params.get('email');
            const urlName = params.get('name');
            const urlRole = params.get('role');
            if (urlEmail || urlName) {
                const userData = {
                    email: urlEmail || '',
                    name: urlName || (urlEmail ? urlEmail.split('@')[0] : 'User'),
                    role: urlRole || 'interviewer'
                };
                try { localStorage.setItem('bees_user_data', JSON.stringify(userData)); } catch {}
                // Clean URL
                window.history.replaceState({}, document.title, window.location.pathname + window.location.hash);
            }

            // 2) Load from storage
            const storedUserData = localStorage.getItem('bees_user_data');
            if (storedUserData) {
                try {
                    const userData = JSON.parse(storedUserData);
                    if (userData && (userData.email || userData.name)) {
                        // Avatar initial
                        try {
                            const userIdResponse = await fetch('/api/user/id');
                            const userIdData = await userIdResponse.json();
                            const userId = userIdData.success ? userIdData.userId : null;
                            const initial = userId ? String(userId).charAt(0).toUpperCase() : (userData.email || userData.name).charAt(0).toUpperCase();
                            document.getElementById('user-avatar').textContent = initial;
                        } catch (error) {
                            console.error('Error fetching user ID:', error);
                            document.getElementById('user-avatar').textContent = (userData.email || userData.name).charAt(0).toUpperCase();
                        }
                        const avatar = document.getElementById('user-avatar');
                        const menu = document.getElementById('avatar-menu');
                        avatar.onclick = ()=> { menu.style.display = (menu.style.display==='block'?'none':'block'); };
                        document.addEventListener('click', (e)=>{ if (!avatar.contains(e.target) && !menu.contains(e.target)) menu.style.display='none'; });
                        const logoutBtn = document.getElementById('logout-btn');
                        if (logoutBtn) {
                            logoutBtn.onclick = ()=> {
                                const overlay = document.createElement('div');
                                overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.35);display:flex;align-items:center;justify-content:center;z-index:2000;';
                                overlay.innerHTML = `
                                  <div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;min-width:280px;max-width:90%;padding:16px;box-shadow:0 10px 20px rgba(0,0,0,0.15)">
                                    <div style=\"font-weight:600;margin-bottom:8px;color:#111827\">Logout?</div>
                                    <div style=\"font-size:14px;color:#374151;margin-bottom:12px\">Are you sure you want to logout?</div>
                                    <div style=\"display:flex;gap:8px;justify-content:flex-end\">
                                      <button id=\"lg-cancel\" style=\"border:1px solid #e5e7eb;background:#fff;padding:6px 10px;border-radius:6px;cursor:pointer\">Cancel</button>
                                      <button id=\"lg-confirm\" style=\"background:#111827;color:#fff;border:none;padding:6px 10px;border-radius:6px;cursor:pointer\">Logout</button>
                                    </div>
                                  </div>`;
                                document.body.appendChild(overlay);
                                overlay.querySelector('#lg-cancel').onclick = ()=> overlay.remove();
                                overlay.querySelector('#lg-confirm').onclick = ()=> { overlay.remove(); try { localStorage.removeItem('bees_user_data'); } catch {}; window.location.href = '/'; };
                            };
                        }
                        currentUser = { name: userData.name || 'User', email: userData.email || '' };
                        await loadDashboardData();
                        return;
                    }
                } catch (e) {
                    console.error('Error parsing stored user data:', e);
                    // Do not remove storage blindly; allow retry path below
                }
            }

            // 3) If still no user, go home to sign in
            window.location.href = '/';
        }

        async function loadDashboardData() {
            try {
                await Promise.all([
                    loadMyInterviews(),
                    loadQuestions(),
                    loadFavoriteQuestions(),
                    loadStats(),
                    loadSessions() // Add this to load sessions
                ]);
            } catch (error) {
                console.error('Error loading dashboard data:', error);
            }
        }

        function showSection(sectionName) {
            // Hide all sections
            document.querySelectorAll('.content-section').forEach(section => {
                section.classList.remove('active');
            });
            
            // Remove active class from all nav links
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
            });
            
            // Show selected section
            document.getElementById(sectionName + '-section').classList.add('active');
            
            // Add active class to clicked nav link
            if (event && event.target) {
                event.target.classList.add('active');
            } else {
                // If called programmatically, find the correct nav link
                document.querySelector(`[onclick="showSection('${sectionName}')"]`).classList.add('active');
            }
            
            // Update page title
            const titles = {
                'interviews': 'My Interviews',
                'questions': 'Question Analysis'
            };
            document.getElementById('page-title').textContent = titles[sectionName];

            // Update URL to persist tab state
            const url = new URL(window.location);
            url.searchParams.set('tab', sectionName);
            window.history.replaceState({}, '', url);
        }

        // Activate section from URL param, e.g., ?tab=my-interviews or ?tab=questions
        document.addEventListener('DOMContentLoaded', function() {
            const params = new URLSearchParams(window.location.search);
            const tab = params.get('tab');
            if (tab) {
                if (tab === 'my-interviews' || tab === 'interviews') {
                    showSection('interviews');
                } else if (tab === 'questions') {
                    showSection('questions');
                }
            }
        });

        // Filter Panel Functions
        let currentFilterTab = 'interviews'; // Default tab
        
        function toggleFilterPanel(tab = 'interviews') {
            // Close all filter panels first
            document.querySelectorAll('.filter-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            document.getElementById('filter-panel-overlay').classList.remove('active');
            
            // Determine which panel to show
            let panelId = 'filter-panel';
            if (tab === 'questions') {
                panelId = 'question-filter-panel';
            }
            
            const panel = document.getElementById(panelId);
            const overlay = document.getElementById('filter-panel-overlay');
            
            if (panel && !panel.classList.contains('active')) {
                currentFilterTab = tab;
                generateFilterContent(tab);
                panel.classList.add('active');
                overlay.classList.add('active');
            }
        }

        function generateFilterContent(tab) {
            // Determine which panel content to update
            let content;
            if (tab === 'questions') {
                content = document.querySelector('#question-filter-panel .filter-panel-content');
            } else {
                content = document.querySelector('#filter-panel .filter-panel-content');
            }
            
            const titles = {
                'interviews': 'My Interviews',
                'questions': 'Question Analysis'
            };
            
            content.innerHTML = `
                <div class="filter-section">
                    <div class="filter-section-title">🔍 Search & Filter</div>
                    <div class="filter-row">
                        ${generateFilterFields(tab)}
                    </div>
                </div>
                
                <div class="sort-section">
                    <div class="filter-section-title">📊 Sort Options</div>
                    <div class="sort-options">
                        ${generateSortOptions(tab)}
                    </div>
                </div>
                
                <div class="group-by-section">
                    <div class="filter-section-title">📋 Group By</div>
                    <div class="group-by-options">
                        ${generateGroupByOptions(tab)}
                    </div>
                </div>
                
                <div class="filter-actions">
                    <button class="btn-filter" onclick="applyFilters('${tab}', true)">Apply Filters</button>
                    <button class="btn-clear" onclick="clearAllFilters('${tab}')">Clear All</button>
                    <button class="btn-export" onclick="exportData('${tab}')">Export Data</button>
                </div>
            `;
        }

        function generateFilterFields(tab) {
            const filterConfigs = {
                'interviews': `
                    <div class="filter-group">
                        <label>Search:</label>
                        <input type="text" id="search-interviews" class="form-input" placeholder="Search by student name, email, or Zeta ID...">
                    </div>
                    <div class="filter-group">
                        <label>Status:</label>
                        <select id="status-filter" class="form-select">
                            <option value="">All Statuses</option>
                            <option value="completed">Completed</option>
                            <option value="in_progress">In Progress</option>
                            <option value="cancelled">Cancelled</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>Verdict:</label>
                        <select id="verdict-filter" class="form-select">
                            <option value="">All Verdicts</option>
                            <option value="Tiger">Tiger</option>
                            <option value="Cow">Cow</option>
                            <option value="Cow+">Cow+</option>
                            <option value="Sheep">Sheep</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>Session:</label>
                        <select id="session-filter" class="form-select">
                            <option value="">All Sessions</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>Date From:</label>
                        <input type="date" id="date-from" class="form-input">
                    </div>
                    <div class="filter-group">
                        <label>Date To:</label>
                        <input type="date" id="date-to" class="form-input">
                    </div>
                `,
                'questions': `
                    <div class="filter-group">
                        <label>Search:</label>
                        <input type="text" id="search-questions" class="form-input" placeholder="Search by question text...">
                    </div>
                    <div class="filter-group">
                        <label>Category:</label>
                        <select id="category-filter" class="form-select">
                            <option value="">All Categories</option>
                            <option value="Technical">Technical</option>
                            <option value="General">General</option>
                            <option value="Behavioral">Behavioral</option>
                            <option value="English">English</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>Times Asked:</label>
                        <input type="number" id="times-asked-min" class="form-input" placeholder="Min" min="0">
                    </div>
                    <div class="filter-group">
                        <label>Success Rate:</label>
                        <input type="number" id="success-rate-min" class="form-input" placeholder="Min %" min="0" max="100">
                    </div>
                `
            };
            
            return filterConfigs[tab] || '';
        }

        function generateSortOptions(tab) {
            const sortConfigs = {
                'interviews': `
                    <div class="sort-option">
                        <label>Sort by:</label>
                        <select id="sort-by" class="form-select" onchange="applyFilters('interviews')">
                            <option value="created_at_desc">Date (Newest First)</option>
                            <option value="created_at_asc">Date (Oldest First)</option>
                            <option value="student_name_asc">Student Name (A-Z)</option>
                            <option value="student_name_desc">Student Name (Z-A)</option>
                            <option value="student_email_asc">Student Email (A-Z)</option>
                            <option value="student_email_desc">Student Email (Z-A)</option>
                            <option value="zeta_id_asc">Zeta ID (A-Z)</option>
                            <option value="zeta_id_desc">Zeta ID (Z-A)</option>
                            <option value="status_asc">Status (A-Z)</option>
                            <option value="status_desc">Status (Z-A)</option>
                            <option value="verdict_asc">Verdict (A-Z)</option>
                            <option value="verdict_desc">Verdict (Z-A)</option>
                        </select>
                    </div>
                `,
                'questions': `
                    <div class="sort-option">
                        <label>Sort by:</label>
                        <select id="sort-by" class="form-select" onchange="applyFilters('questions')">
                            <option value="question_text_asc">Question (A-Z)</option>
                            <option value="question_text_desc">Question (Z-A)</option>
                            <option value="category_asc">Category (A-Z)</option>
                            <option value="category_desc">Category (Z-A)</option>
                            <option value="times_asked_desc">Times Asked (Most)</option>
                            <option value="times_asked_asc">Times Asked (Least)</option>
                            <option value="times_answered_correctly_desc">Correct Answers (Most)</option>
                            <option value="times_answered_correctly_asc">Correct Answers (Least)</option>
                            <option value="times_answered_incorrectly_desc">Incorrect Answers (Most)</option>
                            <option value="times_answered_incorrectly_asc">Incorrect Answers (Least)</option>
                            <option value="success_rate_desc">Success Rate (Highest)</option>
                            <option value="success_rate_asc">Success Rate (Lowest)</option>
                            <option value="created_at_desc">Date Added (Newest)</option>
                            <option value="created_at_asc">Date Added (Oldest)</option>
                        </select>
                    </div>
                `
            };
            
            return sortConfigs[tab] || '';
        }

        function generateGroupByOptions(tab) {
            const groupConfigs = {
                'interviews': `
                    <div class="group-by-option">
                        <input type="radio" id="group-none" name="group-by" value="" checked onchange="applyFilters('interviews')">
                        <label for="group-none">No Grouping</label>
                    </div>
                    <div class="group-by-option">
                        <input type="radio" id="group-status" name="group-by" value="status" onchange="applyFilters('interviews')">
                        <label for="group-status">By Status</label>
                    </div>
                    <div class="group-by-option">
                        <input type="radio" id="group-verdict" name="group-by" value="verdict" onchange="applyFilters('interviews')">
                        <label for="group-verdict">By Verdict</label>
                    </div>
                    <div class="group-by-option">
                        <input type="radio" id="group-date" name="group-by" value="created_date" onchange="applyFilters('interviews')">
                        <label for="group-date">By Date</label>
                    </div>
                `,
                'questions': `
                    <div class="group-by-option">
                        <input type="radio" id="group-none" name="group-by" value="" checked onchange="applyFilters('questions')">
                        <label for="group-none">No Grouping</label>
                    </div>
                    <div class="group-by-option">
                        <input type="radio" id="group-category" name="group-by" value="category" onchange="applyFilters('questions')">
                        <label for="group-category">By Category</label>
                    </div>
                    <div class="group-by-option">
                        <input type="radio" id="group-times-asked" name="group-by" value="times_asked" onchange="applyFilters('questions')">
                        <label for="group-times-asked">By Times Asked</label>
                    </div>
                `
            };
            
            return groupConfigs[tab] || '';
        }

        function closeFilterPanel() {
            document.querySelectorAll('.filter-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            document.getElementById('filter-panel-overlay').classList.remove('active');
        }

        function closeQuestionFilterPanel() {
            document.getElementById('question-filter-panel').classList.remove('active');
            document.getElementById('filter-panel-overlay').classList.remove('active');
        }

        // NEW UNIFIED FILTER SYSTEM
        function applyUnifiedFilters(tab, data) {
            console.log(`Applying unified filters for tab: ${tab}`);
            
            if (!data || !Array.isArray(data)) {
                console.warn('No data provided for filtering');
                return [];
            }
            
            let filtered = [...data];
            
            // Get filter values safely
            const getFilterValue = (id) => {
                const element = document.getElementById(id);
                return element ? element.value : '';
            };
            
            const getRadioValue = (name) => {
                const element = document.querySelector(`input[name="${name}"]:checked`);
                return element ? element.value : '';
            };
            
            switch(tab) {
                case 'interviews':
                    // Search filter
                    const searchTerm = getFilterValue('search-interviews');
                    if (searchTerm) {
                        filtered = filtered.filter(i => 
                            (i.student_name && i.student_name.toLowerCase().includes(searchTerm.toLowerCase())) ||
                            (i.student_email && i.student_email.toLowerCase().includes(searchTerm.toLowerCase())) ||
                            (i.zeta_id && i.zeta_id.toLowerCase().includes(searchTerm.toLowerCase()))
                        );
                    }
                    
                    // Status filter
                    const status = getFilterValue('status-filter');
                    if (status) {
                        filtered = filtered.filter(i => i.status === status);
                    }
                    
                    // Verdict filter
                    const verdict = getFilterValue('verdict-filter');
                    if (verdict) {
                        filtered = filtered.filter(i => i.verdict === verdict);
                    }

                    // Session filter
                    const sessionName = getFilterValue('session-filter');
                    if (sessionName) {
                        filtered = filtered.filter(i => (i.session_name || '') === sessionName);
                    }
                    
                    // Date filters
                    const dateFrom = getFilterValue('date-from');
                    const dateTo = getFilterValue('date-to');
                    if (dateFrom) {
                        filtered = filtered.filter(i => new Date(i.created_at || i.interview_date) >= new Date(dateFrom));
                    }
                    if (dateTo) {
                        filtered = filtered.filter(i => new Date(i.created_at || i.interview_date) <= new Date(dateTo));
                    }
                    
                    // Sort
                    const sortBy = getFilterValue('sort-by') || 'created_at_desc';
                    filtered = sortInterviews(filtered, sortBy);
                    break;
                    
                case 'questions':
                    // Search filter
                    const questionSearch = getFilterValue('search-questions');
                    if (questionSearch) {
                        filtered = filtered.filter(q => 
                            q.question_text && q.question_text.toLowerCase().includes(questionSearch.toLowerCase())
                        );
                    }
                    
                    // Category filter
                    const category = getFilterValue('category-filter');
                    if (category) {
                        filtered = filtered.filter(q => q.category === category);
                    }
                    
                    // Times asked filter
                    const timesAskedMin = getFilterValue('times-asked-min');
                    if (timesAskedMin) {
                        filtered = filtered.filter(q => (q.times_asked || 0) >= parseInt(timesAskedMin));
                    }
                    
                    // Success rate filter
                    const successRateMin = getFilterValue('success-rate-min');
                    if (successRateMin) {
                        filtered = filtered.filter(q => (q.success_rate || 0) >= parseInt(successRateMin));
                    }
                    
                    // Sort
                    const questionSortBy = getFilterValue('sort-by') || 'question_text_asc';
                    filtered = sortQuestions(filtered, questionSortBy);
                    break;
            }
            
            return filtered;
        }

        // Sorting functions
        function sortInterviews(interviews, sortBy) {
            if (!sortBy) return interviews;
            
            const [field, direction] = sortBy.split('_');
            const isAsc = direction === 'asc';
            
            return [...interviews].sort((a, b) => {
                let aVal = a[field];
                let bVal = b[field];
                
                // Handle date fields
                if (field.includes('date') || field.includes('created_at')) {
                    aVal = new Date(aVal || 0);
                    bVal = new Date(bVal || 0);
                }
                
                // Handle string fields
                if (typeof aVal === 'string') {
                    aVal = aVal.toLowerCase();
                    bVal = bVal.toLowerCase();
                }
                
                if (aVal < bVal) return isAsc ? -1 : 1;
                if (aVal > bVal) return isAsc ? 1 : -1;
                return 0;
            });
        }

        function sortQuestions(questions, sortBy) {
            if (!sortBy) return questions;
            
            const [field, direction] = sortBy.split('_');
            const isAsc = direction === 'asc';
            
            return [...questions].sort((a, b) => {
                let aVal = a[field];
                let bVal = b[field];
                
                // Handle date fields
                if (field.includes('date') || field.includes('created_at')) {
                    aVal = new Date(aVal || 0);
                    bVal = new Date(bVal || 0);
                }
                
                // Handle string fields
                if (typeof aVal === 'string') {
                    aVal = aVal.toLowerCase();
                    bVal = bVal.toLowerCase();
                }
                
                if (aVal < bVal) return isAsc ? -1 : 1;
                if (aVal > bVal) return isAsc ? 1 : -1;
                return 0;
            });
        }

        // Grouping functions
        function groupInterviews(interviews, groupBy) {
            if (!groupBy || groupBy === 'none') {
                return { interviews };
            }
            
            const groups = {};
            
            interviews.forEach(interview => {
                let groupKey = '';
                
                switch(groupBy) {
                    case 'status':
                        groupKey = interview.status || 'Unknown';
                        break;
                    case 'verdict':
                        groupKey = interview.verdict || 'Unknown';
                        break;
                    case 'created_date':
                        groupKey = new Date(interview.created_at).toLocaleDateString();
                        break;
                    default:
                        groupKey = 'All';
                }
                
                if (!groups[groupKey]) {
                    groups[groupKey] = [];
                }
                groups[groupKey].push(interview);
            });
            
            return groups;
        }

        function displayGroupedInterviews(groupedData, tbody) {
            let html = '';
            
            Object.keys(groupedData).forEach(groupKey => {
                const interviews = groupedData[groupKey];
                html += `
                    <tr class="group-header">
                        <td colspan="6" class="group-title">${groupKey} (${interviews.length} interviews)</td>
                    </tr>
                `;
                
                interviews.forEach(interview => {
                    html += `
                        <tr>
                            <td>${new Date(interview.created_at).toLocaleDateString()}</td>
                            <td>${interview.student_name}</td>
                            <td>${interview.zeta_id}</td>
                            <td>${interview.session_name || 'N/A'}</td>
                            <td><span class="status-badge status-${interview.status}">${interview.status}</span></td>
                            <td>
                                <button class="btn-view" onclick="viewInterview(${interview.id})">View</button>
                            </td>
                        </tr>
                    `;
                });
            });
            
            tbody.innerHTML = html;
        }

        // Dynamic filter functions
        function applyFilters(tab, closePanel = false) {
            console.log(`Applying filters for tab: ${tab}`);
            
            // Get group by value
            const getRadioValue = (name) => {
                const element = document.querySelector(`input[name="${name}"]:checked`);
                return element ? element.value : '';
            };
            const groupBy = getRadioValue('group-by');
            
            // Use the new unified system
            let filteredData = [];
            let displayFunction = null;
            
            switch(tab) {
                case 'interviews':
                    filteredData = applyUnifiedFilters('interviews', interviews);
                    displayFunction = () => displayInterviews(filteredData, groupBy);
                    break;
                case 'questions':
                    filteredData = applyUnifiedFilters('questions', questions);
                    displayFunction = () => displayQuestionAnalytics(filteredData);
                    break;
                default:
                    console.log('Unknown tab:', tab);
                    return;
            }
            
            // Display the filtered results
            if (displayFunction) {
                displayFunction();
            }
            
            // Only close panel if explicitly requested (from Apply button)
            if (closePanel) {
                closeFilterPanel();
            }
        }

        function clearAllFilters(tab) {
            console.log(`Clearing filters for tab: ${tab}`);
            
            // Clear all filter inputs in the current filter panel
            let filterPanel;
            if (tab === 'questions') {
                filterPanel = document.getElementById('question-filter-panel');
            } else {
                filterPanel = document.getElementById('filter-panel');
            }
            
            const inputs = filterPanel.querySelectorAll('input, select');
            inputs.forEach(input => {
                if (input.type === 'radio') {
                    if (input.value === '') {
                        input.checked = true;
                    } else {
                        input.checked = false;
                    }
                } else {
                    input.value = '';
                }
            });
            
            // Apply the cleared filters
            applyFilters(tab);
        }

        function exportData(tab) {
            console.log(`Exporting data for tab: ${tab}`);
            
            switch(tab) {
                case 'interviews':
                    exportInterviews();
                    break;
                case 'questions':
                    exportQuestions();
                    break;
                default:
                    console.log('Unknown tab:', tab);
            }
        }

        // REMOVED: Old conflicting filter functions - replaced with unified system
        /*
        function applyInterviewsFilters() {
            const searchTerm = document.getElementById('search-interviews')?.value || '';
            const status = document.getElementById('status-filter')?.value || '';
            const verdict = document.getElementById('verdict-filter')?.value || '';
            const dateFrom = document.getElementById('date-from')?.value || '';
            const dateTo = document.getElementById('date-to')?.value || '';
            const sortBy = document.getElementById('sort-by')?.value || 'created_at_desc';
            const groupBy = document.querySelector('input[name="group-by"]:checked')?.value || '';

            console.log('Interviews filters:', { searchTerm, status, verdict, dateFrom, dateTo, sortBy, groupBy });
            
            // Apply filters to interviews data
            let filteredInterviews = [...interviews];
            
            // Search filter
            if (searchTerm) {
                filteredInterviews = filteredInterviews.filter(i => 
                    i.student_name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    i.student_email.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    i.zeta_id.toLowerCase().includes(searchTerm.toLowerCase())
                );
            }
            
            // Status filter
            if (status) {
                filteredInterviews = filteredInterviews.filter(i => i.status === status);
            }
            
            // Verdict filter
            if (verdict) {
                filteredInterviews = filteredInterviews.filter(i => i.verdict === verdict);
            }
            
            // Date filters
            if (dateFrom) {
                filteredInterviews = filteredInterviews.filter(i => new Date(i.created_at) >= new Date(dateFrom));
            }
            if (dateTo) {
                filteredInterviews = filteredInterviews.filter(i => new Date(i.created_at) <= new Date(dateTo));
            }
            
            // Sort
            filteredInterviews = sortInterviews(filteredInterviews, sortBy);
            
            // Display filtered results
            displayInterviews(filteredInterviews, groupBy);
        }
        */

        /*
        function applyQuestionsFilters() {
            const searchTerm = document.getElementById('search-questions')?.value || '';
            const category = document.getElementById('category-filter')?.value || '';
            const timesAskedMin = document.getElementById('times-asked-min')?.value || '';
            const successRateMin = document.getElementById('success-rate-min')?.value || '';
            const sortBy = document.getElementById('sort-by')?.value || 'times_asked_desc';
            const groupBy = document.querySelector('input[name="group-by"]:checked')?.value || '';

            console.log('Questions filters:', { searchTerm, category, timesAskedMin, successRateMin, sortBy, groupBy });
            
            // Apply filters to questions data
            let filteredQuestions = [...questions];
            
            // Search filter
            if (searchTerm) {
                filteredQuestions = filteredQuestions.filter(q => 
                    q.question.toLowerCase().includes(searchTerm.toLowerCase())
                );
            }
            
            // Category filter
            if (category) {
                filteredQuestions = filteredQuestions.filter(q => q.category === category);
            }
            
            // Times asked filter
            if (timesAskedMin) {
                filteredQuestions = filteredQuestions.filter(q => q.times_asked >= parseInt(timesAskedMin));
            }
            
            // Success rate filter
            if (successRateMin) {
                filteredQuestions = filteredQuestions.filter(q => q.success_rate >= parseInt(successRateMin));
            }
            
            // Sort
            filteredQuestions = sortQuestions(filteredQuestions, sortBy);
            
            // Display filtered results
            displayQuestions(filteredQuestions, groupBy);
        }
        */

        /*
        // Sorting functions
        function sortInterviews(interviews, sortBy) {
            return interviews.sort((a, b) => {
                const [field, direction] = sortBy.split('_');
                let aVal, bVal;
                
                if (field === 'student_name') {
                    aVal = a.student_name;
                    bVal = b.student_name;
                } else if (field === 'duration') {
                    aVal = a.duration_seconds;
                    bVal = b.duration_seconds;
                } else {
                    aVal = a[field];
                    bVal = b[field];
                }
                
                if (direction === 'asc') {
                    return aVal > bVal ? 1 : -1;
                } else {
                    return aVal < bVal ? 1 : -1;
                }
            });
        }

        function sortQuestions(questions, sortBy) {
            return questions.sort((a, b) => {
                const [field, direction] = sortBy.split('_');
                const aVal = a[field];
                const bVal = b[field];
                
                if (direction === 'asc') {
                    return aVal > bVal ? 1 : -1;
                } else {
                    return aVal < bVal ? 1 : -1;
                }
            });
        }
        */

        // Export functions
        function exportInterviews() {
            const filteredInterviews = getCurrentFilteredInterviews();
            const csvContent = generateInterviewsCSV(filteredInterviews);
            downloadCSV(csvContent, 'my-interviews.csv');
        }

        function exportQuestions() {
            const filteredQuestions = getCurrentFilteredQuestions();
            const csvContent = generateQuestionsCSV(filteredQuestions);
            downloadCSV(csvContent, 'questions.csv');
        }

        // Helper functions for getting current filtered data
        function getCurrentFilteredInterviews() {
            return interviews || [];
        }

        function getCurrentFilteredQuestions() {
            return questions || [];
        }

        // CSV generation functions
        function generateInterviewsCSV(interviews) {
            const headers = ['Date', 'Student Name', 'Zeta ID', 'Session', 'Status', 'Verdict', 'Duration (min)'];
            const rows = interviews.map(i => [
                new Date(i.created_at).toLocaleDateString(),
                `"${i.student_name.replace(/"/g, '""')}"`,
                i.zeta_id,
                i.session_name || 'N/A',
                i.status,
                i.verdict || 'N/A',
                Math.round(i.duration_seconds / 60)
            ]);
            return [headers.join(','), ...rows.map(row => row.join(','))].join('\n');
        }

        function generateQuestionsCSV(questions) {
            const headers = ['Question', 'Category', 'Times Asked', 'Correct Answers', 'Incorrect Answers', 'Success Rate', 'Created At'];
            const rows = questions.map(q => [
                `"${q.question.replace(/"/g, '""')}"`,
                q.category,
                q.times_asked,
                q.correct_answers,
                q.incorrect_answers,
                q.success_rate,
                new Date(q.created_at).toLocaleDateString()
            ]);
            return [headers.join(','), ...rows.map(row => row.join(','))].join('\n');
        }

        function downloadCSV(content, filename) {
            const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        async function loadMyInterviews() {
            const tbody = document.getElementById('interviews-table-body');
            tbody.innerHTML = `<tr><td colspan="8" class="loading">Loading interviews...</td></tr>`;
            try {
                const userEmail = currentUser?.email || '';
                const response = await fetch(`/api/interviewer/interviews?email=${encodeURIComponent(userEmail)}`);
                const result = await response.json();
                if (result.success) {
                    interviews = result.data; // Store in global interviews variable
                    
                    // Populate filter options with real data
                    populateFilterOptions();
                    
                    // Display interviews using the new unified system
                    displayInterviews(interviews);
                } else {
                    showEmptyState('interviews-table-body', 'Failed to load interviews.');
                }
            } catch (error) {
                console.error('Error loading interviews:', error);
                showEmptyState('interviews-table-body', 'Error loading interviews.');
            }
        }

        // Alias for backward compatibility
        function loadInterviews() {
            loadMyInterviews();
        }

        async function loadSessions() {
            try {
                console.log('Loading sessions...');
                const response = await fetch('/api/admin/sessions');
                const data = await response.json();
                console.log('Sessions response:', data);
                
                if (data.success) {
                    sessions = data.data;
                    console.log('Sessions loaded:', sessions.length);
                    populateSessionFilter();
                } else {
                    console.error('Failed to load sessions:', data.error);
                }
            } catch (error) {
                console.error('Error loading sessions:', error);
            }
        }

        function populateSessionFilter() {
            const sessionFilter = document.getElementById('session-filter');
            console.log('populateSessionFilter called, sessionFilter element:', sessionFilter);
            if (!sessionFilter) {
                console.error('Session filter element not found');
                return;
            }
            
            // Clear existing options except "All Sessions"
            sessionFilter.innerHTML = '<option value="">All Sessions</option>';
            
            // Add unique session names from all sessions
            const uniqueSessions = [...new Set(sessions.map(session => session.name))];
            console.log('Unique sessions to add:', uniqueSessions);
            uniqueSessions.forEach(sessionName => {
                const option = document.createElement('option');
                option.value = sessionName;
                option.textContent = sessionName;
                sessionFilter.appendChild(option);
            });
            console.log('Session filter populated with', uniqueSessions.length, 'sessions');
        }

        async function loadStats() {
            try {
                const userEmail = currentUser?.email || '';
                const response = await fetch(`/api/interviewer/stats?email=${encodeURIComponent(userEmail)}`);
                const result = await response.json();
                if (result.success) {
                    document.getElementById('total-interviews').textContent = result.data.total;
                    document.getElementById('completed-interviews').textContent = result.data.completed;
                    document.getElementById('in-progress-interviews').textContent = result.data.in_progress;
                } else {
                    console.error('Failed to load stats:', result.error);
                }
            } catch (error) {
                console.error('Error loading stats:', error);
            }
        }

        async function loadFavoriteQuestions() {
            try {
                const userEmail = currentUser?.email || '';
                const response = await fetch(`/api/interviewer/favorites?email=${encodeURIComponent(userEmail)}`);
                const result = await response.json();
                if (result.success) {
                    favoriteQuestionIds = new Set(result.data.map(fav => fav.question_id));
                    document.getElementById('favorite-questions').textContent = favoriteQuestionIds.size;
                } else {
                    console.error('Failed to load favorite questions:', result.error);
                }
            } catch (error) {
                console.error('Error loading favorite questions:', error);
            }
        }

        function displayInterviews(interviewsToDisplay, groupBy = '') {
            const tbody = document.getElementById('interviews-table-body');
            if (!tbody) return;

            if (interviewsToDisplay.length === 0) {
                showEmptyState('interviews-table-body', 'No interviews found.');
                return;
            }

            // Handle grouping if specified
            if (groupBy) {
                const groupedData = groupInterviews(interviewsToDisplay, groupBy);
                displayGroupedInterviews(groupedData, tbody);
                return;
            }

            tbody.innerHTML = interviewsToDisplay.map(interview => `
                <tr>
                    <td>${new Date(interview.created_at).toLocaleDateString()}</td>
                    <td>${interview.student_name}</td>
                    <td>${interview.zeta_id}</td>
                    <td>${interview.session_name || 'N/A'}</td>
                    <td><span class="status-badge status-${interview.status}">${interview.status}</span></td>
                    <td>${interview.verdict || 'N/A'}</td>
                    <td>${formatDuration(interview.duration_seconds)}</td>
                    <td>
                        ${interview.status === 'in_progress' ? `<button class="btn btn-primary btn-sm" onclick="resumeMyInterview(${interview.id})">Resume</button>` : ''}
                        <button class="btn btn-primary btn-sm" onclick="viewInterview(${interview.id})">View</button>
                    </td>
                </tr>
            `).join('');
        }

        // Enhanced Filter, Sort, and Group Functions
        
        // NEW: Unified Filter System for Interviewer Dashboard
        function applyFilters(tab, closePanel = false) {
            console.log('Applying filters for tab:', tab);
            
            // Get the group by value
            const groupByRadio = document.querySelector('input[name="group-by"]:checked');
            const groupBy = groupByRadio ? groupByRadio.value : '';
            
            let filteredData = [];
            let displayFunction = null;
            
            switch(tab) {
                case 'interviews':
                    filteredData = applyUnifiedFilters('interviews', interviews);
                    displayFunction = () => displayInterviews(filteredData, groupBy);
                    break;
                case 'questions':
                    filteredData = applyUnifiedFilters('questions', questions);
                    displayFunction = () => displayQuestionAnalytics(filteredData, groupBy);
                    break;
                default:
                    console.log('Unknown tab:', tab);
                    return;
            }
            
            // Execute display function
            if (displayFunction) {
                displayFunction();
            }
            
            // Close panel if requested
            if (closePanel) {
                closeFilterPanel();
            }
        }
        
        // NEW: Unified filter system
        function applyUnifiedFilters(tab, data) {
            if (!data || data.length === 0) return [];
            
            let filtered = [...data];
            
            // Get filter values safely
            const searchTerm = getFilterValue('search-input') || '';
            const statusFilter = getFilterValue('status-filter') || '';
            const verdictFilter = getFilterValue('verdict-filter') || '';
            const dateFrom = getFilterValue('date-from') || '';
            const dateTo = getFilterValue('date-to') || '';
            const sortBy = getFilterValue('sort-by') || '';
            
            // Apply search filter
            if (searchTerm) {
                filtered = filtered.filter(item => {
                    if (tab === 'interviews') {
                        return (item.student_name && item.student_name.toLowerCase().includes(searchTerm.toLowerCase())) ||
                               (item.zeta_id && item.zeta_id.toLowerCase().includes(searchTerm.toLowerCase())) ||
                               (item.student_email && item.student_email.toLowerCase().includes(searchTerm.toLowerCase()));
                    } else if (tab === 'questions') {
                        return (item.question_text && item.question_text.toLowerCase().includes(searchTerm.toLowerCase())) ||
                               (item.category && item.category.toLowerCase().includes(searchTerm.toLowerCase()));
                    }
                    return false;
                });
            }
            
            // Apply status filter
            if (statusFilter && tab === 'interviews') {
                filtered = filtered.filter(item => item.status === statusFilter);
            }
            
            // Apply verdict filter
            if (verdictFilter && tab === 'interviews') {
                filtered = filtered.filter(item => item.verdict === verdictFilter);
            }
            
            // Apply date filters
            if (dateFrom && tab === 'interviews') {
                const fromDate = new Date(dateFrom);
                filtered = filtered.filter(item => {
                    const itemDate = new Date(item.interview_date || item.created_at);
                    return itemDate >= fromDate;
                });
            }
            
            if (dateTo && tab === 'interviews') {
                const toDate = new Date(dateTo);
                toDate.setHours(23, 59, 59, 999);
                filtered = filtered.filter(item => {
                    const itemDate = new Date(item.interview_date || item.created_at);
                    return itemDate <= toDate;
                });
            }
            
            // Apply sorting
            if (sortBy) {
                if (tab === 'interviews') {
                    filtered = sortInterviews(filtered, sortBy);
                } else if (tab === 'questions') {
                    filtered = sortQuestions(filtered, sortBy);
                }
            }
            
            return filtered;
        }
        
        // Helper function to safely get filter values
        function getFilterValue(elementId) {
            const element = document.getElementById(elementId);
            return element ? element.value : '';
        }
        
        // Helper function to safely get radio values
        function getRadioValue(name) {
            const radio = document.querySelector(`input[name="${name}"]:checked`);
            return radio ? radio.value : '';
        }
        
        // NEW: Sorting functions
        function sortInterviews(interviews, sortBy) {
            const sorted = [...interviews];
            
            switch (sortBy) {
                case 'created_at_asc':
                    return sorted.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
                case 'created_at_desc':
                    return sorted.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
                case 'student_name_asc':
                    return sorted.sort((a, b) => (a.student_name || '').localeCompare(b.student_name || ''));
                case 'student_name_desc':
                    return sorted.sort((a, b) => (b.student_name || '').localeCompare(a.student_name || ''));
                case 'zeta_id_asc':
                    return sorted.sort((a, b) => (a.zeta_id || '').localeCompare(b.zeta_id || ''));
                case 'zeta_id_desc':
                    return sorted.sort((a, b) => (b.zeta_id || '').localeCompare(a.zeta_id || ''));
                case 'status_asc':
                    return sorted.sort((a, b) => (a.status || '').localeCompare(b.status || ''));
                case 'status_desc':
                    return sorted.sort((a, b) => (b.status || '').localeCompare(a.status || ''));
                case 'verdict_asc':
                    return sorted.sort((a, b) => (a.verdict || '').localeCompare(b.verdict || ''));
                case 'verdict_desc':
                    return sorted.sort((a, b) => (b.verdict || '').localeCompare(a.verdict || ''));
                default:
                    return sorted;
            }
        }
        
        function sortQuestions(questions, sortBy) {
            const sorted = [...questions];
            
            switch (sortBy) {
                case 'question_text_asc':
                    return sorted.sort((a, b) => (a.question_text || '').localeCompare(b.question_text || ''));
                case 'question_text_desc':
                    return sorted.sort((a, b) => (b.question_text || '').localeCompare(a.question_text || ''));
                case 'category_asc':
                    return sorted.sort((a, b) => (a.category || '').localeCompare(b.category || ''));
                case 'category_desc':
                    return sorted.sort((a, b) => (b.category || '').localeCompare(a.category || ''));
                case 'times_asked_asc':
                    return sorted.sort((a, b) => (a.times_asked || 0) - (b.times_asked || 0));
                case 'times_asked_desc':
                    return sorted.sort((a, b) => (b.times_asked || 0) - (a.times_asked || 0));
                case 'success_rate_asc':
                    return sorted.sort((a, b) => (a.success_rate || 0) - (b.success_rate || 0));
                case 'success_rate_desc':
                    return sorted.sort((a, b) => (b.success_rate || 0) - (a.success_rate || 0));
                default:
                    return sorted;
            }
        }
        
        // NEW: Grouping functions
        function groupInterviews(interviews, groupBy) {
            if (!groupBy) return { groups: null, interviews };
            
            const groups = {};
            
            interviews.forEach(interview => {
                let groupKey;
                switch (groupBy) {
                    case 'status':
                        groupKey = interview.status || 'Unknown';
                        break;
                    case 'verdict':
                        groupKey = interview.verdict || 'No Verdict';
                        break;
                    case 'date':
                        groupKey = formatDate(interview.interview_date || interview.created_at);
                        break;
                    case 'duration':
                        const duration = interview.duration_seconds || 0;
                        const minutes = Math.floor(duration / 60);
                        if (minutes < 5) groupKey = '0-5 minutes';
                        else if (minutes < 15) groupKey = '5-15 minutes';
                        else if (minutes < 30) groupKey = '15-30 minutes';
                        else if (minutes < 60) groupKey = '30-60 minutes';
                        else groupKey = '60+ minutes';
                        break;
                    default:
                        groupKey = 'Other';
                }
                
                if (!groups[groupKey]) {
                    groups[groupKey] = [];
                }
                groups[groupKey].push(interview);
            });
            
            return { groups, interviews };
        }
        
        function displayGroupedInterviews(groupedData, tbody) {
            const { groups } = groupedData;
            let html = '';
            
            Object.keys(groups).sort().forEach(groupKey => {
                const groupInterviews = groups[groupKey];
                html += `
                    <tr class="group-header">
                        <td colspan="8" style="background: #2d3748; color: white; font-weight: 600; padding: 12px;">
                            ${groupKey} (${groupInterviews.length} interviews)
                        </td>
                    </tr>
                `;
                
                groupInterviews.forEach(interview => {
                    html += `
                        <tr data-row-id="${interview.id}">
                            <td>${new Date(interview.created_at).toLocaleDateString()}</td>
                            <td>${interview.student_name || 'N/A'}</td>
                            <td>${interview.zeta_id || 'N/A'}</td>
                            <td>${interview.session_name || 'N/A'}</td>
                            <td><span class="status-badge status-${interview.status}">${interview.status}</span></td>
                            <td>${interview.verdict || 'N/A'}</td>
                            <td>${formatDuration(interview.duration_seconds)}</td>
                            <td>
                                <button class="btn btn-primary btn-sm" onclick="viewInterview(${interview.id})">View</button>
                            </td>
                        </tr>
                    `;
                });
            });
            
            tbody.innerHTML = html;
        }
        
        // NEW: Function to populate filter dropdowns with real data
        function populateFilterOptions() {
            if (!interviews || interviews.length === 0) return;
            
            // Populate status filter
            const statusFilter = document.getElementById('status-filter');
            if (statusFilter) {
                const statuses = [...new Set(interviews.map(i => i.status).filter(Boolean))];
                const currentValue = statusFilter.value;
                statusFilter.innerHTML = '<option value="">All Statuses</option>' + 
                    statuses.map(status => `<option value="${status}">${status}</option>`).join('');
                statusFilter.value = currentValue;
            }
            
            // Populate verdict filter
            const verdictFilter = document.getElementById('verdict-filter');
            if (verdictFilter) {
                const verdicts = [...new Set(interviews.map(i => i.verdict).filter(Boolean))];
                const currentValue = verdictFilter.value;
                verdictFilter.innerHTML = '<option value="">All Verdicts</option>' + 
                    verdicts.map(verdict => `<option value="${verdict}">${verdict}</option>`).join('');
                verdictFilter.value = currentValue;
            }
        }
        
        // NEW: Function to populate question filter options
        function populateQuestionFilterOptions() {
            if (!questions || questions.length === 0) return;
            
            // Populate category filter for questions
            const categoryFilter = document.getElementById('category-filter');
            if (categoryFilter) {
                const categories = [...new Set(questions.map(q => q.category).filter(Boolean))];
                const currentValue = categoryFilter.value;
                categoryFilter.innerHTML = '<option value="">All Categories</option>' + 
                    categories.map(category => `<option value="${category}">${category}</option>`).join('');
                categoryFilter.value = currentValue;
            }
        }
        
        // NEW: Clear all filters function
        function clearAllFilters(tab) {
            console.log('Clearing all filters for tab:', tab);
            
            // Clear all filter inputs
            const searchInput = document.getElementById('search-input');
            if (searchInput) searchInput.value = '';
            
            const statusFilter = document.getElementById('status-filter');
            if (statusFilter) statusFilter.value = '';
            
            const verdictFilter = document.getElementById('verdict-filter');
            if (verdictFilter) verdictFilter.value = '';
            
            const dateFrom = document.getElementById('date-from');
            if (dateFrom) dateFrom.value = '';
            
            const dateTo = document.getElementById('date-to');
            if (dateTo) dateTo.value = '';
            
            const sortBy = document.getElementById('sort-by');
            if (sortBy) sortBy.value = '';
            
            // Reset grouping
            const groupNone = document.getElementById('group-none');
            if (groupNone) groupNone.checked = true;
            
            // Apply filters to refresh display
            applyFilters(tab);
        }

        // REMOVED: Old conflicting displayFilteredInterviews function

        // REMOVED: Old conflicting applyFiltersToInterviews function

        // REMOVED: Old conflicting applySortingToInterviews function
        
        function getSortFunction(sortKey) {
            switch (sortKey) {
                case 'created_at_desc':
                    return (a, b) => new Date(b.created_at) - new Date(a.created_at);
                case 'created_at_asc':
                    return (a, b) => new Date(a.created_at) - new Date(b.created_at);
                case 'student_name_asc':
                    return (a, b) => (a.student_name || '').localeCompare(b.student_name || '');
                case 'student_name_desc':
                    return (a, b) => (b.student_name || '').localeCompare(a.student_name || '');
                case 'duration_desc':
                    return (a, b) => (b.duration_seconds || 0) - (a.duration_seconds || 0);
                case 'duration_asc':
                    return (a, b) => (a.duration_seconds || 0) - (b.duration_seconds || 0);
                case 'status_asc':
                    return (a, b) => (a.status || '').localeCompare(b.status || '');
                case 'status_desc':
                    return (a, b) => (b.status || '').localeCompare(a.status || '');
                case 'verdict_asc':
                    return (a, b) => (a.verdict || '').localeCompare(b.verdict || '');
                case 'verdict_desc':
                    return (a, b) => (b.verdict || '').localeCompare(a.verdict || '');
                default:
                    return null;
            }
        }

        // REMOVED: Old conflicting applyGroupingToInterviews function

        // REMOVED: Old conflicting displayGroupedInterviews function

        // REMOVED: Old conflicting clearAllFilters function
        
        // REMOVED: Old conflicting updateResultsSummary function
        
        // REMOVED: Old conflicting exportInterviews function

        async function loadQuestions() {
            const questionListDiv = document.getElementById('question-bank-list');
            questionListDiv.innerHTML = '<div class="loading">Loading questions...</div>';

            try {
                // Always load analytics for Question Analysis view
                const response = await fetch('/api/admin/questions/analytics');
                const result = await response.json();

                if (result.success) {
                    questions = result.data || []; // Store in global questions variable
                    allQuestions = questions; // Keep for backward compatibility

                    // Populate filter options with real data
                    populateQuestionFilterOptions();

                    // Display questions using the new unified system
                    displayQuestionAnalytics(questions);
                } else {
                    console.error('Failed to load questions analytics:', result.error);
                    questionListDiv.innerHTML = `<div class="empty-state">Failed to load questions.</div>`;
                }
            } catch (error) {
                console.error('Error loading questions analytics:', error);
                questionListDiv.innerHTML = `<div class="empty-state">Error loading questions.</div>`;
            }
        }

        function applyQuestionSorting(questions, sortBy) {
            const sorted = [...questions];
            
            switch (sortBy) {
                case 'popularity': // times asked desc
                    return sorted.sort((a, b) => ((b.times_asked ?? b.count_of_times_asked ?? 0) - (a.times_asked ?? a.count_of_times_asked ?? 0)));
                case 'recent': // fallback to id desc if created_at not present
                    return sorted.sort((a, b) => (b.created_at ? new Date(b.created_at) - new Date(a.created_at) : (b.id || 0) - (a.id || 0)));
                case 'alphabetical':
                    return sorted.sort((a, b) => (a.question || '').localeCompare(b.question || ''));
                case 'category':
                    return sorted.sort((a, b) => (a.category || '').localeCompare(b.category || ''));
                default:
                    return sorted;
            }
        }

        function clearQuestionFilters() {
            document.getElementById('bank-search-input').value = '';
            document.getElementById('bank-category-select').value = '';
            document.getElementById('question-sort-by').value = 'popularity';
            loadQuestions();
        }

        function updateQuestionResultsSummary(count) {
            const summaryElement = document.getElementById('question-results-summary');
            if (summaryElement) {
                summaryElement.innerHTML = `<strong>${count}</strong> questions found`;
                summaryElement.style.display = count > 0 ? 'block' : 'none';
            }
        }

        function exportQuestions() {
            if (!allQuestions || allQuestions.length === 0) {
                alert('No questions to export');
                return;
            }

            // Create CSV content
            const headers = ['Question', 'Category', 'Times Asked'];
            const csvContent = [
                headers.join(','),
                ...allQuestions.map(q => [
                    `"${q.question || ''}"`,
                    `"${q.category || ''}"`,
                    q.count_of_times_asked || 0
                ].join(','))
            ].join('\n');
            
            // Download CSV
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `question_bank_export_${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }

        function displayQuestionAnalytics(questionsToDisplay) {
            const questionListDiv = document.getElementById('question-bank-list');
            if (!questionListDiv) return;

            if (!questionsToDisplay.length) {
                questionListDiv.innerHTML = '<div class="empty-state">No questions found.</div>';
                return;
            }

            const rows = questionsToDisplay.map(q => {
                const timesAsked = q.times_asked ?? q.count_of_times_asked ?? 0;
                const correct = q.correct_answers ?? q.times_answered_correctly ?? 0;
                const incorrect = q.incorrect_answers ?? q.times_answered_incorrectly ?? 0;
                const success = q.success_rate != null ? `${q.success_rate}%` : '-';
                const isFavorited = favoriteQuestionIds.has(q.id);
                return `
                    <tr>
                        <td>
                            <span class="question-text">${q.question || '-'}</span>
                            <button class="favorite-btn ${isFavorited ? 'favorited' : ''}" 
                                    onclick="toggleFavorite(${q.id})" 
                                    title="${isFavorited ? 'Remove from favorites' : 'Add to favorites'}" style="margin-left:8px">
                                ${isFavorited ? '★' : '☆'}
                            </button>
                        </td>
                        <td>${q.category || '-'}</td>
                        <td>${timesAsked}</td>
                        <td>${correct}</td>
                        <td>${incorrect}</td>
                        <td>${success}</td>
                        <td>
                            <button class="btn btn-primary btn-sm" onclick="viewQuestionDetails(${q.id})">View</button>
                        </td>
                    </tr>
                `;
            }).join('');

            questionListDiv.innerHTML = `
                <div class="table-container">
                    <table class="table">
                        <thead>
                            <tr>
                                <th>Question</th>
                                <th>Category</th>
                                <th>Times Asked</th>
                                <th>Correct Answers</th>
                                <th>Incorrect Answers</th>
                                <th>Success Rate</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${rows}
                        </tbody>
                    </table>
                </div>
            `;
        }

        async function viewQuestionDetails(questionId) {
            try {
                const res = await fetch(`/api/admin/questions/${questionId}/details`);
                const json = await res.json();
                if (!res.ok || !json.success) throw new Error(json.error || `HTTP ${res.status}`);

                const q = json.data || json; // support both shapes
                const timesAsked = q.times_asked ?? q.count_of_times_asked ?? 0;
                const correct = q.correct_answers ?? q.times_answered_correctly ?? 0;
                const incorrect = q.incorrect_answers ?? q.times_answered_incorrectly ?? 0;
                const success = q.success_rate != null ? `${q.success_rate}%` : '-';

                const answersHtml = (q.student_answers || []).map(a => `
                    <div class="question-answer-item">
                        <p><strong>${a.student_name || 'Student'}</strong> (${a.zeta_id || '-'})</p>
                        <p>Answered at: ${a.answered_at ? formatDate(a.answered_at) : '-'}</p>
                        <p>Answer: ${a.answer_text || '-'}</p>
                    </div>
                `).join('') || '<p>No answers recorded.</p>';

                const content = `
                    <div class="detail-section">
                        <h4 class="detail-section-title">Question Information</h4>
                        <div class="detail-item"><div class="detail-label">Question</div><div class="detail-value">${q.question || '-'}</div></div>
                        <div class="detail-item"><div class="detail-label">Category</div><div class="detail-value">${q.category || '-'}</div></div>
                        <div class="detail-item"><div class="detail-label">Times Asked</div><div class="detail-value">${timesAsked}</div></div>
                        <div class="detail-item"><div class="detail-label">Correct Answers</div><div class="detail-value">${correct}</div></div>
                        <div class="detail-item"><div class="detail-label">Incorrect Answers</div><div class="detail-value">${incorrect}</div></div>
                        <div class="detail-item"><div class="detail-label">Success Rate</div><div class="detail-value">${success}</div></div>
                    </div>
                    <div class="detail-section">
                        <h4 class="detail-section-title">Student Answers</h4>
                        ${answersHtml}
                    </div>
                `;

                openDetailPanel('Question Details', content);
            } catch (e) {
                console.error('Error loading question details:', e);
                showError(e.message || 'Failed to load question details');
            }
        }

        async function toggleFavorite(questionId) {
            try {
                const isFavorited = favoriteQuestionIds.has(questionId);
                const method = isFavorited ? 'DELETE' : 'POST';
                const userEmail = currentUser?.email || '';
                
                const response = await fetch(`/api/interviewer/favorites?email=${encodeURIComponent(userEmail)}`, {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ question_id: questionId })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    if (isFavorited) {
                        favoriteQuestionIds.delete(questionId);
                    } else {
                        favoriteQuestionIds.add(questionId);
                    }
                    
                    updateFavoriteButtons();
                    updateFavoriteCount();
                    
                    const activeCategory = document.getElementById('bank-category-select').value;
                    if (activeCategory === 'Favorites') {
                        loadQuestions();
                    }
                } else {
                    console.error('Error toggling favorite:', result.error);
                }
            } catch (error) {
                console.error('Error toggling favorite:', error);
            }
        }

        function updateFavoriteButtons() {
            document.querySelectorAll('.favorite-btn').forEach(btn => {
                const questionId = parseInt(btn.onclick.toString().match(/\d+/)[0]);
                if (favoriteQuestionIds.has(questionId)) {
                    btn.classList.add('favorited');
                    btn.textContent = '★';
                    btn.title = 'Remove from favorites';
                } else {
                    btn.classList.remove('favorited');
                    btn.textContent = '☆';
                    btn.title = 'Add to favorites';
                }
            });
        }

        function updateFavoriteCount() {
            document.getElementById('favorite-questions').textContent = favoriteQuestionIds.size;
        }

        async function viewInterview(interviewId) {
            try {
                // Get interview details
                const interviewResponse = await fetch(`/api/interviews/${interviewId}`);
                const interviewData = await interviewResponse.json();
                
                if (!interviewData.success) {
                    showError('Interview not found');
                    return;
                }


                const interview = interviewData.data;

                // Get student details
                let studentInfo = 'Unknown Student';
                if (interview.student_id) {
                    try {
                        const studentResponse = await fetch(`/api/students/${interview.student_id}`);
                        const studentData = await studentResponse.json();
                        if (studentData.success) {
                            const student = studentData.data;
                            studentInfo = `${student.first_name} ${student.last_name} (${student.zeta_id})`;
                        }
                    } catch (error) {
                        console.error('Error loading student details:', error);
                    }
                }

                // Get interview questions
                let questionsHtml = '<p>No questions found</p>';
                try {
                    const questionsResponse = await fetch(`/api/interviews/${interviewId}/questions`);
                    const questionsData = await questionsResponse.json();
                    if (questionsData.success && questionsData.data.length > 0) {
                        questionsHtml = questionsData.data.map((q, index) => `
                            <div class="question-answer-item" id="question-${q.id}">
                                <div class="question-header">
                                    <p><strong>Q${index + 1}:</strong> <span class="question-text-display">${q.question_text}</span></p>
                                    <button class="icon-btn edit-btn" onclick="editQuestionText(${q.id}, '${q.question_text.replace(/'/g, "\\'").replace(/\n/g, '\\n').replace(/\r/g, '\\r')}')" title="Edit Question">✏️</button>
                                </div>
                                <div class="answer-section">
                                    <p><strong>Answer:</strong> <span class="answer-text-display">${q.student_answer || 'No answer provided'}</span></p>
                                    <button class="icon-btn edit-btn" onclick="editQuestionAnswer(${q.id}, '${(q.student_answer || '').replace(/'/g, "\\'").replace(/\n/g, '\\n').replace(/\r/g, '\\r')}')" title="Edit Answer">✏️</button>
                                </div>
                                ${q.answer_photo_url ? `
                                    <div class="photo-gallery">
                                        ${(() => {
                                            try {
                                                console.log('Raw answer_photo_url:', q.answer_photo_url);
                                                console.log('Type of answer_photo_url:', typeof q.answer_photo_url);
                                                
                                                // Handle different formats of answer_photo_url
                                                let photoUrls;
                                                
                                                if (typeof q.answer_photo_url === 'string') {
                                                    // Try to parse as JSON
                                                    try {
                                                        photoUrls = JSON.parse(q.answer_photo_url);
                                                    } catch (parseError) {
                                                        console.log('Not valid JSON, treating as single URL');
                                                        photoUrls = q.answer_photo_url;
                                                    }
                                                } else {
                                                    photoUrls = q.answer_photo_url;
                                                }
                                                
                                                console.log('Parsed photoUrls:', photoUrls);
                                                
                                                if (Array.isArray(photoUrls)) {
                                                    return photoUrls.map((url, index) => {
                                                        // Clean up URL if it has malformed characters
                                                        const cleanUrl = url.replace(/^\[|\]$/g, '').replace(/^"|"$/g, '');
                                                        console.log(`Processing URL ${index}:`, cleanUrl);
                                                        return `
                                                            <div class="photo-item">
                                                                <img src="${cleanUrl}" alt="Answer photo" class="answer-image" onclick="openImageModal('${cleanUrl}')">
                                                            </div>
                                                        `;
                                                    }).join('');
                                                } else if (typeof photoUrls === 'string' && photoUrls.trim()) {
                                                    // Handle single image (backward compatibility)
                                                    const cleanUrl = photoUrls.replace(/^\[|\]$/g, '').replace(/^"|"$/g, '');
                                                    console.log('Single URL:', cleanUrl);
                                                    return `
                                                        <div class="photo-item">
                                                            <img src="${cleanUrl}" alt="Answer photo" class="answer-image" onclick="openImageModal('${cleanUrl}')">
                                                        </div>
                                                    `;
                                                } else {
                                                    console.log('No valid photo URLs found');
                                                    return '<p>No valid images found</p>';
                                                }
                                            } catch (e) {
                                                console.error('Error processing photo URLs:', e);
                                                console.log('Raw value:', q.answer_photo_url);
                                                return '<p>Error loading images</p>';
                                            }
                                        })()}
                                    </div>
                                ` : ''}
                            </div>
                        `).join('');
                    }
                } catch (error) {
                    console.error('Error loading interview questions:', error);
                }

                const content = `
                    <div class="detail-section">
                        <h4 class="detail-section-title">Interview Information</h4>
                        <div class="detail-item">
                            <div class="detail-label">Interview ID</div>
                            <div class="detail-value">#${interview.id}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Student</div>
                            <div class="detail-value">${studentInfo}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Date</div>
                            <div class="detail-value">${formatDate(interview.interview_date)}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Status</div>
                            <div class="detail-value"><span class="status-badge status-${interview.status}">${interview.status}</span></div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Duration</div>
                            <div class="detail-value">${interview.duration_seconds ? formatDuration(interview.duration_seconds) : 'N/A'}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Verdict</div>
                            <div class="detail-value">${interview.verdict || 'No Verdict'}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Overall Notes</div>
                            <div class="detail-value">${interview.overall_notes || 'No notes available'}</div>
                        </div>
                    </div>
                    
                    <div class="detail-section">
                        <h4 class="detail-section-title">Questions & Answers</h4>
                        <div class="detail-section-content">
                            ${questionsHtml}
                        </div>
                    </div>
                `;

                openDetailPanel(`Interview #${interview.id}`, content);

            } catch (error) {
                console.error('Error loading interview details:', error);
                showError('Error loading interview details');
            }
        }

        function resumeMyInterview(interviewId) {
            try {
                const item = (interviews || []).find(i => i.id === interviewId);
                if (!item) {
                    showError('Interview not found');
                    return;
                }
                const zeta = item.zeta_id || '';
                const sessionId = item.session_id || item.session || '';
                if (!zeta || !sessionId) {
                    showError('Missing Zeta ID or Session');
                    return;
                }
                const url = `/interview-session.html?zeta_id=${encodeURIComponent(zeta)}&session_id=${encodeURIComponent(sessionId)}&resume=1`;
                window.location.href = url;
            } catch (e) {
                console.error('Error resuming interview', e);
                showError('Unable to resume interview');
            }
        }

        function showEmptyState(tableBodyId, message) {
            const tbody = document.getElementById(tableBodyId);
            tbody.innerHTML = `
                <tr>
                    <td colspan="8" class="empty-state">
                        <i>📋</i>
                        <div>${message}</div>
                    </td>
                </tr>
            `;
        }

        function formatDuration(seconds) {
            if (seconds === null || seconds === undefined) return 'N/A';
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function formatDate(dateString) {
            if (!dateString) return 'N/A';
            const date = new Date(dateString);
            return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
        }

        function showError(message) {
            alert('Error: ' + message);
        }

        function openDetailPanel(title, content) {
            // Create detail panel if it doesn't exist
            let detailPanel = document.getElementById('detail-panel');
            if (!detailPanel) {
                detailPanel = document.createElement('div');
                detailPanel.id = 'detail-panel';
                detailPanel.className = 'detail-panel';
                document.body.appendChild(detailPanel);
            }

            // Create overlay if it doesn't exist
            let overlay = document.getElementById('detail-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'detail-overlay';
                overlay.className = 'detail-overlay';
                overlay.onclick = closeDetailPanel;
                document.body.appendChild(overlay);
            }

            // Set content
            detailPanel.innerHTML = `
                <div class="detail-panel-header">
                    <h3>${title}</h3>
                    <button class="detail-panel-close" onclick="closeDetailPanel()">&times;</button>
                </div>
                <div class="detail-panel-content">
                    ${content}
                </div>
            `;

            // Show panel
            detailPanel.classList.add('active');
            overlay.classList.add('active');
        }

        function closeDetailPanel() {
            const detailPanel = document.getElementById('detail-panel');
            const overlay = document.getElementById('detail-overlay');
            
            if (detailPanel) detailPanel.classList.remove('active');
            if (overlay) overlay.classList.remove('active');
        }

        function openImageModal(imageUrl) {
            // Create image modal if it doesn't exist
            let imageModal = document.getElementById('image-modal');
            if (!imageModal) {
                imageModal = document.createElement('div');
                imageModal.id = 'image-modal';
                imageModal.className = 'image-modal';
                imageModal.innerHTML = `
                    <div class="image-modal-content">
                        <span class="image-modal-close" onclick="closeImageModal()">&times;</span>
                        <img id="modal-image" src="" alt="Full size image">
                    </div>
                `;
                imageModal.onclick = closeImageModal;
                document.body.appendChild(imageModal);
            }

            // Set image source and show modal
            document.getElementById('modal-image').src = imageUrl;
            imageModal.classList.add('active');
        }

        function closeImageModal() {
            const imageModal = document.getElementById('image-modal');
            if (imageModal) {
                imageModal.classList.remove('active');
            }
        }

        // Add Question Modal Functions
        function openAddQuestionModal() {
            console.log('openAddQuestionModal called');
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.35);display:flex;align-items:center;justify-content:center;z-index:2000;';
            modal.innerHTML = `
                <div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;min-width:500px;max-width:90%;padding:24px;box-shadow:0 10px 20px rgba(0,0,0,0.15)">
                    <div style="font-weight:600;margin-bottom:16px;color:#111827;font-size:1.2rem">Add New Question</div>
                    <div style="margin-bottom:16px">
                        <label style="display:block;margin-bottom:8px;font-weight:500;color:#374151">Question Text *</label>
                        <textarea id="new-question-text" style="width:100%;padding:12px;border:1px solid #d1d5db;border-radius:6px;font-size:14px;min-height:100px;resize:vertical" placeholder="Enter your question here..."></textarea>
                    </div>
                    <div style="margin-bottom:16px">
                        <label style="display:block;margin-bottom:8px;font-weight:500;color:#374151">Category</label>
                        <select id="new-question-category" style="width:100%;padding:12px;border:1px solid #d1d5db;border-radius:6px;font-size:14px">
                            <option value="">Select Category</option>
                            <option value="Technical">Technical</option>
                            <option value="Behavioral">Behavioral</option>
                            <option value="Problem Solving">Problem Solving</option>
                            <option value="Communication">Communication</option>
                            <option value="Leadership">Leadership</option>
                            <option value="General">General</option>
                        </select>
                    </div>
                    <div style="display:flex;gap:8px;justify-content:flex-end">
                        <button id="add-question-cancel" style="border:1px solid #e5e7eb;background:#fff;padding:8px 16px;border-radius:6px;cursor:pointer">Cancel</button>
                        <button id="add-question-save" style="background:#059669;color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer">Add Question</button>
                    </div>
                </div>`;
            document.body.appendChild(modal);
            
            modal.querySelector('#add-question-cancel').onclick = () => modal.remove();
            modal.querySelector('#add-question-save').onclick = async () => {
                const questionText = document.getElementById('new-question-text').value.trim();
                const category = document.getElementById('new-question-category').value;
                
                if (!questionText) {
                    alert('Please enter a question text');
                    return;
                }
                
                try {
                    const response = await fetch('/api/question-bank', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            question: questionText,
                            category: category || 'General'
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        modal.remove();
                        showSuccess('Question added successfully!');
                        loadQuestions(); // Refresh the question list
                    } else {
                        showError('Error adding question: ' + (result.error || 'Unknown error'));
                    }
                } catch (error) {
                    console.error('Error adding question:', error);
                    showError('Error adding question');
                }
            };
        }

        // Bulk Import Modal Functions
        function openBulkImportModal() {
            console.log('openBulkImportModal called');
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.35);display:flex;align-items:center;justify-content:center;z-index:2000;';
            modal.innerHTML = `
                <div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;min-width:600px;max-width:90%;padding:24px;box-shadow:0 10px 20px rgba(0,0,0,0.15)">
                    <div style="font-weight:600;margin-bottom:16px;color:#111827;font-size:1.2rem">Bulk Import Questions</div>
                    <div style="margin-bottom:16px;padding:12px;background:#f3f4f6;border-radius:6px;font-size:14px;color:#374151">
                        <strong>Instructions:</strong><br>
                        • Enter one question per line<br>
                        • Use format: "Question text | Category" (category is optional)<br>
                        • Example: "What is JavaScript? | Technical"<br>
                        • If no category is specified, "General" will be used
                    </div>
                    <div style="margin-bottom:16px">
                        <label style="display:block;margin-bottom:8px;font-weight:500;color:#374151">Questions *</label>
                        <textarea id="bulk-questions-text" style="width:100%;padding:12px;border:1px solid #d1d5db;border-radius:6px;font-size:14px;min-height:200px;resize:vertical;font-family:monospace" placeholder="Enter questions here, one per line..."></textarea>
                    </div>
                    <div style="display:flex;gap:8px;justify-content:flex-end">
                        <button id="bulk-import-cancel" style="border:1px solid #e5e7eb;background:#fff;padding:8px 16px;border-radius:6px;cursor:pointer">Cancel</button>
                        <button id="bulk-import-save" style="background:#3b82f6;color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer">Import Questions</button>
                    </div>
                </div>`;
            document.body.appendChild(modal);
            
            modal.querySelector('#bulk-import-cancel').onclick = () => modal.remove();
            modal.querySelector('#bulk-import-save').onclick = async () => {
                const questionsText = document.getElementById('bulk-questions-text').value.trim();
                
                if (!questionsText) {
                    alert('Please enter questions to import');
                    return;
                }
                
                // Parse questions
                const lines = questionsText.split('\n').filter(line => line.trim());
                const questions = lines.map(line => {
                    const parts = line.split('|').map(part => part.trim());
                    return {
                        question: parts[0],
                        category: parts[1] || 'General'
                    };
                });
                
                if (questions.length === 0) {
                    alert('No valid questions found');
                    return;
                }
                
                try {
                    const response = await fetch('/api/question-bank/bulk', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ questions })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        modal.remove();
                        showSuccess(`Successfully imported ${result.imported || questions.length} questions!`);
                        loadQuestions(); // Refresh the question list
                    } else {
                        showError('Error importing questions: ' + (result.error || 'Unknown error'));
                    }
                } catch (error) {
                    console.error('Error importing questions:', error);
                    showError('Error importing questions');
                }
            };
        }

        // Edit functionality
        let selectedRows = new Set();
        let currentEditRow = null;
        let currentEditData = null;

        function toggleRowSelection(rowId) {
            if (selectedRows.has(rowId)) {
                selectedRows.delete(rowId);
            } else {
                selectedRows.add(rowId);
            }
            updateBulkEditControls();
        }

        function selectAllRows() {
            const checkboxes = document.querySelectorAll('.row-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
                selectedRows.add(checkbox.dataset.rowId);
            });
            updateBulkEditControls();
        }

        function clearSelection() {
            selectedRows.clear();
            const checkboxes = document.querySelectorAll('.row-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            updateBulkEditControls();
        }

        function updateBulkEditControls() {
            const controls = document.querySelector('.bulk-edit-controls');
            const count = document.getElementById('bulk-edit-selected-count');
            
            if (selectedRows.size > 0) {
                controls.classList.add('active');
                count.textContent = `${selectedRows.size} records selected`;
            } else {
                controls.classList.remove('active');
            }
        }

        function openBulkEditModal() {
            if (selectedRows.size === 0) {
                showError('Please select records to edit');
                return;
            }
            
            const modal = document.getElementById('bulk-edit-modal');
            const fieldSelect = document.getElementById('bulk-edit-field');
            
            // Populate field options based on current tab
            fieldSelect.innerHTML = '<option value="">Select field...</option>';
            
            const currentTab = document.querySelector('.nav-link.active').textContent.trim();
            let fields = [];
            
            if (currentTab.includes('My Interviews')) {
                fields = [
                    { value: 'verdict', text: 'Verdict' },
                    { value: 'status', text: 'Status' },
                    { value: 'overall_notes', text: 'Notes' }
                ];
            } else if (currentTab.includes('Question Analysis')) {
                fields = [
                    { value: 'question', text: 'Question Text' },
                    { value: 'category', text: 'Category' }
                ];
            }
            
            fields.forEach(field => {
                const option = document.createElement('option');
                option.value = field.value;
                option.textContent = field.text;
                fieldSelect.appendChild(option);
            });
            
            modal.classList.add('active');
        }

        function closeBulkEditModal() {
            const modal = document.getElementById('bulk-edit-modal');
            if (modal) {
                modal.classList.remove('active');
            }
            const valueInput = document.getElementById('bulk-edit-value');
            if (valueInput) {
                valueInput.value = '';
            }
            const valueGroup = document.getElementById('bulk-edit-value-group');
            if (valueGroup) {
                valueGroup.style.display = 'none';
            }
        }

        function updateBulkEditFields() {
            const fieldSelect = document.getElementById('bulk-edit-field');
            const valueGroup = document.getElementById('bulk-edit-value-group');
            
            if (fieldSelect.value) {
                valueGroup.style.display = 'block';
            } else {
                valueGroup.style.display = 'none';
            }
        }

        async function applyBulkEdit() {
            const field = document.getElementById('bulk-edit-field').value;
            const value = document.getElementById('bulk-edit-value').value;
            
            if (!field || !value) {
                showError('Please select a field and enter a value');
                return;
            }
            
            try {
                // Map display field names to actual database field names
                const fieldMapping = {
                    'verdict': 'verdict',
                    'status': 'status',
                    'overall_notes': 'overall_notes',
                    'question': 'question',
                    'category': 'category'
                };
                
                const dbField = fieldMapping[field] || field;
                const updates = Array.from(selectedRows).map(rowId => ({
                    id: parseInt(rowId), // Ensure ID is an integer
                    data: { [dbField]: value }
                }));
                
                const currentTab = document.querySelector('.nav-link.active').textContent.trim();
                let endpoint = '';
                
                if (currentTab.includes('My Interviews')) {
                    endpoint = '/api/interviews/bulk';
                } else if (currentTab.includes('Question Analysis')) {
                    endpoint = '/api/question-bank/bulk';
                }
                
                console.log('Bulk edit request:', { endpoint, updates });
                
                const response = await fetch(endpoint, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ updates })
                });
                
                const result = await response.json();
                console.log('Bulk edit response:', result);
                
                if (result.success) {
                    showSuccess(`Successfully updated ${updates.length} records`);
                    closeBulkEditModal();
                    clearSelection();
                    // Refresh current tab data
                    const activeTab = document.querySelector('.nav-link.active');
                    if (activeTab) {
                        activeTab.click();
                    }
                } else {
                    showError('Error updating records: ' + result.error);
                }
            } catch (error) {
                console.error('Error applying bulk edit:', error);
                showError('Error applying bulk edit');
            }
        }

        function startEdit(rowId, data) {
            if (currentEditRow) {
                cancelEdit();
            }
            
            currentEditRow = rowId;
            currentEditData = { ...data };
            
            const row = document.querySelector(`[data-row-id="${rowId}"]`);
            row.classList.add('editing');
            
            // Replace content with edit form
            const cells = row.querySelectorAll('td:not(:last-child)');
            cells.forEach((cell, index) => {
                const field = cell.dataset.field;
                if (field && field !== 'id' && field !== 'interview_count' && field !== 'times_asked') {
                    const currentValue = cell.textContent.trim();
                    cell.innerHTML = `<input type="text" class="edit-input" value="${currentValue}" data-field="${field}">`;
                }
            });
            
            // Replace action buttons
            const actionCell = row.querySelector('td:last-child');
            actionCell.innerHTML = `
                <button class="icon-btn save-btn" onclick="saveEdit('${rowId}')" title="Save">✓</button>
                <button class="icon-btn cancel-btn" onclick="cancelEdit()" title="Cancel">✗</button>
            `;
        }

        function cancelEdit() {
            if (!currentEditRow) return;
            
            const row = document.querySelector(`[data-row-id="${currentEditRow}"]`);
            row.classList.remove('editing');
            
            // Restore original content by reloading the current tab
            const activeTab = document.querySelector('.nav-link.active');
            if (activeTab) {
                activeTab.click();
            }
            
            currentEditRow = null;
            currentEditData = null;
        }

        async function saveEdit(rowId) {
            try {
                const row = document.querySelector(`[data-row-id="${rowId}"]`);
                const inputs = row.querySelectorAll('.edit-input');
                const updateData = {};
                
                inputs.forEach(input => {
                    updateData[input.dataset.field] = input.value;
                });
                
                const currentTab = document.querySelector('.nav-link.active').textContent.trim();
                let endpoint = '';
                
                if (currentTab.includes('My Interviews')) {
                    endpoint = `/api/interviews/${rowId}`;
                } else if (currentTab.includes('Question Analysis')) {
                    endpoint = `/api/question-bank/${rowId}`;
                }
                
                const response = await fetch(endpoint, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updateData)
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showSuccess('Record updated successfully');
                    currentEditRow = null;
                    currentEditData = null;
                    // Refresh current tab data
                    const activeTab = document.querySelector('.nav-link.active');
                    if (activeTab) {
                        activeTab.click();
                    }
                } else {
                    showError('Error updating record: ' + result.error);
                }
            } catch (error) {
                console.error('Error saving edit:', error);
                showError('Error saving edit');
            }
        }

        function deleteRecord(rowId, type) {
            if (!confirm(`Are you sure you want to delete this ${type}?`)) {
                return;
            }
            
            // Implementation depends on the specific delete functionality
            // This would call the appropriate delete API endpoint
            console.log(`Delete ${type} with ID: ${rowId}`);
        }

        // Edit question text in interview details
        async function editQuestionText(questionId, currentText) {
            const questionElement = document.getElementById(`question-${questionId}`);
            const questionDisplay = questionElement.querySelector('.question-text-display');
            const editButton = questionElement.querySelector('.question-header .edit-btn');
            
            // Create input field
            const input = document.createElement('textarea');
            input.className = 'question-edit-input';
            input.value = currentText;
            input.rows = 3;
            
            // Create action buttons
            const actions = document.createElement('div');
            actions.className = 'edit-actions';
            actions.innerHTML = `
                <button class="btn btn-success" onclick="saveQuestionText(${questionId})">Save</button>
                <button class="btn btn-secondary" onclick="cancelQuestionTextEdit(${questionId}, '${currentText.replace(/'/g, "\\'").replace(/\n/g, '\\n').replace(/\r/g, '\\r')}')">Cancel</button>
            `;
            
            // Replace display with input
            questionDisplay.style.display = 'none';
            editButton.style.display = 'none';
            questionDisplay.parentNode.insertBefore(input, questionDisplay);
            questionDisplay.parentNode.insertBefore(actions, questionDisplay);
            
            // Focus and select text
            input.focus();
            input.select();
        }
        
        // Save question text
        async function saveQuestionText(questionId) {
            const questionElement = document.getElementById(`question-${questionId}`);
            const input = questionElement.querySelector('.question-edit-input');
            const newText = input.value.trim();
            
            if (!newText) {
                showError('Question text cannot be empty');
                return;
            }
            
            try {
                const response = await fetch(`/api/interview-questions/${questionId}/text`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        question_text: newText
                    })
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    // Update display
                    const questionDisplay = questionElement.querySelector('.question-text-display');
                    questionDisplay.textContent = newText;
                    questionDisplay.style.display = 'inline';
                    
                    // Show edit button
                    const editButton = questionElement.querySelector('.question-header .edit-btn');
                    editButton.style.display = 'inline-block';
                    
                    // Remove input and actions
                    input.remove();
                    questionElement.querySelector('.edit-actions').remove();
                    
                    showSuccess('Question updated successfully');
                } else {
                    showError(result.error || 'Error updating question');
                }
            } catch (error) {
                console.error('Error updating question:', error);
                showError('Error updating question');
            }
        }
        
        // Cancel question text edit
        function cancelQuestionTextEdit(questionId, originalText) {
            const questionElement = document.getElementById(`question-${questionId}`);
            const questionDisplay = questionElement.querySelector('.question-text-display');
            const editButton = questionElement.querySelector('.question-header .edit-btn');
            
            // Restore display
            questionDisplay.style.display = 'inline';
            editButton.style.display = 'inline-block';
            
            // Remove input and actions
            questionElement.querySelector('.question-edit-input').remove();
            questionElement.querySelector('.edit-actions').remove();
        }
        
        // Edit question answer in interview details
        async function editQuestionAnswer(questionId, currentAnswer) {
            const questionElement = document.getElementById(`question-${questionId}`);
            const answerDisplay = questionElement.querySelector('.answer-text-display');
            const editButton = questionElement.querySelector('.answer-section .edit-btn');
            
            // Create input field
            const input = document.createElement('textarea');
            input.className = 'answer-edit-input';
            input.value = currentAnswer;
            input.rows = 3;
            
            // Create action buttons
            const actions = document.createElement('div');
            actions.className = 'edit-actions';
            actions.innerHTML = `
                <button class="btn btn-success" onclick="saveQuestionAnswer(${questionId})">Save</button>
                <button class="btn btn-secondary" onclick="cancelQuestionAnswerEdit(${questionId}, '${currentAnswer.replace(/'/g, "\\'").replace(/\n/g, '\\n').replace(/\r/g, '\\r')}')">Cancel</button>
            `;
            
            // Replace display with input
            answerDisplay.style.display = 'none';
            editButton.style.display = 'none';
            answerDisplay.parentNode.insertBefore(input, answerDisplay);
            answerDisplay.parentNode.insertBefore(actions, answerDisplay);
            
            // Focus and select text
            input.focus();
            input.select();
        }
        
        // Save question answer
        async function saveQuestionAnswer(questionId) {
            const questionElement = document.getElementById(`question-${questionId}`);
            const input = questionElement.querySelector('.answer-edit-input');
            const newAnswer = input.value.trim();
            
            try {
                const response = await fetch(`/api/interview-questions/${questionId}/answer`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        student_answer: newAnswer
                    })
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    // Update display
                    const answerDisplay = questionElement.querySelector('.answer-text-display');
                    answerDisplay.textContent = newAnswer || 'No answer provided';
                    answerDisplay.style.display = 'inline';
                    
                    // Show edit button
                    const editButton = questionElement.querySelector('.answer-section .edit-btn');
                    editButton.style.display = 'inline-block';
                    
                    // Remove input and actions
                    input.remove();
                    questionElement.querySelector('.edit-actions').remove();
                    
                    showSuccess('Answer updated successfully');
                } else {
                    showError(result.error || 'Error updating answer');
                }
            } catch (error) {
                console.error('Error updating answer:', error);
                showError('Error updating answer');
            }
        }
        
        // Cancel question answer edit
        function cancelQuestionAnswerEdit(questionId, originalAnswer) {
            const questionElement = document.getElementById(`question-${questionId}`);
            const answerDisplay = questionElement.querySelector('.answer-text-display');
            const editButton = questionElement.querySelector('.answer-section .edit-btn');
            
            // Restore display
            answerDisplay.style.display = 'inline';
            editButton.style.display = 'inline-block';
            
            // Remove input and actions
            questionElement.querySelector('.answer-edit-input').remove();
            questionElement.querySelector('.edit-actions').remove();
        }
        
        // Show success message (replace alert with modal)
        function showSuccess(message) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.35);display:flex;align-items:center;justify-content:center;z-index:2000;';
            modal.innerHTML = `
                <div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;min-width:280px;max-width:90%;padding:16px;box-shadow:0 10px 20px rgba(0,0,0,0.15)">
                    <div style="font-weight:600;margin-bottom:8px;color:#059669">Success</div>
                    <div style="font-size:14px;color:#374151;margin-bottom:12px">${message}</div>
                    <div style="display:flex;gap:8px;justify-content:flex-end">
                        <button onclick="this.closest('div[style*=\"position:fixed\"]').remove()" style="background:#059669;color:#fff;border:none;padding:6px 10px;border-radius:6px;cursor:pointer">OK</button>
                    </div>
                </div>`;
            document.body.appendChild(modal);
        }
    </script>

    <!-- Bulk Edit Modal -->
    <div id="bulk-edit-modal" class="bulk-edit-modal" onclick="closeBulkEditModal()">
        <div class="bulk-edit-content" onclick="event.stopPropagation()">
            <div class="bulk-edit-header">
                <h3 class="bulk-edit-title">Bulk Edit Records</h3>
                <button class="close-modal" onclick="closeBulkEditModal()">&times;</button>
            </div>
            <form id="bulk-edit-form" class="bulk-edit-form">
                <div class="form-group">
                    <label class="form-label">Field to Update:</label>
                    <select id="bulk-edit-field" class="form-select" onchange="updateBulkEditFields()">
                        <option value="">Select field...</option>
                    </select>
                </div>
                <div id="bulk-edit-value-group" class="form-group" style="display: none;">
                    <label class="form-label">New Value:</label>
                    <input type="text" id="bulk-edit-value" class="form-input" placeholder="Enter new value...">
                </div>
                <div class="form-group">
                    <label class="form-label">Selected Records:</label>
                    <div id="bulk-edit-selected-count" class="bulk-edit-info">0 records selected</div>
                </div>
            </form>
            <div class="bulk-edit-footer">
                <button class="btn btn-secondary" onclick="closeBulkEditModal()">Cancel</button>
                <button class="btn btn-primary" onclick="applyBulkEdit()">Apply Changes</button>
            </div>
        </div>
    </div>
</body>
</html>