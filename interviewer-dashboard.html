<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interviewer Dashboard - Bees Interview Platform</title>
    <link rel="icon" type="image/png" href="/logo2.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #ffffff;
            color: #000000;
            line-height: 1.6;
        }

        .dashboard-container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* Unified Header with Navigation */
        .sidebar {
            width: 100%;
            background: #000000;
            color: white;
            padding: 0.75rem 2rem;
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            gap: 2rem;
        }

        .sidebar-header {
            display: flex;
            align-items: center;
        }

        .sidebar-header .logo {
            display: flex;
            align-items: center;
        }
        
        .logo-container {
            display: flex;
            align-items: center;
            color: #ffffff;
        }
        
        /* Logo styling - showing original colors */

        .sidebar-nav {
            list-style: none;
            display: flex;
            align-items: center;
            margin: 0;
            padding: 0;
            gap: 0.25rem;
            flex: 1;
            justify-content: flex-end;
        }

        .nav-item {
            margin: 0;
        }

        .nav-link {
            display: block;
            padding: 0.75rem 1.25rem;
            color: #cccccc;
            text-decoration: none;
            transition: all 0.2s ease;
            border-radius: 6px;
            white-space: nowrap;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .nav-link:hover,
        .nav-link.active {
            background: #333333;
            color: white;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .header-actions .btn-primary {
            background: #dc3545;
            color: white;
            padding: 0.6rem 1.2rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            white-space: nowrap;
        }

        .header-actions .btn-primary:hover {
            background: #c82333;
        }

        /* Main Content */
        .main-content {
            margin-left: 0;
            flex: 1;
            padding: 2rem;
            max-width: 100%;
        }

        .header {
            display: none;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .home-link {
            color: #000;
            text-decoration: none;
            margin-right: 1rem;
            font-weight: 600;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            transition: background-color 0.2s ease;
        }

        .home-link:hover {
            background-color: #f0f0f0;
            text-decoration: none;
        }

        .header h1 {
            color: #000;
            font-size: 1.5rem;
            font-weight: 600;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            padding-bottom: 0.25rem;
            border-bottom: 1px solid #cccccc;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            background: #000;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .btn {
            background: #1E4ED8;
            color: white;
            padding: 0.9rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
            border: none;
            text-decoration: none;
            display: inline-block;
        }

        .btn-primary {
            background: #2563eb;
            color: white;
        }

        .btn-primary:hover {
            background: #1d4ed8;
        }

        .btn-sm {
            padding: 0.3rem 0.6rem;
            font-size: 0.8rem;
        }

        /* Content Tabs */
        .content-section {
            display: none;
        }

        .content-section.active {
            display: block;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            border-left: 4px solid #000;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: #000;
            margin-bottom: 0.5rem;
        }

        .stat-label {
            color: #666;
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .section-card {
        }

        .section-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #000;
            margin-bottom: 1rem;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.5rem;
        }

        .table-container {
            overflow-x: auto;
        }

        .table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        .table th, .table td {
            padding: 0.4rem 0.6rem;
            text-align: left;
            border-bottom: 1px solid #eee;
            font-size: 0.8rem;
        }

        .table th {
            background: #f8f8f8;
            font-weight: 600;
            color: #000;
            font-size: 0.75rem;
        }

        /* Compact table styling for edit functionality */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }

        .data-table th,
        .data-table td {
            padding: 0.5rem 0.75rem;
            text-align: left;
            border-bottom: 1px solid #e5e7eb;
            vertical-align: middle;
        }

        .data-table th {
            background: #f8fafc;
            font-weight: 600;
            color: #374151;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .data-table tr:hover {
            background: #f9fafb;
        }

        .data-table tr.editing {
            background: #fef3c7;
        }

        /* Icon buttons */
        .icon-btn {
            background: none;
            border: none;
            padding: 0.25rem;
            margin: 0 0.125rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
        }

        .icon-btn:hover {
            background: #f3f4f6;
            transform: scale(1.1);
        }

        .edit-btn {
            color: #2563eb;
        }

        .edit-btn:hover {
            background: #dbeafe;
            color: #1d4ed8;
        }

        .delete-btn {
            color: #dc2626;
        }

        .delete-btn:hover {
            background: #fef2f2;
            color: #b91c1c;
        }

        .save-btn {
            color: #059669;
        }

        .save-btn:hover {
            background: #d1fae5;
            color: #047857;
        }

        .cancel-btn {
            color: #6b7280;
        }

        .cancel-btn:hover {
            background: #f3f4f6;
            color: #374151;
        }

        /* Ensure edit icons in question/answer sections are exactly 16x16 */
        .edit-question-btn img,
        .edit-answer-btn img {
            width: 16px !important;
            height: 16px !important;
            max-width: 16px !important;
            max-height: 16px !important;
        }

        /* Edit form styling */
        .edit-form {
            display: none;
        }

        .edit-form.active {
            display: block;
        }

        .edit-input {
            width: 100%;
            padding: 0.25rem 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.85rem;
            background: white;
        }

        .edit-input:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
        }

        .edit-select {
            width: 100%;
            padding: 0.25rem 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.85rem;
            background: white;
        }

        /* Bulk edit controls */
        .bulk-edit-controls {
            display: none;
            padding: 1rem;
            background: #f8fafc;
            border-bottom: 1px solid #e5e7eb;
            align-items: center;
            gap: 1rem;
        }

        .bulk-edit-controls.active {
            display: flex;
        }

        .bulk-edit-info {
            color: #6b7280;
            font-size: 0.875rem;
        }

        .bulk-edit-actions {
            display: flex;
            gap: 0.5rem;
        }

        /* Checkbox styling */
        .row-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        /* Modal styling for bulk edit */
        .bulk-edit-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .bulk-edit-modal.active {
            display: flex;
        }

        .bulk-edit-content {
            background: white;
            border-radius: 8px;
            padding: 2rem;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .bulk-edit-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .bulk-edit-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #111827;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6b7280;
        }

        .bulk-edit-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .form-label {
            font-weight: 500;
            color: #374151;
            font-size: 0.875rem;
        }

        .form-input,
        .form-select,
        .form-textarea {
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.875rem;
        }

        .form-input:focus,
        .form-select:focus,
        .form-textarea:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
        }

        .bulk-edit-footer {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid #e5e7eb;
        }

        .btn {
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: #2563eb;
            color: white;
            border: none;
        }

        .btn-primary:hover {
            background: #1d4ed8;
        }

        .btn-secondary {
            background: #6b7280;
            color: white;
            border: none;
        }

        .btn-secondary:hover {
            background: #4b5563;
        }

        .table tbody tr:hover {
            background: #f5f5f5;
        }

        .question-bank-filters {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }


        .question-item {
            padding: 0.75rem 0;
            border-bottom: 1px dashed #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .question-item:last-child {
            border-bottom: none;
        }

        .question-text {
            flex-grow: 1;
            margin-right: 1rem;
            color: #000;
        }

        .favorite-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.2rem;
            color: #ccc;
            transition: color 0.2s ease;
        }

        .favorite-btn.favorited {
            color: gold;
        }

        .favorite-btn:hover {
            color: orange;
        }

               .loading, .empty-state {
                   text-align: center;
                   padding: 2rem;
                   color: #666;
               }

               /* Detail Panel Styles - Larger width up to half page */
               .detail-panel {
                   position: fixed;
                   top: 0;
                   right: -50%;
                   width: 50%;
                   min-width: 600px;
                   max-width: 800px;
                   height: 100vh;
                   background: white;
                   box-shadow: -5px 0 15px rgba(0,0,0,0.3);
                   z-index: 1001;
                   transition: right 0.3s ease;
                   overflow-y: auto;
               }

               .detail-panel.active {
                   right: 0;
               }

               .detail-overlay {
                   position: fixed;
                   top: 0;
                   left: 0;
                   width: 100%;
                   height: 100%;
                   background: rgba(0,0,0,0.5);
                   z-index: 1000;
                   opacity: 0;
                   visibility: hidden;
                   transition: all 0.3s ease;
               }

               .detail-overlay.active {
                   opacity: 1;
                   visibility: visible;
               }

               .detail-panel-header {
                   background: #000000;
                   color: white;
                   padding: 1rem;
                   display: flex;
                   justify-content: space-between;
                   align-items: center;
                   border-bottom: 1px solid #333;
               }

               .detail-panel-header h3 {
                   margin: 0;
                   font-size: 1.2rem;
               }

               .detail-panel-close {
                   background: none;
                   border: none;
                   color: white;
                   font-size: 1.5rem;
                   cursor: pointer;
                   padding: 0;
                   width: 30px;
                   height: 30px;
                   display: flex;
                   align-items: center;
                   justify-content: center;
               }

               .detail-panel-content {
                   padding: 1.5rem;
               }

               .detail-section {
                   margin-bottom: 2rem;
               }

               .detail-section-title {
                   font-size: 1.1rem;
                   font-weight: 600;
                   color: #000000;
                   margin-bottom: 1rem;
                   padding-bottom: 0.5rem;
                   border-bottom: 2px solid #000000;
               }

               .detail-item {
                   display: flex;
                   justify-content: space-between;
                   align-items: flex-start;
                   padding: 0.75rem 0;
                   border-bottom: 1px solid #eee;
               }

               .detail-label {
                   font-weight: 600;
                   color: #666;
                   min-width: 120px;
               }

               .detail-value {
                   color: #000000;
                   text-align: right;
                   flex: 1;
               }

               .question-answer-item {
                   background: #f8f9fa;
                   padding: 1rem;
                   margin-bottom: 1rem;
                   border-radius: 5px;
                   border-left: 4px solid #000000;
               }

               .question-answer-item p {
                   margin: 0.5rem 0;
                   color: #000000;
               }
               
               .question-header, .answer-section {
                   display: flex;
                   justify-content: space-between;
                   align-items: flex-start;
                   margin-bottom: 0.5rem;
               }
               
               /* Images specifically in question headers */
               .question-header img {
                   width: 200px !important;
                   height: 200px !important;
                   object-fit: contain !important;
                   object-position: center !important;
                   background-color: #f8f9fa !important;
                   border: 1px solid #ddd !important;
                   border-radius: 4px !important;
                   display: block !important;
                   margin: 10px 0 !important;
               }
               
               .question-header p, .answer-section p {
                   flex: 1;
                   margin: 0;
                   margin-right: 0.5rem;
               }
               
               .question-text-display, .answer-text-display {
                   word-wrap: break-word;
               }
               
               /* Rich content wrapper for AI-generated questions with multiple elements */
               .rich-content-wrapper {
                   display: block;
                   margin-top: 0.5rem;
               }
               
               .rich-content-wrapper p {
                   margin: 0.25rem 0;
               }
               
               .rich-content-wrapper p:first-child {
                   margin-top: 0;
               }
               
               .rich-content-wrapper p:last-child {
                   margin-bottom: 0;
               }
               
               /* Fixed images in detail panel - 200x200 with aspect ratio preserved */
               .question-text-display img, .answer-text-display img {
                   width: 200px !important;
                   height: 200px !important;
                   display: block;
                   margin: 10px 0;
                   object-fit: contain;
                   object-position: center;
                   background-color: #f8f9fa;
                   border: 1px solid #ddd;
                   border-radius: 4px;
               }

               /* Ensure rich content images are also properly sized */
               .question-text-display p img, .answer-text-display p img,
               .question-text-display div img, .answer-text-display div img {
                   width: 200px !important;
                   height: 200px !important;
                   max-width: 200px !important;
                   max-height: 200px !important;
                   object-fit: contain !important;
                   object-position: center !important;
                   background-color: #f8f9fa !important;
                   border: 1px solid #ddd !important;
                   border-radius: 4px !important;
                   display: block !important;
                   margin: 10px 0 !important;
               }
               
               .question-edit-input, .answer-edit-input {
                   width: 100%;
                   padding: 0.5rem;
                   border: 1px solid #d1d5db;
                   border-radius: 4px;
                   font-size: 0.9rem;
                   margin-bottom: 0.5rem;
               }
               
               /* Rich text editor styles for edit mode */
               .rich-text-editor-container {
                   width: 100%;
                   margin: 0.5rem 0;
               }
               
               .rich-text-editor-container .ql-editor {
                   min-height: 120px;
                   max-height: 300px;
                   overflow-y: auto;
               }
               
               .rich-text-editor-container .ql-editor img {
                   width: 200px;
                   height: 200px;
                   object-fit: contain;
                   object-position: center;
                   background-color: #f8f9fa;
                   border: 1px solid #ddd;
                   border-radius: 4px;
                   display: block;
                   margin: 10px 0;
               }
               
               .edit-actions {
                   display: flex;
                   gap: 0.5rem;
                   margin-top: 0.5rem;
               }
               
               .photo-gallery {
                   display: flex;
                   flex-wrap: wrap;
                   gap: 0.5rem;
                   margin-top: 0.5rem;
               }
               
               .photo-item {
                   position: relative;
                   display: inline-block;
               }
               
               .photo-item img {
                   width: 80px;
                   height: 80px;
                   object-fit: cover;
                   border-radius: 4px;
                   border: 1px solid #d1d5db;
                   cursor: pointer;
               }

               .answer-image {
                   width: 200px;
                   height: 200px;
                   object-fit: contain;
                   object-position: center;
                   background-color: #f8f9fa;
                   border: 1px solid #cccccc;
                   border-radius: 5px;
                   cursor: pointer;
                   margin-top: 0.5rem;
               }

               /* Image Modal Styles */
               .image-modal {
                   position: fixed;
                   top: 0;
                   left: 0;
                   width: 100%;
                   height: 100%;
                   background: rgba(0,0,0,0.9);
                   z-index: 2000;
                   display: flex;
                   align-items: center;
                   justify-content: center;
                   opacity: 0;
                   visibility: hidden;
                   transition: all 0.3s ease;
               }

               .image-modal.active {
                   opacity: 1;
                   visibility: visible;
               }

               .image-modal-content {
                   position: relative;
                   max-width: 90%;
                   max-height: 90%;
               }

               .image-modal-content img {
                   max-width: 100%;
                   max-height: 100%;
                   border-radius: 5px;
               }

               .image-modal-close {
                   position: absolute;
                   top: -40px;
                   right: 0;
                   color: white;
                   font-size: 2rem;
                   cursor: pointer;
                   background: rgba(0,0,0,0.5);
                   width: 40px;
                   height: 40px;
                   display: flex;
                   align-items: center;
                   justify-content: center;
                   border-radius: 50%;
               }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #000;
        }

        .form-select, .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #000;
            border-radius: 5px;
            font-size: 1rem;
        }

        .hidden {
            display: none !important;
        }

        /* Compact Filter Toggle Button */
        .btn-filter-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: #000000;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.3s ease;
        }

        .btn-filter-toggle:hover {
            background: #333333;
            transform: translateY(-1px);
        }

        .filter-icon {
            font-size: 1rem;
        }

        .filter-text {
            font-weight: 500;
        }

        /* Filter Panel */
        .filter-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: white;
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
            z-index: 9999;
            transition: right 0.3s ease;
            overflow-y: auto;
        }

        .filter-panel.active {
            right: 0;
        }

        .filter-panel-header {
            background: #000000;
            color: white;
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333333;
        }

        .filter-panel-header h3 {
            margin: 0;
            font-size: 1.2rem;
            flex: 1;
        }

        .filter-panel-content {
            padding: 1.5rem;
        }

        /* Filter Panel Overlay - separate from detail panel overlay */
        .filter-panel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 400px; /* Don't cover the filter panel */
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9998;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease;
        }

        .filter-panel-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        /* Filter Panel Sections */
        .filter-panel .filter-section,
        .filter-panel .sort-section,
        .filter-panel .group-by-section {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 1rem;
        }

        .filter-panel .filter-section-title {
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #333333;
            font-size: 0.9rem;
        }

        .filter-panel .filter-row {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .filter-panel .filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .filter-panel .filter-group label {
            font-size: 0.8rem;
            font-weight: 500;
            color: #555555;
        }

        .filter-panel .form-input,
        .filter-panel .form-select {
            padding: 0.5rem;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 0.8rem;
            width: 100%;
        }

        .filter-panel .sort-options,
        .filter-panel .group-by-options {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .filter-panel .sort-option {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .filter-panel .group-by-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .filter-panel .group-by-option label {
            font-size: 0.8rem;
            cursor: pointer;
            margin: 0;
        }

        .filter-panel .filter-actions {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #dee2e6;
        }

        .filter-panel .btn-filter,
        .filter-panel .btn-clear,
        .filter-panel .btn-export,
        .filter-panel .btn {
            width: 100%;
            padding: 0.75rem;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-size: 0.875rem;
            transition: background 0.2s;
        }

        /* Enhanced Filter Styles */
        .controls-panel {
            background: #f8f9fa;
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
            border: 1px solid #dee2e6;
        }

        .filter-section {
            margin-bottom: 1.5rem;
        }

        .filter-section-title {
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #495057;
            font-size: 1rem;
            border-bottom: 2px solid #007bff;
            padding-bottom: 0.25rem;
        }

        .filter-row {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            align-items: end;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            min-width: 150px;
        }

        .filter-group label {
            font-weight: 600;
            margin-bottom: 0.25rem;
            color: #495057;
            font-size: 0.875rem;
        }

        .filter-group select,
        .filter-group input {
            padding: 0.5rem;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 0.875rem;
            background: white;
        }

        .filter-group input[type="text"] {
            min-width: 200px;
        }

        .filter-group input[type="number"] {
            min-width: 100px;
        }

        /* Sort Section */
        .sort-section {
            background: #fff3cd;
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 1rem;
        }

        .sort-options {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .sort-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .sort-option select {
            padding: 0.25rem 0.5rem;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 0.875rem;
            min-width: 150px;
        }

        /* Group By Section */
        .group-by-section {
            background: #e9ecef;
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 1rem;
        }

        .group-by-options {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .group-by-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .group-by-option input[type="radio"] {
            margin: 0;
        }

        .group-by-option label {
            margin: 0;
            font-size: 0.875rem;
            cursor: pointer;
        }

        /* Action Buttons */
        .filter-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn-filter {
            background: #007bff;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: background 0.2s;
        }

        .btn-filter:hover {
            background: #0056b3;
        }

        .btn-clear {
            background: #6c757d;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: background 0.2s;
        }

        .btn-clear:hover {
            background: #545b62;
        }

        .btn-export {
            background: #28a745;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: background 0.2s;
        }

        .btn-export:hover {
            background: #1e7e34;
        }

        /* Results Summary */
        .results-summary {
            background: #d1ecf1;
            padding: 0.75rem 1rem;
            border-radius: 4px;
            margin-top: 1rem;
            font-size: 0.875rem;
            color: #0c5460;
        }

        .results-summary strong {
            color: #000000;
        }
        
        /* Pagination Styles */
        .pagination-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            margin: 20px 0;
            padding: 16px;
        }
        
        .pagination-btn {
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            background: #ffffff;
            color: #374151;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }
        
        .pagination-btn:hover {
            background: #f3f4f6;
            border-color: #9ca3af;
        }
        
        .pagination-btn.active {
            background: #3b82f6;
            color: #ffffff;
            border-color: #3b82f6;
        }
        
        .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .pagination-ellipsis {
            padding: 8px 4px;
            color: #6b7280;
            font-size: 14px;
        }
        
        .pagination-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 16px 0;
            padding: 12px 16px;
            background: #f9fafb;
            border-radius: 8px;
            font-size: 14px;
            color: #374151;
        }
    </style>
    
    <!-- Quill.js for rich text editing -->
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>
</head>
<body>
    <div class="dashboard-container">
        <!-- Unified Header with Navigation -->
        <nav class="sidebar">
            <div class="sidebar-header">
                <a href="/" class="logo">
                    <img src="/logo3.png" alt="BEES Logo" style="height: 40px; width: auto;">
                </a>
            </div>
            <ul class="sidebar-nav">
                <li class="nav-item">
                    <a href="#" class="nav-link active" onclick="showSection('interviews')">
                        My Interviews
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" onclick="showSection('questions')">
                        Question Analysis
                    </a>
                </li>
            </ul>
            <div class="header-actions">
                <button id="start-interview-btn" class="btn-primary" onclick="window.location.href='/interview'">Start Interview</button>
                <div class="user-info" style="position:relative">
                    <div class="user-avatar" id="user-avatar" style="cursor:pointer;background:#fff;color:#000">I</div>
                    <div id="avatar-menu" style="position:absolute;right:0;top:56px;background:#fff;border:1px solid #e5e7eb;border-radius:8px;box-shadow:0 10px 20px rgba(0,0,0,0.1);display:none;min-width:140px;z-index:10">
                        <button id="logout-btn" style="width:100%;background:#fff;border:none;text-align:left;padding:10px 12px;cursor:pointer">Logout</button>
                    </div>
                </div>
            </div>
        </nav>

        <!-- Main Content -->
        <main class="main-content">

            <!-- My Interviews Section -->
            <section id="interviews-section" class="content-section active">
                <!-- Stats Grid -->
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="total-interviews">0</div>
                        <div class="stat-label">Total Interviews</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="completed-interviews">0</div>
                        <div class="stat-label">Completed Interviews</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="in-progress-interviews">0</div>
                        <div class="stat-label">Interviews In Progress</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="favorite-questions">0</div>
                        <div class="stat-label">Favorite Questions</div>
                    </div>
                </div>


                <!-- Interviews Table -->
                <div class="section-card">
                    <div class="section-header">
                        <h2 class="section-title">My Interviews</h2>
                        <div class="header-actions">
                            <input type="text" id="interviewer-inline-search" class="form-input" placeholder="Search..." oninput="displayInterviews()" style="max-width:220px">
                        </div>
                    </div>
                    
                    <!-- Advanced Filters for Interviews -->
                    <div id="advanced-filters-interviews" class="adv-filters" style="margin:1rem 0;padding:1rem;background:#f9fafb;border-radius:6px">
                        <div id="filters-container-interviews" class="filters-container"></div>
                        <div class="filters-actions" style="margin-top:8px;display:flex;gap:8px">
                            <button class="btn btn-secondary" style="padding:0.5rem 1rem;font-size:0.875rem" onclick="addInterviewsFilterRow()">+ Add filter</button>
                            <button class="link-btn" style="background:none;border:none;color:#6b7280;cursor:pointer;text-decoration:underline" onclick="clearAdvancedFiltersInterviews()">Clear filters</button>
                        </div>
                    </div>
                    
                    <!-- Results Summary -->
                    <div id="results-summary" class="results-summary" style="display: none;">
                        <strong>0</strong> interviews found
                    </div>
                    
                    <div class="table-container">
                        <table class="table">
                            <thead>
                                <tr>
                                    <th data-field="created_at" onclick="sortByInterviewer('created_at')">Date <span class="sort-indicator"><span class="asc">‚ñ≤</span><span class="desc">‚ñº</span></span></th>
                                    <th data-field="student_name" onclick="sortByInterviewer('student_name')">Student Name <span class="sort-indicator"><span class="asc">‚ñ≤</span><span class="desc">‚ñº</span></span></th>
                                    <th data-field="zeta_id" onclick="sortByInterviewer('zeta_id')">Zeta ID <span class="sort-indicator"><span class="asc">‚ñ≤</span><span class="desc">‚ñº</span></span></th>
                                    <th data-field="session_name" onclick="sortByInterviewer('session_name')">Session <span class="sort-indicator"><span class="asc">‚ñ≤</span><span class="desc">‚ñº</span></span></th>
                                    <th data-field="status" onclick="sortByInterviewer('status')">Status <span class="sort-indicator"><span class="asc">‚ñ≤</span><span class="desc">‚ñº</span></span></th>
                                    <th data-field="verdict" onclick="sortByInterviewer('verdict')">Verdict <span class="sort-indicator"><span class="asc">‚ñ≤</span><span class="desc">‚ñº</span></span></th>
                                    <th data-field="duration_seconds" onclick="sortByInterviewer('duration_seconds')">Duration <span class="sort-indicator"><span class="asc">‚ñ≤</span><span class="desc">‚ñº</span></span></th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="interviews-table-body">
                                <tr><td colspan="8" class="loading">Loading interviews...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </section>

            <!-- Question Analysis Section -->
            <section id="questions-section" class="content-section">
                <div class="section-card">
                    <div class="section-header">
                        <h2 class="section-title">Question Analysis</h2>
                        <div class="header-actions">
                            <button class="btn btn-success" onclick="openAddQuestionModal()">Add Question</button>
                            <button class="btn btn-info" onclick="openBulkImportModal()">Bulk Import</button>
                            <input type="text" id="interviewer-questions-inline-search" class="form-input" placeholder="Search questions..." oninput="displayQuestionAnalytics()" style="max-width:260px">
                        </div>
                    </div>
                    
                    <!-- Advanced Filters for Questions -->
                    <div id="advanced-filters-questions-interviewer" class="adv-filters" style="margin:1rem 0;padding:1rem;background:#f9fafb;border-radius:6px">
                        <div id="filters-container-questions-interviewer" class="filters-container"></div>
                        <div class="filters-actions" style="margin-top:8px;display:flex;gap:8px">
                            <button class="btn btn-secondary" style="padding:0.5rem 1rem;font-size:0.875rem" onclick="addQuestionsFilterRowInterviewer()">+ Add filter</button>
                            <button class="link-btn" style="background:none;border:none;color:#6b7280;cursor:pointer;text-decoration:underline" onclick="clearAdvancedFiltersQuestionsInterviewer()">Clear filters</button>
                        </div>
                    </div>
                    
                    <!-- Results Summary -->
                    <div id="question-results-summary" class="results-summary" style="display: none;">
                        <strong>0</strong> questions found
                    </div>
                    <div class="table-container">
                        <table class="data-table">
                            <thead>
                                <tr>
                                    <th data-field="question" onclick="sortByQuestion('question')">Question <span class="sort-indicator"><span class="asc">‚ñ≤</span><span class="desc">‚ñº</span></span></th>
                                    <th>Tags</th>
                                    <th data-field="times_asked" onclick="sortByQuestion('times_asked')">Times Asked <span class="sort-indicator"><span class="asc">‚ñ≤</span><span class="desc">‚ñº</span></span></th>
                                    <th data-field="average_score" onclick="sortByQuestion('average_score')">Avg Score <span class="sort-indicator"><span class="asc">‚ñ≤</span><span class="desc">‚ñº</span></span></th>
                                    <th data-field="success_rate" onclick="sortByQuestion('success_rate')">Success Rate <span class="sort-indicator"><span class="asc">‚ñ≤</span><span class="desc">‚ñº</span></span></th>
                                    <th>Favorite</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="question-bank-list">
                                <tr><td colspan="8" class="loading">Loading questions...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <!-- Filter Panel Overlay -->
    <div id="filter-panel-overlay" class="filter-panel-overlay" onclick="closeFilterPanel()"></div>

    <!-- Interview Filter Panel -->
    <div id="filter-panel" class="filter-panel">
        <div class="filter-panel-header">
            <h3>Filter & Sort Options</h3>
            <button class="close-btn" onclick="closeFilterPanel()">‚úï</button>
        </div>
        <div class="filter-panel-content">
            <!-- Search Section -->
            <div class="filter-section">
                <div class="filter-section-title">üîç Search & Filter</div>
                <div class="filter-row">
                    <div class="filter-group">
                        <label>Search:</label>
                        <input type="text" id="search-interviews" class="form-input" placeholder="Search by student name, Zeta ID, or session..." onkeyup="applyFilters('interviews')">
                    </div>
                    <div class="filter-group">
                        <label>Status:</label>
                        <select id="status-filter" class="form-select" onchange="applyFilters('interviews')">
                            <option value="">All Statuses</option>
                            <option value="completed">Completed</option>
                            <option value="in_progress">In Progress</option>
                            <option value="cancelled">Cancelled</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>Verdict:</label>
                        <select id="verdict-filter" class="form-select" onchange="applyFilters('interviews')">
                            <option value="">All Verdicts</option>
                            <option value="Tiger">Tiger</option>
                            <option value="Cow">Cow</option>
                            <option value="Sheep">Sheep</option>
                        </select>
                    </div>
                </div>
                <div class="filter-row">
                    <div class="filter-group">
                        <label>Date From:</label>
                        <input type="date" id="date-from" class="form-input" onchange="applyFilters('interviews')">
                    </div>
                    <div class="filter-group">
                        <label>Date To:</label>
                        <input type="date" id="date-to" class="form-input" onchange="applyFilters('interviews')">
                    </div>
                    <div class="filter-group">
                        <label>Duration (min):</label>
                        <input type="number" id="duration-min" class="form-input" placeholder="Minutes" min="0" onchange="applyFilters('interviews')">
                    </div>
                </div>
            </div>

            <!-- Sort Section -->
            <div class="sort-section">
                <div class="filter-section-title">üìä Sort Options</div>
                <div class="sort-options">
                    <div class="sort-option">
                        <label>Primary Sort:</label>
                        <select id="sort-by" class="form-select" onchange="applyFilters('interviews')">
                            <option value="created_at_desc">Date (Newest First)</option>
                            <option value="created_at_asc">Date (Oldest First)</option>
                            <option value="student_name_asc">Student Name (A-Z)</option>
                            <option value="student_name_desc">Student Name (Z-A)</option>
                            <option value="duration_desc">Duration (Longest First)</option>
                            <option value="duration_asc">Duration (Shortest First)</option>
                            <option value="status_asc">Status (A-Z)</option>
                            <option value="verdict_asc">Verdict (A-Z)</option>
                        </select>
                    </div>
                    <div class="sort-option">
                        <label>Secondary Sort:</label>
                        <select id="sort-by-2" class="form-select" onchange="applyFilters('interviews')">
                            <option value="">None</option>
                            <option value="student_name_asc">Student Name (A-Z)</option>
                            <option value="student_name_desc">Student Name (Z-A)</option>
                            <option value="created_at_desc">Date (Newest First)</option>
                            <option value="created_at_asc">Date (Oldest First)</option>
                            <option value="duration_desc">Duration (Longest First)</option>
                            <option value="duration_asc">Duration (Shortest First)</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Group By Section -->
            <div class="group-by-section">
                <div class="filter-section-title">üìã Group By</div>
                <div class="group-by-options">
                    <div class="group-by-option">
                        <input type="radio" id="group-none" name="group-by" value="" onchange="applyFilters('interviews')" checked>
                        <label for="group-none">No Grouping</label>
                    </div>
                    <div class="group-by-option">
                        <input type="radio" id="group-status" name="group-by" value="status" onchange="applyFilters('interviews')">
                        <label for="group-status">Status</label>
                    </div>
                    <div class="group-by-option">
                        <input type="radio" id="group-verdict" name="group-by" value="verdict" onchange="applyFilters('interviews')">
                        <label for="group-verdict">Verdict</label>
                    </div>
                    <div class="group-by-option">
                        <input type="radio" id="group-date" name="group-by" value="date" onchange="applyFilters('interviews')">
                        <label for="group-date">Date</label>
                    </div>
                    <div class="group-by-option">
                        <input type="radio" id="group-duration" name="group-by" value="duration" onchange="applyFilters('interviews')">
                        <label for="group-duration">Duration Range</label>
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="filter-actions">
                <button class="btn-filter" onclick="applyFilters('interviews', true)">Apply Filters</button>
                <button class="btn-clear" onclick="clearAllFilters()">Clear All</button>
                <button class="btn-export" onclick="exportInterviews()">Export CSV</button>
                <button class="btn btn-secondary" onclick="loadInterviews()">Refresh Data</button>
            </div>
        </div>
    </div>

    <!-- Question Filter Panel -->
    <div id="question-filter-panel" class="filter-panel">
        <div class="filter-panel-header">
            <h3>Filter & Sort Questions</h3>
            <button class="close-btn" onclick="closeQuestionFilterPanel()">‚úï</button>
        </div>
        <div class="filter-panel-content">
            <div class="filter-section">
                <div class="filter-section-title">üîé Search</div>
                <div class="filter-row">
                    <div class="filter-group">
                        <label for="search-questions">Search</label>
                        <input type="text" id="search-questions" class="form-input" placeholder="Search by question text or category">
                    </div>
                </div>
            </div>

            <div class="filter-section">
                <div class="filter-section-title">üéØ Filters</div>
                <div class="filter-row">
                    <div class="filter-group">
                        <label for="category-filter">Tags</label>
                        <select id="category-filter" class="form-select">
                            <option value="">All Tags</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="times-asked-min">Times Asked (Min)</label>
                        <input type="number" id="times-asked-min" class="form-input" placeholder="0" min="0">
                    </div>
                    <div class="filter-group">
                        <label for="success-rate-min">Success Rate (Min %)</label>
                        <input type="number" id="success-rate-min" class="form-input" placeholder="0" min="0" max="100">
                    </div>
                </div>
            </div>

            <div class="sort-section">
                <div class="filter-section-title">üìä Sort Options</div>
                <div class="sort-options">
                    <div class="sort-option">
                        <label for="sort-by">Sort by</label>
                        <select id="sort-by" class="form-select">
                            <option value="created_at_desc">Newest First</option>
                            <option value="created_at_asc">Oldest First</option>
                            <option value="question_text_asc">Question (A-Z)</option>
                            <option value="question_text_desc">Question (Z-A)</option>
                            <option value="times_asked_desc">Times Asked (High‚ÜíLow)</option>
                            <option value="times_asked_asc">Times Asked (Low‚ÜíHigh)</option>
                            <option value="success_rate_desc">Success % (High‚ÜíLow)</option>
                            <option value="success_rate_asc">Success % (Low‚ÜíHigh)</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="filter-actions">
                <button class="btn-filter" onclick="closeQuestionFilterPanel()">Close</button>
                <button class="btn-clear" onclick="clearFilters('questions')">Clear</button>
            </div>
        </div>
    </div>

    <style>
        .table th[data-field] { cursor: pointer; }
        .sort-indicator .asc,
        .sort-indicator .desc { cursor: pointer; }
        
        /* Advanced Filters Styling */
        .filters-container{display:flex;flex-direction:column;gap:6px;flex:1}
        .filter-row-adv{display:flex;align-items:center;gap:6px;flex-wrap:nowrap}
        .filter-row-adv .form-select,.filter-row-adv .form-input{height:32px;padding:4px 8px;font-size:13px;border:1px solid #d1d5db;border-radius:4px}
        .filter-row-adv .form-input[type="date"]{padding:4px 6px}
        .filter-row-adv .filter-connector{min-width:70px;max-width:70px}
        .filter-row-adv .filter-field{min-width:140px;max-width:140px}
        .filter-row-adv .filter-op{min-width:120px;max-width:120px}
        .filter-row-adv .filter-value{min-width:160px;flex:1}
        .filter-row-adv .filter-value2{min-width:120px}
        .filter-row-adv .btn{white-space:nowrap}
    </style>

    <script>
        // Sorting state for Question Analysis
        window.questionSortState = { field: 'times_asked', dir: 'desc' };
        function sortByQuestion(field){
            const s = window.questionSortState;
            if (s.field === field){ s.dir = s.dir === 'asc' ? 'desc' : 'asc'; } else { s.field = field; s.dir = 'asc'; }
            updateQuestionSortIndicators();
            if (typeof displayQuestionAnalytics==='function') displayQuestionAnalytics(window.allQuestions||window.questions||[]);
        }
        function updateQuestionSortIndicators(){
            const thead = document.querySelector('#questions-section thead');
            if (!thead) return; const {field,dir}=window.questionSortState;
            thead.querySelectorAll('th[data-field] .sort-indicator .asc').forEach(s=> s.style.opacity='0.3');
            thead.querySelectorAll('th[data-field] .sort-indicator .desc').forEach(s=> s.style.opacity='0.3');
            const asc = thead.querySelector(`th[data-field="${field}"] .sort-indicator .asc`);
            const desc = thead.querySelector(`th[data-field="${field}"] .sort-indicator .desc`);
            if (asc) asc.style.opacity = dir==='asc' ? '1' : '0.3';
            if (desc) desc.style.opacity = dir==='desc' ? '1' : '0.3';
        }
        // Inline sort/search for interviewer lists
        const interviewerSortState = { field: 'created_at', dir: 'desc' };
        function sortByInterviewer(field){
            if (interviewerSortState.field === field){
                interviewerSortState.dir = interviewerSortState.dir === 'asc' ? 'desc' : 'asc';
            } else { interviewerSortState.field = field; interviewerSortState.dir = 'asc'; }
            displayInterviews();
        }
        function applyInterviewerInline(list){
            const term = document.getElementById('interviewer-inline-search')?.value || '';
            const t = term.toLowerCase();
            let filtered = term ? list.filter(i => (
                (i.student_name||'').toLowerCase().includes(t) ||
                (i.zeta_id||'').toLowerCase().includes(t) ||
                (i.session_name||'').toLowerCase().includes(t) ||
                (i.status||'').toLowerCase().includes(t) ||
                (i.verdict||'').toLowerCase().includes(t)
            )) : [...list];
            const {field,dir}=interviewerSortState; const asc=dir==='asc';
            const getVal = (x)=>{
                if (field==='created_at') return new Date(x.created_at||x.interview_date||0).getTime();
                if (field==='duration_seconds') return Number(x.duration_seconds||0);
                return (x[field]??'').toString().toLowerCase();
            };
            filtered.sort((a,b)=>{ const av=getVal(a), bv=getVal(b); if(av<bv) return asc?-1:1; if(av>bv) return asc?1:-1; return 0; });
            return filtered;
        }
        function updateInterviewerSortIndicators(){
            const thead = document.querySelector('#interviews-section thead');
            if (!thead) return; const {field,dir}=interviewerSortState;
            thead.querySelectorAll('th[data-field] .sort-indicator .asc').forEach(s=> s.style.opacity='0.3');
            thead.querySelectorAll('th[data-field] .sort-indicator .desc').forEach(s=> s.style.opacity='0.3');
            const asc = thead.querySelector(`th[data-field="${field}"] .sort-indicator .asc`);
            const desc = thead.querySelector(`th[data-field="${field}"] .sort-indicator .desc`);
            if (asc) asc.style.opacity = dir==='asc' ? '1' : '0.3';
            if (desc) desc.style.opacity = dir==='desc' ? '1' : '0.3';
        }
        // Inline Questions filter (replaces old panel for Questions tab)
        function debounce(fn, d=200){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), d);} }
        function bindInlineQuestionFilters(){
            const el = (id)=>document.getElementById(id);
            const apply = debounce(applyQuestionsInlineFilter, 180);
            ['qf-search','qf-times','qf-success'].forEach(id=>{ const e=el(id); if(e){ e.addEventListener('input', apply);} });
            ['qf-category','qf-sort'].forEach(id=>{ const e=el(id); if(e){ e.addEventListener('change', apply);} });
            // Populate categories from DB
            populateQuestionCategories();
            applyQuestionsInlineFilter();
        }
        function resetInlineQuestionFilters(){
            ['qf-search','qf-times','qf-success'].forEach(id=>{ const e=document.getElementById(id); if(e){ e.value=''; }});
            ['qf-category','qf-sort'].forEach(id=>{ const e=document.getElementById(id); if(e){ e.value=''; }});
            // default sort
            const s=document.getElementById('qf-sort'); if(s){ s.value='created_at_desc'; }
            applyQuestionsInlineFilter();
        }
        function applyQuestionsInlineFilter(){
            try{
                const q=(id)=>document.getElementById(id);
                const term=(q('qf-search')?.value||'').toLowerCase().trim();
                const cat=(q('qf-category')?.value||'').trim();
                const minTimes=parseInt(q('qf-times')?.value||'',10);
                const minSuccess=parseInt(q('qf-success')?.value||'',10);
                const sort=q('qf-sort')?.value||'created_at_desc';
                let data=[...(window.allQuestions||window.questions||[])];
                if (term){ data=data.filter(x=> (x.question_text||x.question||'').toLowerCase().includes(term) || (x.category||'').toLowerCase().includes(term)); }
                if (cat){ data=data.filter(x=> (x.category||'')===cat); }
                if (!isNaN(minTimes)){ data=data.filter(x=> (x.times_asked ?? x.count_of_times_asked ?? 0) >= minTimes); }
                if (!isNaN(minSuccess)){ data=data.filter(x=> (x.success_rate ?? 0) >= minSuccess); }
                // sort
                const [field,dir]=sort.split('_'); const asc=dir==='asc';
                const get=(x,f)=>{
                    if (f==='question_text'){ return (x.question_text||x.question||'').toLowerCase(); }
                    if (f==='times'){ return (x.times_asked ?? x.count_of_times_asked ?? 0); }
                    if (f==='success'){ return (x.success_rate ?? 0); }
                    if (f==='created'){ return new Date(x.created_at || x.created_date || 0).getTime(); }
                    return (x[f]!==undefined? x[f]: '');
                };
                const mapField={question_text:'question_text', times_asked:'times', success_rate:'success', created_at:'created'};
                const f = mapField[field] || field;
                data.sort((a,b)=>{
                    const av=get(a,f), bv=get(b,f);
                    if (av<bv) return asc? -1:1; if (av>bv) return asc? 1:-1; return 0;
                });
                // display
                if (typeof displayQuestionAnalytics==='function') displayQuestionAnalytics(data);
            }catch(e){ console.warn('applyQuestionsInlineFilter error', e); }
        }
        document.addEventListener('DOMContentLoaded', bindInlineQuestionFilters);

        // Debounced filter function for search input
        const debouncedQuestionFilter = debounce(() => applyFilters('questions', false), 300);
        
        async function openQuestionFilterPanel(){
            try {
                await populateQuestionCategories();
            } catch {}
            const panel = document.getElementById('question-filter-panel');
            let overlay = document.getElementById('filter-panel-overlay');
            if (panel){
                panel.classList.add('active');
                // Ensure overlay exists and is active
                if (!overlay){
                    overlay = document.createElement('div');
                    overlay.id = 'filter-panel-overlay';
                    overlay.className = 'filter-panel-overlay active';
                    overlay.onclick = closeQuestionFilterPanel;
                    document.body.appendChild(overlay);
                } else {
                    overlay.classList.add('active');
                }
                
                // Bind live filter events
                bindQuestionFilterEvents();
            }
        }
        
        function bindQuestionFilterEvents() {
            // Search input - debounced
            const searchInput = document.getElementById('search-questions');
            if (searchInput && !searchInput.dataset.bound) {
                searchInput.addEventListener('input', debouncedQuestionFilter);
                searchInput.dataset.bound = 'true';
            }
            
            // Category select - immediate
            const categorySelect = document.getElementById('category-filter');
            if (categorySelect && !categorySelect.dataset.bound) {
                categorySelect.addEventListener('change', () => applyFilters('questions', false));
                categorySelect.dataset.bound = 'true';
            }
            
            // Times asked - debounced
            const timesAskedInput = document.getElementById('times-asked-min');
            if (timesAskedInput && !timesAskedInput.dataset.bound) {
                timesAskedInput.addEventListener('input', debouncedQuestionFilter);
                timesAskedInput.dataset.bound = 'true';
            }
            
            // Success rate - debounced
            const successRateInput = document.getElementById('success-rate-min');
            if (successRateInput && !successRateInput.dataset.bound) {
                successRateInput.addEventListener('input', debouncedQuestionFilter);
                successRateInput.dataset.bound = 'true';
            }
            
            // Sort by - immediate
            const sortBySelect = document.getElementById('sort-by');
            if (sortBySelect && !sortBySelect.dataset.bound) {
                sortBySelect.addEventListener('change', () => applyFilters('questions', false));
                sortBySelect.dataset.bound = 'true';
            }
        }
        function closeQuestionFilterPanel(){
            const panel = document.getElementById('question-filter-panel');
            const overlay = document.getElementById('filter-panel-overlay');
            if (panel){ panel.classList.remove('active'); }
            if (overlay){ overlay.classList.remove('active'); }
        }

        async function populateQuestionCategories(){
            try {
                const res = await fetch('/api/question-bank/tags');
                const j = await res.json();
                if (j && j.success && Array.isArray(j.data)){
                    const sel = document.getElementById('category-filter');
                    if (sel){
                        const tags = j.data.map(t => (typeof t === 'string' ? t : t.tag)).filter(Boolean).sort();
                        sel.innerHTML = '<option value="">All Tags</option>' + tags.map(t=>`<option value="${t}">#${t}</option>`).join('');
                    }
                }
            } catch (e) { console.warn('populateQuestionCategories error', e); }
        }
        // Live filtering: apply filters immediately as user types/selects
        function debounce(fn, delay = 250) {
            let t;
            return (...args) => {
                clearTimeout(t);
                t = setTimeout(() => fn.apply(null, args), delay);
            };
        }

        function initLiveFilters() {
            try {
                // Interviews tab filters
                const bindInterviews = () => {
                    const apply = debounce(() => { applyFilters('interviews'); setClearFiltersVisibility('interviews'); }, 200);
                    ['interviews-search','status-filter','verdict-filter','date-from','date-to','sort-by']
                        .forEach(id => { const el = document.getElementById(id); if (el) {
                            const evt = (el.tagName === 'SELECT' || el.type === 'date') ? 'change' : 'input';
                            el.removeEventListener(evt, apply);
                            el.addEventListener(evt, apply);
                        }});
                    // Group by radios
                    document.querySelectorAll('input[name="group-by"]').forEach(r => {
                        r.removeEventListener('change', apply);
                        r.addEventListener('change', apply);
                    });
                };

                // Questions tab filters
                const bindQuestions = () => {
                    const applyQ = debounce(() => { applyFilters('questions'); setClearFiltersVisibility('questions'); }, 200);
                    ['search-questions','category-filter','times-asked-min','success-rate-min','sort-by']
                        .forEach(id => { const el = document.getElementById(id); if (el) {
                            const evt = (el.tagName === 'SELECT') ? 'change' : 'input';
                            el.removeEventListener(evt, applyQ);
                            el.addEventListener(evt, applyQ);
                        }});
                };

                bindInterviews();
                bindQuestions();

                // Re-bind after panels open (ensures elements exist)
                const originalToggle = window.toggleFilterPanel;
                window.toggleFilterPanel = function(section) {
                    try { if (typeof originalToggle === 'function') originalToggle(section); } catch {}
                    setTimeout(() => {
                        if (section === 'interviews') { initLiveFilters(); setClearFiltersVisibility('interviews'); }
                        if (section === 'questions') { initLiveFilters(); setClearFiltersVisibility('questions'); }
                    }, 0);
                };

                // Initial visibility
                setClearFiltersVisibility('interviews');
                setClearFiltersVisibility('questions');
            } catch (e) { console.warn('initLiveFilters error', e); }
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', initLiveFilters);
        function setClearFiltersVisibility(section) {
            try {
                const map = {
                    'interviews': ['interviews-search','status-filter','verdict-filter','date-from','date-to'],
                    'questions': ['search-questions','category-filter','sort-by','times-asked-min','success-rate-min']
                };
                const ids = map[section] || [];
                const isActive = ids.some(id => {
                    const el = document.getElementById(id);
                    if (!el) return false;
                    if (el.tagName === 'SELECT') return el.value && el.value !== '';
                    if (el.type === 'number') return el.value !== '' && Number(el.value) > 0;
                    return el.value && el.value.trim() !== '';
                });
                const btn = document.getElementById(`clear-filters-${section}`);
                if (btn) btn.style.display = isActive ? '' : 'none';
            } catch {}
        }

        function clearFilters(section) {
            try {
                switch(section) {
                    case 'interviews':
                        ['interviews-search','status-filter','verdict-filter','date-from','date-to'].forEach(id=>{ const el=document.getElementById(id); if(el){ el.value=''; if(el.onchange) el.onchange(); }});
                        applyFilters && applyFilters('interviews');
                        break;
                    case 'questions':
                        ['search-questions','category-filter','sort-by','times-asked-min','success-rate-min'].forEach(id=>{ const el=document.getElementById(id); if(el){ el.value=''; if(el.onchange) el.onchange(); }});
                        // For Questions tab, refresh using displayQuestionAnalytics if needed
                        try { refreshCurrentSection(); } catch { if (typeof displayQuestionAnalytics === 'function' && Array.isArray(window.allQuestions)) displayQuestionAnalytics(window.allQuestions); }
                        break;
                }
                setClearFiltersVisibility(section);
            } catch {}
        }
        let allInterviews = [];
        let allQuestions = [];
        let favoriteQuestionIds = new Set();
        let currentUser = null;
        let sessions = []; // Add sessions array
        
        // Pagination variables
        const ITEMS_PER_PAGE = 10;
        let currentPage = {
            interviews: 1,
            questions: 1
        };
        let totalPages = {
            interviews: 1,
            questions: 1
        };

        // Pagination utility functions
        function getPaginatedData(data, section) {
            const startIndex = (currentPage[section] - 1) * ITEMS_PER_PAGE;
            const endIndex = startIndex + ITEMS_PER_PAGE;
            return data.slice(startIndex, endIndex);
        }
        
        function updateTotalPages(data, section) {
            totalPages[section] = Math.ceil(data.length / ITEMS_PER_PAGE);
            if (currentPage[section] > totalPages[section] && totalPages[section] > 0) {
                currentPage[section] = totalPages[section];
            }
        }
        
        function createPaginationControls(section) {
            const totalPagesCount = totalPages[section];
            if (totalPagesCount <= 1) return '';
            
            let controls = '<div class="pagination-controls">';
            
            // Previous button
            if (currentPage[section] > 1) {
                controls += `<button class="pagination-btn" onclick="changePage('${section}', ${currentPage[section] - 1})">Previous</button>`;
            }
            
            // Page numbers
            const startPage = Math.max(1, currentPage[section] - 2);
            const endPage = Math.min(totalPagesCount, currentPage[section] + 2);
            
            if (startPage > 1) {
                controls += `<button class="pagination-btn" onclick="changePage('${section}', 1)">1</button>`;
                if (startPage > 2) {
                    controls += '<span class="pagination-ellipsis">...</span>';
                }
            }
            
            for (let i = startPage; i <= endPage; i++) {
                const activeClass = i === currentPage[section] ? 'active' : '';
                controls += `<button class="pagination-btn ${activeClass}" onclick="changePage('${section}', ${i})">${i}</button>`;
            }
            
            if (endPage < totalPagesCount) {
                if (endPage < totalPagesCount - 1) {
                    controls += '<span class="pagination-ellipsis">...</span>';
                }
                controls += `<button class="pagination-btn" onclick="changePage('${section}', ${totalPagesCount})">${totalPagesCount}</button>`;
            }
            
            // Next button
            if (currentPage[section] < totalPagesCount) {
                controls += `<button class="pagination-btn" onclick="changePage('${section}', ${currentPage[section] + 1})">Next</button>`;
            }
            
            controls += '</div>';
            return controls;
        }
        
        function changePage(section, page) {
            currentPage[section] = page;
            refreshCurrentSection();
        }
        
        function refreshCurrentSection() {
            const activeSection = document.querySelector('.content-section.active');
            if (activeSection) {
                const sectionId = activeSection.id;
                switch(sectionId) {
                    case 'interviews-section':
                        displayInterviews(allInterviews);
                        break;
                    case 'questions-section':
                        displayQuestionAnalytics(allQuestions);
                        break;
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            checkUserLoginStatus();
            // Debug: Check if functions are available
            console.log('openAddQuestionModal available:', typeof openAddQuestionModal);
            console.log('openBulkImportModal available:', typeof openBulkImportModal);
        });

        async function checkUserLoginStatus() {
            // 1) Prefer URL params (first-time after OAuth redirect)
            const params = new URLSearchParams(window.location.search);
            const urlEmail = params.get('email');
            const urlName = params.get('name');
            const urlRole = params.get('role');
            if (urlEmail || urlName) {
                // Verify the user is authorized
                try {
                    const response = await fetch(`/api/user/role?email=${encodeURIComponent(urlEmail)}`);
                    const data = await response.json();
                    
                    if (!response.ok || !data.success) {
                        console.log('‚ùå User not authorized');
                        window.location.href = '/';
                        return;
                    }
                    
                    const userData = {
                        email: urlEmail || '',
                        name: urlName || (urlEmail ? urlEmail.split('@')[0] : 'User'),
                        role: data.role || 'interviewer'
                    };
                    try { localStorage.setItem('bees_user_data', JSON.stringify(userData)); } catch {}
                    // Clean URL
                    window.history.replaceState({}, document.title, window.location.pathname + window.location.hash);
                } catch (error) {
                    console.error('Error verifying user authorization:', error);
                    window.location.href = '/';
                    return;
                }
            }

            // 2) Load from storage
            const storedUserData = localStorage.getItem('bees_user_data');
            if (storedUserData) {
                try {
                    const userData = JSON.parse(storedUserData);
                    if (userData && (userData.email || userData.name)) {
                        // Verify the stored user is still authorized
                        try {
                            const response = await fetch(`/api/user/role?email=${encodeURIComponent(userData.email)}`);
                            const data = await response.json();
                            
                            if (!response.ok || !data.success) {
                                console.log('‚ùå Stored user not authorized');
                                localStorage.removeItem('bees_user_data');
                                window.location.href = '/';
                                return;
                            }
                        } catch (authError) {
                            console.error('Error verifying stored user authorization:', authError);
                            localStorage.removeItem('bees_user_data');
                            window.location.href = '/';
                            return;
                        }
                        
                        // Avatar initial
                        try {
                            const userIdResponse = await fetch('/api/user/id');
                            const userIdData = await userIdResponse.json();
                            const userId = userIdData.success ? userIdData.userId : null;
                            const initial = userId ? String(userId).charAt(0).toUpperCase() : (userData.email || userData.name).charAt(0).toUpperCase();
                            document.getElementById('user-avatar').textContent = initial;
                        } catch (error) {
                            console.error('Error fetching user ID:', error);
                            document.getElementById('user-avatar').textContent = (userData.email || userData.name).charAt(0).toUpperCase();
                        }
                        const avatar = document.getElementById('user-avatar');
                        const menu = document.getElementById('avatar-menu');
                        avatar.onclick = ()=> { menu.style.display = (menu.style.display==='block'?'none':'block'); };
                        document.addEventListener('click', (e)=>{ if (!avatar.contains(e.target) && !menu.contains(e.target)) menu.style.display='none'; });
                        const logoutBtn = document.getElementById('logout-btn');
                        if (logoutBtn) {
                            logoutBtn.onclick = ()=> {
                                const overlay = document.createElement('div');
                                overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.35);display:flex;align-items:center;justify-content:center;z-index:2000;';
                                overlay.innerHTML = `
                                  <div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;min-width:280px;max-width:90%;padding:16px;box-shadow:0 10px 20px rgba(0,0,0,0.15)">
                                    <div style=\"font-weight:600;margin-bottom:8px;color:#111827\">Logout?</div>
                                    <div style=\"font-size:14px;color:#374151;margin-bottom:12px\">Are you sure you want to logout?</div>
                                    <div style=\"display:flex;gap:8px;justify-content:flex-end\">
                                      <button id=\"lg-cancel\" style=\"border:1px solid #e5e7eb;background:#fff;padding:6px 10px;border-radius:6px;cursor:pointer\">Cancel</button>
                                      <button id=\"lg-confirm\" style=\"background:#111827;color:#fff;border:none;padding:6px 10px;border-radius:6px;cursor:pointer\">Logout</button>
                                    </div>
                                  </div>`;
                                document.body.appendChild(overlay);
                                overlay.querySelector('#lg-cancel').onclick = ()=> overlay.remove();
                                overlay.querySelector('#lg-confirm').onclick = ()=> { overlay.remove(); try { localStorage.removeItem('bees_user_data'); } catch {}; window.location.href = '/'; };
                            };
                        }
                        currentUser = { name: userData.name || 'User', email: userData.email || '' };
                        await loadDashboardData();
                        return;
                    }
                } catch (e) {
                    console.error('Error parsing stored user data:', e);
                    // Do not remove storage blindly; allow retry path below
                }
            }

            // 3) If still no user, go home to sign in
            window.location.href = '/';
        }

        async function loadDashboardData() {
            try {
                await Promise.all([
                    loadMyInterviews(),
                    loadQuestions(),
                    loadFavoriteQuestions(),
                    loadStats(),
                    loadSessions() // Load sessions data but don't populate filters yet
                ]);
            } catch (error) {
                console.error('Error loading dashboard data:', error);
            }
        }

        function showSection(sectionName) {
            // Hide all sections
            document.querySelectorAll('.content-section').forEach(section => {
                section.classList.remove('active');
            });
            
            // Remove active class from all nav links
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
            });
            
            // Show selected section
            document.getElementById(sectionName + '-section').classList.add('active');
            
            // Add active class to clicked nav link
            if (event && event.target && event.target.classList) {
                event.target.classList.add('active');
            } else {
                // If called programmatically, find the correct nav link
                const navLink = document.querySelector(`[onclick="showSection('${sectionName}')"]`);
                if (navLink) {
                    navLink.classList.add('active');
                }
            }
            
            // Update URL to persist tab state
            const url = new URL(window.location);
            url.searchParams.set('tab', sectionName);
            window.history.replaceState({}, '', url);
        }

        // Activate section from URL param, e.g., ?tab=my-interviews or ?tab=questions
        document.addEventListener('DOMContentLoaded', function() {
            const params = new URLSearchParams(window.location.search);
            const tab = params.get('tab');
            if (tab) {
                if (tab === 'my-interviews' || tab === 'interviews') {
                    showSection('interviews');
                } else if (tab === 'questions') {
                    showSection('questions');
                }
            }
        });

        // Filter Panel Functions
        let currentFilterTab = 'interviews'; // Default tab
        
        function toggleFilterPanel(tab = 'interviews') {
            // Close all filter panels first
            document.querySelectorAll('.filter-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            document.getElementById('filter-panel-overlay').classList.remove('active');
            
            // Determine which panel to show
            let panelId = 'filter-panel';
            if (tab === 'questions') {
                panelId = 'question-filter-panel';
            }
            
            const panel = document.getElementById(panelId);
            const overlay = document.getElementById('filter-panel-overlay');
            
            if (panel && !panel.classList.contains('active')) {
                currentFilterTab = tab;
                generateFilterContent(tab);
                panel.classList.add('active');
                overlay.classList.add('active');
            }
        }

        function generateFilterContent(tab) {
            // Determine which panel content to update
            let content;
            if (tab === 'questions') {
                content = document.querySelector('#question-filter-panel .filter-panel-content');
            } else {
                content = document.querySelector('#filter-panel .filter-panel-content');
            }
            
            const titles = {
                'interviews': 'My Interviews',
                'questions': 'Question Analysis'
            };
            
            content.innerHTML = `
                <div class="filter-section">
                    <div class="filter-section-title">üîç Search & Filter</div>
                    <div class="filter-row">
                        ${generateFilterFields(tab)}
                    </div>
                </div>
                
                <div class="sort-section">
                    <div class="filter-section-title">üìä Sort Options</div>
                    <div class="sort-options">
                        ${generateSortOptions(tab)}
                    </div>
                </div>
                
                <div class="group-by-section">
                    <div class="filter-section-title">üìã Group By</div>
                    <div class="group-by-options">
                        ${generateGroupByOptions(tab)}
                    </div>
                </div>
                
                <div class="filter-actions">
                    <button class="btn-filter" onclick="applyFilters('${tab}', true)">Apply Filters</button>
                    <button class="btn-clear" onclick="clearAllFilters('${tab}')">Clear All</button>
                    <button class="btn-export" onclick="exportData('${tab}')">Export Data</button>
                </div>
            `;
            
            // Populate filters with data after they are created
            setTimeout(() => {
                if (tab === 'interviews') {
                    populateSessionFilter();
                } else if (tab === 'questions') {
                    populateCategoryFilter();
                }
            }, 100);
        }

        function generateFilterFields(tab) {
            const filterConfigs = {
                'interviews': `
                    <div class="filter-group">
                        <label>Search:</label>
                        <input type="text" id="search-interviews" class="form-input" placeholder="Search by student name, email, or Zeta ID...">
                    </div>
                    <div class="filter-group">
                        <label>Status:</label>
                        <select id="status-filter" class="form-select">
                            <option value="">All Statuses</option>
                            <option value="completed">Completed</option>
                            <option value="in_progress">In Progress</option>
                            <option value="cancelled">Cancelled</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>Verdict:</label>
                        <select id="verdict-filter" class="form-select">
                            <option value="">All Verdicts</option>
                            <option value="Tiger">Tiger</option>
                            <option value="Cow">Cow</option>
                            <option value="Sheep">Sheep</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>Session:</label>
                        <select id="session-filter" class="form-select">
                            <option value="">All Sessions</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>Date From:</label>
                        <input type="date" id="date-from" class="form-input">
                    </div>
                    <div class="filter-group">
                        <label>Date To:</label>
                        <input type="date" id="date-to" class="form-input">
                    </div>
                `,
                'questions': `
                    <div class="filter-group">
                        <label>Search:</label>
                        <input type="text" id="search-questions" class="form-input" placeholder="Search by question text...">
                    </div>
                    <div class="filter-group">
                        <label>Category:</label>
                        <select id="category-filter" class="form-select">
                            <option value="">Loading categories...</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>Times Asked:</label>
                        <input type="number" id="times-asked-min" class="form-input" placeholder="Min" min="0">
                    </div>
                    <div class="filter-group">
                        <label>Success Rate:</label>
                        <input type="number" id="success-rate-min" class="form-input" placeholder="Min %" min="0" max="100">
                    </div>
                `
            };
            
            return filterConfigs[tab] || '';
        }

        function generateSortOptions(tab) {
            const sortConfigs = {
                'interviews': `
                    <div class="sort-option">
                        <label>Sort by:</label>
                        <select id="sort-by" class="form-select" onchange="applyFilters('interviews')">
                            <option value="created_at_desc">Date (Newest First)</option>
                            <option value="created_at_asc">Date (Oldest First)</option>
                            <option value="student_name_asc">Student Name (A-Z)</option>
                            <option value="student_name_desc">Student Name (Z-A)</option>
                            <option value="student_email_asc">Student Email (A-Z)</option>
                            <option value="student_email_desc">Student Email (Z-A)</option>
                            <option value="zeta_id_asc">Zeta ID (A-Z)</option>
                            <option value="zeta_id_desc">Zeta ID (Z-A)</option>
                            <option value="status_asc">Status (A-Z)</option>
                            <option value="status_desc">Status (Z-A)</option>
                            <option value="verdict_asc">Verdict (A-Z)</option>
                            <option value="verdict_desc">Verdict (Z-A)</option>
                        </select>
                    </div>
                `,
                'questions': `
                    <div class="sort-option">
                        <label>Sort by:</label>
                        <select id="sort-by" class="form-select" onchange="applyFilters('questions')">
                            <option value="question_text_asc">Question (A-Z)</option>
                            <option value="question_text_desc">Question (Z-A)</option>
                            <option value="category_asc">Category (A-Z)</option>
                            <option value="category_desc">Category (Z-A)</option>
                            <option value="times_asked_desc">Times Asked (Most)</option>
                            <option value="times_asked_asc">Times Asked (Least)</option>
                            <option value="average_score_desc">Average Score (Highest)</option>
                            <option value="average_score_asc">Average Score (Lowest)</option>
                            <option value="success_rate_desc">Success Rate (Highest)</option>
                            <option value="success_rate_asc">Success Rate (Lowest)</option>
                            <option value="created_at_desc">Date Added (Newest)</option>
                            <option value="created_at_asc">Date Added (Oldest)</option>
                        </select>
                    </div>
                `
            };
            
            return sortConfigs[tab] || '';
        }

        function generateGroupByOptions(tab) {
            const groupConfigs = {
                'interviews': `
                    <div class="group-by-option">
                        <input type="radio" id="group-none" name="group-by" value="" checked onchange="applyFilters('interviews')">
                        <label for="group-none">No Grouping</label>
                    </div>
                    <div class="group-by-option">
                        <input type="radio" id="group-status" name="group-by" value="status" onchange="applyFilters('interviews')">
                        <label for="group-status">By Status</label>
                    </div>
                    <div class="group-by-option">
                        <input type="radio" id="group-verdict" name="group-by" value="verdict" onchange="applyFilters('interviews')">
                        <label for="group-verdict">By Verdict</label>
                    </div>
                    <div class="group-by-option">
                        <input type="radio" id="group-date" name="group-by" value="created_date" onchange="applyFilters('interviews')">
                        <label for="group-date">By Date</label>
                    </div>
                `,
                'questions': `
                    <div class="group-by-option">
                        <input type="radio" id="group-none" name="group-by" value="" checked onchange="applyFilters('questions')">
                        <label for="group-none">No Grouping</label>
                    </div>
                    <div class="group-by-option">
                        <input type="radio" id="group-category" name="group-by" value="category" onchange="applyFilters('questions')">
                        <label for="group-category">By Category</label>
                    </div>
                    <div class="group-by-option">
                        <input type="radio" id="group-times-asked" name="group-by" value="times_asked" onchange="applyFilters('questions')">
                        <label for="group-times-asked">By Times Asked</label>
                    </div>
                `
            };
            
            return groupConfigs[tab] || '';
        }

        function closeFilterPanel() {
            document.querySelectorAll('.filter-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            document.getElementById('filter-panel-overlay').classList.remove('active');
        }

        function closeQuestionFilterPanel() {
            document.getElementById('question-filter-panel').classList.remove('active');
            document.getElementById('filter-panel-overlay').classList.remove('active');
        }

        // NEW UNIFIED FILTER SYSTEM (CORRECTED IDs FOR QUESTIONS TAB)
        function applyUnifiedFilters(tab, data) {
            console.log(`Applying unified filters for tab: ${tab}`);
            
            if (!data || !Array.isArray(data)) {
                console.warn('No data provided for filtering');
                return [];
            }
            
            let filtered = [...data];
            
            // Get filter values safely
            const getFilterValue = (id) => {
                const element = document.getElementById(id);
                return element ? element.value : '';
            };
            
            const getRadioValue = (name) => {
                const element = document.querySelector(`input[name="${name}"]:checked`);
                return element ? element.value : '';
            };
            
            switch(tab) {
                case 'interviews':
                    // Search filter
                    const searchTerm = getFilterValue('search-interviews');
                    if (searchTerm) {
                        filtered = filtered.filter(i => 
                            (i.student_name && i.student_name.toLowerCase().includes(searchTerm.toLowerCase())) ||
                            (i.student_email && i.student_email.toLowerCase().includes(searchTerm.toLowerCase())) ||
                            (i.zeta_id && i.zeta_id.toLowerCase().includes(searchTerm.toLowerCase()))
                        );
                    }
                    
                    // Status filter
                    const status = getFilterValue('status-filter');
                    if (status) {
                        filtered = filtered.filter(i => i.status === status);
                    }
                    
                    // Verdict filter
                    const verdict = getFilterValue('verdict-filter');
                    if (verdict) {
                        filtered = filtered.filter(i => i.verdict === verdict);
                    }

                    // Session filter
                    const sessionName = getFilterValue('session-filter');
                    if (sessionName) {
                        filtered = filtered.filter(i => (i.session_name || '') === sessionName);
                    }
                    
                    // Date filters
                    const dateFrom = getFilterValue('date-from');
                    const dateTo = getFilterValue('date-to');
                    if (dateFrom) {
                        filtered = filtered.filter(i => new Date(i.created_at || i.interview_date) >= new Date(dateFrom));
                    }
                    if (dateTo) {
                        filtered = filtered.filter(i => new Date(i.created_at || i.interview_date) <= new Date(dateTo));
                    }
                    
                    // Sort
                    const sortBy = getFilterValue('sort-by') || 'created_at_desc';
                    filtered = sortInterviews(filtered, sortBy);
                    break;
                    
                case 'questions':
                    // Search filter (correct ID: search-questions)
                    const qSearch = getFilterValue('search-questions');
                    if (qSearch) {
                        const term = qSearch.toLowerCase();
                        filtered = filtered.filter(q => 
                            (q.question_text && q.question_text.toLowerCase().includes(term)) ||
                            (q.question && q.question.toLowerCase().includes(term)) ||
                            (q.category && q.category.toLowerCase().includes(term))
                        );
                    }

                    // Tag/Category filter (supports both new tags array and legacy category)
                    const qCategory = getFilterValue('category-filter');
                    if (qCategory) {
                        const searchTag = qCategory.toLowerCase();
                        filtered = filtered.filter(q => {
                            // Check tags array first (new system)
                            if (q.tags && Array.isArray(q.tags)) {
                                return q.tags.some(tag => tag.toLowerCase() === searchTag);
                            }
                            // Fallback to category (legacy)
                            return (q.category || '').toLowerCase() === searchTag;
                        });
                    }

                    // Times asked filter
                    const qTimesAskedMin = getFilterValue('times-asked-min');
                    if (qTimesAskedMin !== '') {
                        const min = parseInt(qTimesAskedMin, 10) || 0;
                        filtered = filtered.filter(q => (q.times_asked ?? q.count_of_times_asked ?? 0) >= min);
                    }

                    // Success rate filter
                    const qSuccessRateMin = getFilterValue('success-rate-min');
                    if (qSuccessRateMin !== '') {
                        const min = parseInt(qSuccessRateMin, 10) || 0;
                        filtered = filtered.filter(q => (q.success_rate ?? 0) >= min);
                    }

                    // Sort
                    const qSortBy = getFilterValue('sort-by') || 'created_at_desc';
                    filtered = sortQuestions(filtered, qSortBy);
                    break;
            }
            
            return filtered;
        }

        // ============ Advanced Filter Functions ============
        const textOps = ['contains','equals','starts_with','ends_with','not_contains','not_equals'];
        const dateOps = ['=','‚â†','>','‚â•','<','‚â§','between','not_between'];
        
        // Interviews Filter Functions
        const interviewsFilterFields = [
            { value:'student_name', label:'Student' },
            { value:'zeta_id', label:'Zeta ID' },
            { value:'session_name', label:'Session' },
            { value:'status', label:'Status' },
            { value:'verdict', label:'Verdict' },
            { value:'created_at', label:'Date' }
        ];
        
        function addInterviewsFilterRow(){
            const c = document.getElementById('filters-container-interviews'); if (!c) return;
            const isFirst = c.querySelectorAll('.filter-row-adv').length === 0;
            const row = document.createElement('div');
            row.className = 'filter-row-adv';
            row.style.cssText = 'display:flex;gap:8px;align-items:center;flex-wrap:wrap';
            const connectorHtml = isFirst ? '' : `<select class="filter-connector form-select" style="min-width:90px;padding:0.4rem 0.6rem;border:1px solid #d1d5db;border-radius:4px">
<option value="AND">AND</option>
<option value="OR">OR</option>
<option value="NOT">NOT</option>
</select>`;
            row.innerHTML = `
                ${connectorHtml}
                <select class="filter-field form-select" style="min-width:140px;padding:0.4rem 0.6rem;border:1px solid #d1d5db;border-radius:4px">
                    ${interviewsFilterFields.map(f=>`<option value="${f.value}">${f.label}</option>`).join('')}
                </select>
                <select class="filter-op form-select" style="min-width:140px;padding:0.4rem 0.6rem;border:1px solid #d1d5db;border-radius:4px"></select>
                <input type="text" class="filter-value form-input" placeholder="Value" style="min-width:180px;padding:0.4rem 0.6rem;border:1px solid #d1d5db;border-radius:4px">
                <input type="date" class="filter-value2 form-input" style="display:none;padding:0.4rem 0.6rem;border:1px solid #d1d5db;border-radius:4px">
                <button class="btn btn-secondary" style="padding:0.4rem 0.8rem;font-size:0.875rem" onclick="removeInterviewsFilterRow(this);">Remove</button>
            `;
            c.appendChild(row);
            bindInterviewsFilterRow(row);
            updateInterviewsFilterFieldOptions();
            displayInterviews();
        }
        
        function bindInterviewsFilterRow(row){
            const fieldSel = row.querySelector('.filter-field');
            const opSel = row.querySelector('.filter-op');
            const v1 = row.querySelector('.filter-value');
            const v2 = row.querySelector('.filter-value2');
            function refreshOps(){
                const f = fieldSel.value;
                const isDate = (f === 'created_at');
                const ops = isDate ? dateOps : textOps;
                opSel.innerHTML = ops.map(o=>`<option value="${o}">${o}</option>`).join('');
                v1.type = isDate ? 'date' : 'text';
                v2.style.display = 'none'; v2.value = '';
                opSel.onchange = ()=>{
                    const op = opSel.value;
                    if (isDate && (op==='between' || op==='not_between')) { v2.style.display='inline-block'; } else { v2.style.display='none'; v2.value=''; }
                    displayInterviews();
                };
            }
            fieldSel.onchange = ()=>{ refreshOps(); updateInterviewsFilterFieldOptions(); displayInterviews(); };
            v1.oninput = ()=> displayInterviews();
            v2.oninput = ()=> displayInterviews();
            const connEl = row.querySelector('.filter-connector');
            if (connEl) connEl.onchange = ()=> displayInterviews();
            refreshOps();
        }
        
        function clearAdvancedFiltersInterviews(){ const c=document.getElementById('filters-container-interviews'); if(c){ c.innerHTML=''; } displayInterviews(); }
        function removeInterviewsFilterRow(btn){ const row = btn.parentElement; row && row.remove(); updateInterviewsFilterFieldOptions(); displayInterviews(); }
        function updateInterviewsFilterFieldOptions(){ updateAdvFieldOptions('filters-container-interviews', interviewsFilterFields); }
        function updateAdvFieldOptions(containerId, fields){ 
            const c=document.getElementById(containerId); if(!c) return; 
            const rows=Array.from(c.querySelectorAll('.filter-row-adv')); 
            const selected = new Set(rows.map(r=> (r.querySelector('.filter-field')?.value)||'')); 
            rows.forEach(r=>{ 
                const sel=r.querySelector('.filter-field'); if(!sel) return; 
                const cur=sel.value; 
                const opts = fields.filter(f=> f.value===cur || !selected.has(f.value)); 
                sel.innerHTML = opts.map(f=>`<option value="${f.value}">${f.label}</option>`).join(''); 
                sel.value = cur; 
            }); 
            normalizeFilterConnectors(containerId); 
        }
        function normalizeFilterConnectors(containerId){ 
            const c=document.getElementById(containerId); if(!c) return; 
            const rows=Array.from(c.querySelectorAll('.filter-row-adv')); 
            rows.forEach((r,i)=>{ 
                const conn=r.querySelector('.filter-connector'); 
                if(conn){ conn.style.display = i===0 ? 'none' : 'inline-block'; }
            }); 
        }
        
        function applyAdvancedFiltersInterviews(items){
            const c = document.getElementById('filters-container-interviews'); if (!c) return items;
            const rows = Array.from(c.querySelectorAll('.filter-row-adv'));
            if (rows.length===0) return items;
            function matchRow(item, row){
                const field = row.querySelector('.filter-field').value;
                const op = row.querySelector('.filter-op').value;
                const v1 = row.querySelector('.filter-value').value;
                const v2 = row.querySelector('.filter-value2').value;
                if (!v1 && op !== 'not_between') return true;
                const valRaw = item[field];
                if (field==='created_at'){
                    const ts = valRaw ? new Date(valRaw).getTime() : 0;
                    if (!v1) return true;
                    const d1 = v1 ? new Date(v1) : null;
                    const t1 = d1 ? (d1.setHours(0,0,0,0), d1.getTime()) : NaN;
                    const d2 = v2 ? new Date(v2) : null;
                    const t2 = d2 ? (d2.setHours(23,59,59,999), d2.getTime()) : NaN;
                    const dayStart = d1 ? t1 : NaN;
                    const dayEnd = d1 ? (new Date(v1)).setHours(23,59,59,999) : NaN;
                    switch(op){
                        case '=': return !isNaN(dayStart) && ts>=dayStart && ts<=dayEnd;
                        case '‚â†': return !isNaN(dayStart) && (ts<dayStart || ts>dayEnd);
                        case '>': return ts>t1;
                        case '‚â•': return ts>=t1;
                        case '<': return ts<t1;
                        case '‚â§': return ts<=t1;
                        case 'between': return !isNaN(t1)&&!isNaN(t2) && ts>=Math.min(t1,t2) && ts<=Math.max(t1,t2);
                        case 'not_between': return (isNaN(t1)||isNaN(t2)) ? true : (ts<Math.min(t1,t2) || ts>Math.max(t1,t2));
                        default: return true;
                    }
                } else {
                    if (!v1) return true;
                    const val = (valRaw ?? '').toString().trim().toLowerCase();
                    const q = (v1||'').trim().toLowerCase();
                    switch(op){
                        case 'contains': return val.includes(q);
                        case 'equals': return val===q;
                        case 'starts_with': return val.startsWith(q);
                        case 'ends_with': return val.endsWith(q);
                        case 'not_contains': return !val.includes(q);
                        case 'not_equals': return val!==q;
                        default: return true;
                    }
                }
            }
            return items.filter(r=>{
                let result = true; let first = true;
                for (const row of rows){
                    const connEl = row.querySelector('.filter-connector');
                    const conn = connEl ? connEl.value : 'AND';
                    const m = matchRow(r, row);
                    if (first){ result = m; first=false; continue; }
                    if (conn==='AND') result = result && m;
                    else if (conn==='OR') result = result || m;
                    else if (conn==='NOT') result = result && !m;
                }
                return result;
            });
        }
        
        // Questions Filter Functions
        const questionsFilterFieldsInterviewer = [
            { value:'question', label:'Question Text' },
            { value:'tags', label:'Tags' },
            { value:'times_asked', label:'Times Asked' },
            { value:'average_score', label:'Average Score' }
        ];
        
        function addQuestionsFilterRowInterviewer(){
            const c = document.getElementById('filters-container-questions-interviewer'); if (!c) return;
            const isFirst = c.querySelectorAll('.filter-row-adv').length === 0;
            const row = document.createElement('div');
            row.className = 'filter-row-adv';
            row.style.cssText = 'display:flex;gap:8px;align-items:center;flex-wrap:wrap';
            const connectorHtml = isFirst ? '' : `<select class="filter-connector form-select" style="min-width:90px;padding:0.4rem 0.6rem;border:1px solid #d1d5db;border-radius:4px">
<option value="AND">AND</option>
<option value="OR">OR</option>
<option value="NOT">NOT</option>
</select>`;
            row.innerHTML = `
                ${connectorHtml}
                <select class="filter-field form-select" style="min-width:140px;padding:0.4rem 0.6rem;border:1px solid #d1d5db;border-radius:4px">
                    ${questionsFilterFieldsInterviewer.map(f=>`<option value="${f.value}">${f.label}</option>`).join('')}
                </select>
                <select class="filter-op form-select" style="min-width:140px;padding:0.4rem 0.6rem;border:1px solid #d1d5db;border-radius:4px"></select>
                <input type="text" class="filter-value form-input" placeholder="Value" style="min-width:180px;padding:0.4rem 0.6rem;border:1px solid #d1d5db;border-radius:4px">
                <input type="text" class="filter-value2 form-input" placeholder="Value 2" style="display:none;min-width:120px;padding:0.4rem 0.6rem;border:1px solid #d1d5db;border-radius:4px">
                <button class="btn btn-secondary" style="padding:0.4rem 0.8rem;font-size:0.875rem" onclick="removeQuestionsFilterRowInterviewer(this);">Remove</button>
            `;
            c.appendChild(row);
            bindQuestionsFilterRowInterviewer(row);
            updateQuestionsFilterFieldOptionsInterviewer();
            displayQuestionAnalytics();
        }
        
        function bindQuestionsFilterRowInterviewer(row){
            const fieldSel = row.querySelector('.filter-field');
            const opSel = row.querySelector('.filter-op');
            const v1 = row.querySelector('.filter-value');
            const v2 = row.querySelector('.filter-value2');
            function refreshOps(){
                const f = fieldSel.value;
                const isNumeric = (f === 'times_asked' || f === 'average_score');
                const ops = isNumeric ? ['=','‚â†','>','‚â•','<','‚â§','between','not_between'] : textOps;
                opSel.innerHTML = ops.map(o=>`<option value="${o}">${o}</option>`).join('');
                v1.type = isNumeric ? 'number' : 'text';
                v2.type = isNumeric ? 'number' : 'text';
                v2.style.display = 'none'; v2.value = '';
                opSel.onchange = ()=>{
                    const op = opSel.value;
                    if (op==='between' || op==='not_between') { v2.style.display='inline-block'; } else { v2.style.display='none'; v2.value=''; }
                    displayQuestionAnalytics();
                };
            }
            fieldSel.onchange = ()=>{ refreshOps(); updateQuestionsFilterFieldOptionsInterviewer(); displayQuestionAnalytics(); };
            v1.oninput = ()=> displayQuestionAnalytics();
            v2.oninput = ()=> displayQuestionAnalytics();
            const connEl = row.querySelector('.filter-connector');
            if (connEl) connEl.onchange = ()=> displayQuestionAnalytics();
            refreshOps();
        }
        
        function clearAdvancedFiltersQuestionsInterviewer(){ const c=document.getElementById('filters-container-questions-interviewer'); if(c){ c.innerHTML=''; } displayQuestionAnalytics(); }
        function removeQuestionsFilterRowInterviewer(btn){ const row = btn.parentElement; row && row.remove(); updateQuestionsFilterFieldOptionsInterviewer(); displayQuestionAnalytics(); }
        function updateQuestionsFilterFieldOptionsInterviewer(){ updateAdvFieldOptions('filters-container-questions-interviewer', questionsFilterFieldsInterviewer); }
        
        function applyAdvancedFiltersQuestionsInterviewer(items){
            const c = document.getElementById('filters-container-questions-interviewer'); if (!c) return items;
            const rows = Array.from(c.querySelectorAll('.filter-row-adv'));
            if (rows.length===0) return items;
            function matchRow(item, row){
                const field = row.querySelector('.filter-field').value;
                const op = row.querySelector('.filter-op').value;
                const v1 = row.querySelector('.filter-value').value;
                const v2 = row.querySelector('.filter-value2').value;
                if (!v1 && op !== 'not_between') return true;
                const valRaw = item[field];
                if (field==='times_asked' || field==='average_score'){
                    const num = Number(valRaw) || 0;
                    const n1 = Number(v1) || 0;
                    const n2 = Number(v2) || 0;
                    switch(op){
                        case '=': return num === n1;
                        case '‚â†': return num !== n1;
                        case '>': return num > n1;
                        case '‚â•': return num >= n1;
                        case '<': return num < n1;
                        case '‚â§': return num <= n1;
                        case 'between': return num >= Math.min(n1,n2) && num <= Math.max(n1,n2);
                        case 'not_between': return num < Math.min(n1,n2) || num > Math.max(n1,n2);
                        default: return true;
                    }
                } else {
                    const val = (valRaw ?? '').toString().trim().toLowerCase();
                    const q = (v1||'').trim().toLowerCase();
                    switch(op){
                        case 'contains': return val.includes(q);
                        case 'equals': return val===q;
                        case 'starts_with': return val.startsWith(q);
                        case 'ends_with': return val.endsWith(q);
                        case 'not_contains': return !val.includes(q);
                        case 'not_equals': return val!==q;
                        default: return true;
                    }
                }
            }
            return items.filter(r=>{
                let result = true; let first = true;
                for (const row of rows){
                    const connEl = row.querySelector('.filter-connector');
                    const conn = connEl ? connEl.value : 'AND';
                    const m = matchRow(r, row);
                    if (first){ result = m; first=false; continue; }
                    if (conn==='AND') result = result && m;
                    else if (conn==='OR') result = result || m;
                    else if (conn==='NOT') result = result && !m;
                }
                return result;
            });
        }

        // Sorting functions
        function sortInterviews(interviews, sortBy) {
            if (!sortBy) return interviews;
            
            const [field, direction] = sortBy.split('_');
            const isAsc = direction === 'asc';
            
            return [...interviews].sort((a, b) => {
                let aVal = a[field];
                let bVal = b[field];
                
                // Handle date fields
                if (field.includes('date') || field.includes('created_at')) {
                    aVal = new Date(aVal || 0);
                    bVal = new Date(bVal || 0);
                }
                
                // Handle string fields
                if (typeof aVal === 'string') {
                    aVal = aVal.toLowerCase();
                    bVal = bVal.toLowerCase();
                }
                
                if (aVal < bVal) return isAsc ? -1 : 1;
                if (aVal > bVal) return isAsc ? 1 : -1;
                return 0;
            });
        }

        function sortQuestions(questions, sortBy) {
            if (!sortBy) return questions;
            
            const [field, direction] = sortBy.split('_');
            const isAsc = direction === 'asc';
            
            return [...questions].sort((a, b) => {
                let aVal = a[field];
                let bVal = b[field];
                
                // Handle date fields
                if (field.includes('date') || field.includes('created_at')) {
                    aVal = new Date(aVal || 0);
                    bVal = new Date(bVal || 0);
                }
                
                // Handle string fields
                if (typeof aVal === 'string') {
                    aVal = aVal.toLowerCase();
                    bVal = bVal.toLowerCase();
                }
                
                if (aVal < bVal) return isAsc ? -1 : 1;
                if (aVal > bVal) return isAsc ? 1 : -1;
                return 0;
            });
        }

        // Grouping functions
        function groupInterviews(interviews, groupBy) {
            if (!groupBy || groupBy === 'none') {
                return { interviews };
            }
            
            const groups = {};
            
            interviews.forEach(interview => {
                let groupKey = '';
                
                switch(groupBy) {
                    case 'status':
                        groupKey = interview.status || 'Unknown';
                        break;
                    case 'verdict':
                        groupKey = interview.verdict || 'Unknown';
                        break;
                    case 'created_date':
                        groupKey = new Date(interview.created_at).toLocaleDateString();
                        break;
                    default:
                        groupKey = 'All';
                }
                
                if (!groups[groupKey]) {
                    groups[groupKey] = [];
                }
                groups[groupKey].push(interview);
            });
            
            return groups;
        }

        function displayGroupedInterviews(groupedData, tbody) {
            let html = '';
            
            Object.keys(groupedData).forEach(groupKey => {
                const interviews = groupedData[groupKey];
                html += `
                    <tr class="group-header">
                        <td colspan="6" class="group-title">${groupKey} (${interviews.length} interviews)</td>
                    </tr>
                `;
                
                interviews.forEach(interview => {
                    html += `
                        <tr>
                            <td>${new Date(interview.created_at).toLocaleDateString()}</td>
                            <td>${interview.student_name}</td>
                            <td>${interview.zeta_id}</td>
                            <td>${interview.session_name || 'N/A'}</td>
                            <td><span class="status-badge status-${interview.status}">${interview.status}</span></td>
                            <td>
                                <button class="btn-view" onclick="viewInterview(${interview.id})">View</button>
                            </td>
                        </tr>
                    `;
                });
            });
            
            tbody.innerHTML = html;
        }

        // Dynamic filter functions
        function applyFilters(tab, closePanel = false) {
            console.log(`Applying filters for tab: ${tab}`);
            
            // Get group by value
            const getRadioValue = (name) => {
                const element = document.querySelector(`input[name="${name}"]:checked`);
                return element ? element.value : '';
            };
            const groupBy = getRadioValue('group-by');
            
            // Use the new unified system
            let filteredData = [];
            let displayFunction = null;
            
            switch(tab) {
                case 'interviews':
                    filteredData = applyUnifiedFilters('interviews', allInterviews);
                    displayFunction = () => displayInterviews(filteredData, groupBy);
                    break;
                case 'questions':
                    filteredData = applyUnifiedFilters('questions', allQuestions);
                    displayFunction = () => displayQuestionAnalytics(filteredData);
                    break;
                default:
                    console.log('Unknown tab:', tab);
                    return;
            }
            
            // Display the filtered results
            if (displayFunction) {
                displayFunction();
            }
            
            // Only close panel if explicitly requested (from Apply button)
            if (closePanel) {
                closeQuestionFilterPanel();
            }
        }

        function clearAllFilters(tab) {
            console.log(`Clearing filters for tab: ${tab}`);
            
            // Clear all filter inputs in the current filter panel
            let filterPanel;
            if (tab === 'questions') {
                filterPanel = document.getElementById('question-filter-panel');
            } else {
                filterPanel = document.getElementById('filter-panel');
            }
            
            const inputs = filterPanel.querySelectorAll('input, select');
            inputs.forEach(input => {
                if (input.type === 'radio') {
                    if (input.value === '') {
                        input.checked = true;
                    } else {
                        input.checked = false;
                    }
                } else {
                    input.value = '';
                }
            });
            
            // Apply the cleared filters
            applyFilters(tab);
        }

        function exportData(tab) {
            console.log(`Exporting data for tab: ${tab}`);
            
            switch(tab) {
                case 'interviews':
                    exportInterviews();
                    break;
                case 'questions':
                    exportQuestions();
                    break;
                default:
                    console.log('Unknown tab:', tab);
            }
        }

        // REMOVED: Old conflicting filter functions - replaced with unified system
        /*
        function applyInterviewsFilters() {
            const searchTerm = document.getElementById('search-interviews')?.value || '';
            const status = document.getElementById('status-filter')?.value || '';
            const verdict = document.getElementById('verdict-filter')?.value || '';
            const dateFrom = document.getElementById('date-from')?.value || '';
            const dateTo = document.getElementById('date-to')?.value || '';
            const sortBy = document.getElementById('sort-by')?.value || 'created_at_desc';
            const groupBy = document.querySelector('input[name="group-by"]:checked')?.value || '';

            console.log('Interviews filters:', { searchTerm, status, verdict, dateFrom, dateTo, sortBy, groupBy });
            
            // Apply filters to interviews data
            let filteredInterviews = [...interviews];
            
            // Search filter
            if (searchTerm) {
                filteredInterviews = filteredInterviews.filter(i => 
                    i.student_name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    i.student_email.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    i.zeta_id.toLowerCase().includes(searchTerm.toLowerCase())
                );
            }
            
            // Status filter
            if (status) {
                filteredInterviews = filteredInterviews.filter(i => i.status === status);
            }
            
            // Verdict filter
            if (verdict) {
                filteredInterviews = filteredInterviews.filter(i => i.verdict === verdict);
            }
            
            // Date filters
            if (dateFrom) {
                filteredInterviews = filteredInterviews.filter(i => new Date(i.created_at) >= new Date(dateFrom));
            }
            if (dateTo) {
                filteredInterviews = filteredInterviews.filter(i => new Date(i.created_at) <= new Date(dateTo));
            }
            
            // Sort
            filteredInterviews = sortInterviews(filteredInterviews, sortBy);
            
            // Display filtered results
            displayInterviews(filteredInterviews, groupBy);
        }
        */

        /*
        function applyQuestionsFilters() {
            const searchTerm = document.getElementById('search-questions')?.value || '';
            const category = document.getElementById('category-filter')?.value || '';
            const timesAskedMin = document.getElementById('times-asked-min')?.value || '';
            const successRateMin = document.getElementById('success-rate-min')?.value || '';
            const sortBy = document.getElementById('sort-by')?.value || 'times_asked_desc';
            const groupBy = document.querySelector('input[name="group-by"]:checked')?.value || '';

            console.log('Questions filters:', { searchTerm, category, timesAskedMin, successRateMin, sortBy, groupBy });
            
            // Apply filters to questions data
            let filteredQuestions = [...questions];
            
            // Search filter
            if (searchTerm) {
                filteredQuestions = filteredQuestions.filter(q => 
                    q.question.toLowerCase().includes(searchTerm.toLowerCase())
                );
            }
            
            // Category filter
            if (category) {
                filteredQuestions = filteredQuestions.filter(q => q.category === category);
            }
            
            // Times asked filter
            if (timesAskedMin) {
                filteredQuestions = filteredQuestions.filter(q => q.times_asked >= parseInt(timesAskedMin));
            }
            
            // Success rate filter
            if (successRateMin) {
                filteredQuestions = filteredQuestions.filter(q => q.success_rate >= parseInt(successRateMin));
            }
            
            // Sort
            filteredQuestions = sortQuestions(filteredQuestions, sortBy);
            
            // Display filtered results
            displayQuestions(filteredQuestions, groupBy);
        }
        */

        /*
        // Sorting functions
        function sortInterviews(interviews, sortBy) {
            return interviews.sort((a, b) => {
                const [field, direction] = sortBy.split('_');
                let aVal, bVal;
                
                if (field === 'student_name') {
                    aVal = a.student_name;
                    bVal = b.student_name;
                } else if (field === 'duration') {
                    aVal = a.duration_seconds;
                    bVal = b.duration_seconds;
                } else {
                    aVal = a[field];
                    bVal = b[field];
                }
                
                if (direction === 'asc') {
                    return aVal > bVal ? 1 : -1;
                } else {
                    return aVal < bVal ? 1 : -1;
                }
            });
        }

        function sortQuestions(questions, sortBy) {
            return questions.sort((a, b) => {
                const [field, direction] = sortBy.split('_');
                const aVal = a[field];
                const bVal = b[field];
                
                if (direction === 'asc') {
                    return aVal > bVal ? 1 : -1;
                } else {
                    return aVal < bVal ? 1 : -1;
                }
            });
        }
        */

        // Export functions
        function exportInterviews() {
            const filteredInterviews = getCurrentFilteredInterviews();
            const csvContent = generateInterviewsCSV(filteredInterviews);
            downloadCSV(csvContent, 'my-interviews.csv');
        }

        function exportQuestions() {
            const filteredQuestions = getCurrentFilteredQuestions();
            const csvContent = generateQuestionsCSV(filteredQuestions);
            downloadCSV(csvContent, 'questions.csv');
        }

        // Helper functions for getting current filtered data
        function getCurrentFilteredInterviews() {
            return interviews || [];
        }

        function getCurrentFilteredQuestions() {
            return questions || [];
        }

        // CSV generation functions
        function generateInterviewsCSV(interviews) {
            const headers = ['Date', 'Student Name', 'Zeta ID', 'Session', 'Status', 'Verdict', 'Duration (min)'];
            const rows = interviews.map(i => [
                new Date(i.created_at).toLocaleDateString(),
                `"${i.student_name.replace(/"/g, '""')}"`,
                i.zeta_id,
                i.session_name || 'N/A',
                i.status,
                i.verdict || 'N/A',
                Math.round(i.duration_seconds / 60)
            ]);
            return [headers.join(','), ...rows.map(row => row.join(','))].join('\n');
        }

        function generateQuestionsCSV(questions) {
            const headers = ['Question', 'Category', 'Times Asked', 'Correct Answers', 'Incorrect Answers', 'Success Rate', 'Created At'];
            const rows = questions.map(q => [
                `"${q.question.replace(/"/g, '""')}"`,
                q.category,
                q.times_asked,
                q.correct_answers,
                q.incorrect_answers,
                q.success_rate,
                new Date(q.created_at).toLocaleDateString()
            ]);
            return [headers.join(','), ...rows.map(row => row.join(','))].join('\n');
        }

        function downloadCSV(content, filename) {
            const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        async function loadMyInterviews() {
            const tbody = document.getElementById('interviews-table-body');
            tbody.innerHTML = `<tr><td colspan="8" class="loading">Loading interviews...</td></tr>`;
            try {
                const userEmail = currentUser?.email || '';
                const response = await fetch(`/api/interviewer/interviews?email=${encodeURIComponent(userEmail)}`);
                const result = await response.json();
                if (result.success) {
                    interviews = result.data; // Store in global interviews variable
                    
                    // Populate filter options with real data
                    populateFilterOptions();
                    
                    // Display interviews using the new unified system
                    displayInterviews(interviews);
                } else {
                    showEmptyState('interviews-table-body', 'Failed to load interviews.');
                }
            } catch (error) {
                console.error('Error loading interviews:', error);
                showEmptyState('interviews-table-body', 'Error loading interviews.');
            }
        }

        // Alias for backward compatibility
        function loadInterviews() {
            loadMyInterviews();
        }

        async function loadSessions() {
            try {
                console.log('loadSessions() called - Loading sessions...');
                const response = await fetch('/api/admin/sessions');
                const data = await response.json();
                console.log('loadSessions() - Sessions response:', data);
                
                if (data.success) {
                    sessions = data.data;
                    console.log('loadSessions() - Sessions loaded:', sessions.length);
                    // Don't populate filter here - it will be populated when filter panel is opened
                } else {
                    console.error('loadSessions() - Failed to load sessions:', data.error);
                }
            } catch (error) {
                console.error('loadSessions() - Error loading sessions:', error);
            }
        }

        async function populateSessionFilter() {
            const sessionFilter = document.getElementById('session-filter');
            console.log('populateSessionFilter called, sessionFilter element:', sessionFilter);
            if (!sessionFilter) {
                console.error('Session filter element not found');
                return;
            }
            
            // Clear existing options except "All Sessions"
            sessionFilter.innerHTML = '<option value="">Loading sessions...</option>';
            
            try {
                // Fetch sessions from API
                const response = await fetch('/api/admin/sessions');
                const data = await response.json();
                
                console.log('Sessions API response in populateSessionFilter:', data);
                
                if (data.success) {
                    sessions = data.data;
                    console.log('Sessions data:', sessions);
                    // Clear and add "All Sessions" option
                    sessionFilter.innerHTML = '<option value="">All Sessions</option>';
                    
                    // Add unique session names from all sessions
                    const uniqueSessions = [...new Set(sessions.map(session => session.name))];
                    console.log('Unique sessions to add:', uniqueSessions);
                    uniqueSessions.forEach(sessionName => {
                        const option = document.createElement('option');
                        option.value = sessionName;
                        option.textContent = sessionName;
                        sessionFilter.appendChild(option);
                    });
                    console.log('Session filter populated with', uniqueSessions.length, 'sessions');
                } else {
                    console.error('Failed to load sessions:', data.error);
                    sessionFilter.innerHTML = '<option value="">Error loading sessions</option>';
                }
            } catch (error) {
                console.error('Error loading sessions:', error);
                sessionFilter.innerHTML = '<option value="">Error loading sessions</option>';
            }
        }

        async function loadStats() {
            try {
                const userEmail = currentUser?.email || '';
                const response = await fetch(`/api/interviewer/stats?email=${encodeURIComponent(userEmail)}`);
                const result = await response.json();
                if (result.success) {
                    document.getElementById('total-interviews').textContent = result.data.total;
                    document.getElementById('completed-interviews').textContent = result.data.completed;
                    document.getElementById('in-progress-interviews').textContent = result.data.in_progress;
                } else {
                    console.error('Failed to load stats:', result.error);
                }
            } catch (error) {
                console.error('Error loading stats:', error);
            }
        }

        async function loadFavoriteQuestions() {
            try {
                const userEmail = currentUser?.email || '';
                const response = await fetch(`/api/interviewer/favorites?email=${encodeURIComponent(userEmail)}`);
                const result = await response.json();
                if (result.success) {
                    favoriteQuestionIds = new Set(result.data.map(fav => fav.question_id));
                    document.getElementById('favorite-questions').textContent = favoriteQuestionIds.size;
                } else {
                    console.error('Failed to load favorite questions:', result.error);
                }
            } catch (error) {
                console.error('Error loading favorite questions:', error);
            }
        }

        function displayInterviews(interviewsToDisplay, groupBy = '') {
            const tbody = document.getElementById('interviews-table-body');
            const container = document.querySelector('#interviews-section .table-container');
            if (!tbody) return;

            // Fallback to global list if arg is not provided
            const baseList = Array.isArray(interviewsToDisplay) ? interviewsToDisplay : (window.interviews || []);

            if (!baseList || baseList.length === 0) {
                showEmptyState('interviews-table-body', 'No interviews found.');
                return;
            }

            // Handle grouping if specified
            if (groupBy) {
                const groupedData = groupInterviews(baseList, groupBy);
                displayGroupedInterviews(groupedData, tbody);
                return;
            }

            // Inline search + advanced filters + sort
            let filtered = applyInterviewerInline(baseList);
            filtered = applyAdvancedFiltersInterviews(filtered);
            
            // Check if no results after filtering
            if (filtered.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" class="empty-state">No matches found for your search or filter criteria</td></tr>';
                // Remove pagination controls and info
                if (container) {
                    const existingPagination = container.querySelector('.pagination-controls');
                    if (existingPagination) existingPagination.remove();
                    const existingInfo = container.querySelector('.pagination-info');
                    if (existingInfo) existingInfo.remove();
                }
                return;
            }
            
            // Update pagination
            updateTotalPages(filtered, 'interviews');
            const paginatedData = getPaginatedData(filtered, 'interviews');

            tbody.innerHTML = paginatedData.map(interview => `
                <tr>
                    <td>${formatDate(interview.created_at || interview.interview_date)}</td>
                    <td>${interview.student_name}</td>
                    <td>${interview.zeta_id}</td>
                    <td>${interview.session_name || 'N/A'}</td>
                    <td><span class="status-badge status-${interview.status}">${interview.status}</span></td>
                    <td>${interview.verdict ? `<span style="display:inline-block;padding:2px 6px;border-radius:10px;color:#fff;background:${String(interview.verdict).toLowerCase().includes('tiger')?'#10b981':String(interview.verdict).toLowerCase().includes('cow')?'#f59e0b':String(interview.verdict).toLowerCase().includes('sheep')?'#6b7280':'#6b7280'}">${interview.verdict}</span>` : 'N/A'}</td>
                    <td>${formatDuration(interview.duration_seconds)}</td>
                    <td>
                        ${interview.status === 'in_progress' ? `<button class="btn btn-primary btn-sm" onclick="resumeMyInterview(${interview.id})">Resume</button>` : ''}
                        <button class="btn btn-primary btn-sm" onclick="viewInterview(${interview.id})">View</button>
                    </td>
                </tr>
            `).join('');
            
            // Add pagination controls
            console.log('üîç Debugging pagination for interviews:');
            console.log('Container found:', !!container);
            console.log('Container element:', container);
            console.log('Total interviews:', interviewsToDisplay.length);
            console.log('Total pages:', totalPages['interviews']);
            console.log('Current page:', currentPage['interviews']);
            
            if (container) {
                const existingPagination = container.querySelector('.pagination-controls');
                if (existingPagination) {
                    existingPagination.remove();
                }
                
                const paginationHTML = createPaginationControls('interviews');
                console.log('Pagination HTML generated:', paginationHTML);
                if (paginationHTML) {
                    container.insertAdjacentHTML('beforeend', paginationHTML);
                    console.log('‚úÖ Pagination controls added to container');
                } else {
                    console.log('‚ö†Ô∏è No pagination HTML generated (likely only 1 page)');
                }
                
                // Add pagination info
                const existingInfo = container.querySelector('.pagination-info');
                if (existingInfo) {
                    existingInfo.remove();
                }
                
                const startIndex = (currentPage['interviews'] - 1) * ITEMS_PER_PAGE + 1;
                const endIndex = Math.min(currentPage['interviews'] * ITEMS_PER_PAGE, filtered.length);
                const infoHTML = `
                    <div class="pagination-info">
                        <span>Showing ${startIndex}-${endIndex} of ${filtered.length} interviews</span>
                        <span>Page ${currentPage['interviews']} of ${totalPages['interviews']}</span>
                    </div>
                `;
                container.insertAdjacentHTML('beforeend', infoHTML);
                console.log('‚úÖ Pagination info added to container');
                updateInterviewerSortIndicators();
            } else {
                console.error('‚ùå Container not found for pagination!');
                console.error('Looking for: #interviews-section .table-container');
                console.error('Available containers:', document.querySelectorAll('.table-container'));
            }
        }

        // Enhanced Filter, Sort, and Group Functions
        
        // NOTE: applyFilters function is defined above - this is a duplicate comment block only
        
        // NEW: Unified filter system
        function applyUnifiedFilters(tab, data) {
            if (!data || data.length === 0) return [];
            
            let filtered = [...data];
            
            // Get filter values safely
            const searchTerm = getFilterValue('search-input') || '';
            const statusFilter = getFilterValue('status-filter') || '';
            const verdictFilter = getFilterValue('verdict-filter') || '';
            const dateFrom = getFilterValue('date-from') || '';
            const dateTo = getFilterValue('date-to') || '';
            const sortBy = getFilterValue('sort-by') || '';
            
            // Apply search filter
            if (searchTerm) {
                filtered = filtered.filter(item => {
                    if (tab === 'interviews') {
                        return (item.student_name && item.student_name.toLowerCase().includes(searchTerm.toLowerCase())) ||
                               (item.zeta_id && item.zeta_id.toLowerCase().includes(searchTerm.toLowerCase())) ||
                               (item.student_email && item.student_email.toLowerCase().includes(searchTerm.toLowerCase()));
                    } else if (tab === 'questions') {
                        return (item.question_text && item.question_text.toLowerCase().includes(searchTerm.toLowerCase())) ||
                               (item.category && item.category.toLowerCase().includes(searchTerm.toLowerCase()));
                    }
                    return false;
                });
            }
            
            // Apply status filter
            if (statusFilter && tab === 'interviews') {
                filtered = filtered.filter(item => item.status === statusFilter);
            }
            
            // Apply verdict filter
            if (verdictFilter && tab === 'interviews') {
                filtered = filtered.filter(item => item.verdict === verdictFilter);
            }
            
            // Apply date filters
            if (dateFrom && tab === 'interviews') {
                const fromDate = new Date(dateFrom);
                filtered = filtered.filter(item => {
                    const itemDate = new Date(item.interview_date || item.created_at);
                    return itemDate >= fromDate;
                });
            }
            
            if (dateTo && tab === 'interviews') {
                const toDate = new Date(dateTo);
                toDate.setHours(23, 59, 59, 999);
                filtered = filtered.filter(item => {
                    const itemDate = new Date(item.interview_date || item.created_at);
                    return itemDate <= toDate;
                });
            }
            
            // Apply sorting
            if (sortBy) {
                if (tab === 'interviews') {
                    filtered = sortInterviews(filtered, sortBy);
                } else if (tab === 'questions') {
                    filtered = sortQuestions(filtered, sortBy);
                }
            }
            
            return filtered;
        }
        
        // Helper function to safely get filter values
        function getFilterValue(elementId) {
            const element = document.getElementById(elementId);
            return element ? element.value : '';
        }
        
        // Helper function to safely get radio values
        function getRadioValue(name) {
            const radio = document.querySelector(`input[name="${name}"]:checked`);
            return radio ? radio.value : '';
        }
        
        // NEW: Sorting functions
        function sortInterviews(interviews, sortBy) {
            const sorted = [...interviews];
            
            switch (sortBy) {
                case 'created_at_asc':
                    return sorted.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
                case 'created_at_desc':
                    return sorted.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
                case 'student_name_asc':
                    return sorted.sort((a, b) => (a.student_name || '').localeCompare(b.student_name || ''));
                case 'student_name_desc':
                    return sorted.sort((a, b) => (b.student_name || '').localeCompare(a.student_name || ''));
                case 'zeta_id_asc':
                    return sorted.sort((a, b) => (a.zeta_id || '').localeCompare(b.zeta_id || ''));
                case 'zeta_id_desc':
                    return sorted.sort((a, b) => (b.zeta_id || '').localeCompare(a.zeta_id || ''));
                case 'status_asc':
                    return sorted.sort((a, b) => (a.status || '').localeCompare(b.status || ''));
                case 'status_desc':
                    return sorted.sort((a, b) => (b.status || '').localeCompare(a.status || ''));
                case 'verdict_asc':
                    return sorted.sort((a, b) => (a.verdict || '').localeCompare(b.verdict || ''));
                case 'verdict_desc':
                    return sorted.sort((a, b) => (b.verdict || '').localeCompare(a.verdict || ''));
                default:
                    return sorted;
            }
        }
        
        function sortQuestions(questions, sortBy) {
            const sorted = [...questions];
            
            switch (sortBy) {
                case 'question_text_asc':
                    return sorted.sort((a, b) => (a.question_text || '').localeCompare(b.question_text || ''));
                case 'question_text_desc':
                    return sorted.sort((a, b) => (b.question_text || '').localeCompare(a.question_text || ''));
                case 'category_asc':
                    return sorted.sort((a, b) => (a.category || '').localeCompare(b.category || ''));
                case 'category_desc':
                    return sorted.sort((a, b) => (b.category || '').localeCompare(a.category || ''));
                case 'times_asked_asc':
                    return sorted.sort((a, b) => (a.times_asked || 0) - (b.times_asked || 0));
                case 'times_asked_desc':
                    return sorted.sort((a, b) => (b.times_asked || 0) - (a.times_asked || 0));
                case 'success_rate_asc':
                    return sorted.sort((a, b) => (a.success_rate || 0) - (b.success_rate || 0));
                case 'success_rate_desc':
                    return sorted.sort((a, b) => (b.success_rate || 0) - (a.success_rate || 0));
                default:
                    return sorted;
            }
        }
        
        // NEW: Grouping functions
        function groupInterviews(interviews, groupBy) {
            if (!groupBy) return { groups: null, interviews };
            
            const groups = {};
            
            interviews.forEach(interview => {
                let groupKey;
                switch (groupBy) {
                    case 'status':
                        groupKey = interview.status || 'Unknown';
                        break;
                    case 'verdict':
                        groupKey = interview.verdict || 'No Verdict';
                        break;
                    case 'date':
                        groupKey = formatDate(interview.interview_date || interview.created_at);
                        break;
                    case 'duration':
                        const duration = interview.duration_seconds || 0;
                        const minutes = Math.floor(duration / 60);
                        if (minutes < 5) groupKey = '0-5 minutes';
                        else if (minutes < 15) groupKey = '5-15 minutes';
                        else if (minutes < 30) groupKey = '15-30 minutes';
                        else if (minutes < 60) groupKey = '30-60 minutes';
                        else groupKey = '60+ minutes';
                        break;
                    default:
                        groupKey = 'Other';
                }
                
                if (!groups[groupKey]) {
                    groups[groupKey] = [];
                }
                groups[groupKey].push(interview);
            });
            
            return { groups, interviews };
        }
        
        function displayGroupedInterviews(groupedData, tbody) {
            const { groups } = groupedData;
            let html = '';
            
            Object.keys(groups).sort().forEach(groupKey => {
                const groupInterviews = groups[groupKey];
                html += `
                    <tr class="group-header">
                        <td colspan="8" style="background: #2d3748; color: white; font-weight: 600; padding: 12px;">
                            ${groupKey} (${groupInterviews.length} interviews)
                        </td>
                    </tr>
                `;
                
                groupInterviews.forEach(interview => {
                    html += `
                        <tr data-row-id="${interview.id}">
                            <td>${new Date(interview.created_at).toLocaleDateString()}</td>
                            <td>${interview.student_name || 'N/A'}</td>
                            <td>${interview.zeta_id || 'N/A'}</td>
                            <td>${interview.session_name || 'N/A'}</td>
                            <td><span class="status-badge status-${interview.status}">${interview.status}</span></td>
                            <td>${interview.verdict || 'N/A'}</td>
                            <td>${formatDuration(interview.duration_seconds)}</td>
                            <td>
                                <button class="btn btn-primary btn-sm" onclick="viewInterview(${interview.id})">View</button>
                            </td>
                        </tr>
                    `;
                });
            });
            
            tbody.innerHTML = html;
        }
        
        // NEW: Function to populate filter dropdowns with real data
        function populateFilterOptions() {
            if (!interviews || interviews.length === 0) return;
            
            // Populate status filter
            const statusFilter = document.getElementById('status-filter');
            if (statusFilter) {
                const statuses = [...new Set(interviews.map(i => i.status).filter(Boolean))];
                const currentValue = statusFilter.value;
                statusFilter.innerHTML = '<option value="">All Statuses</option>' + 
                    statuses.map(status => `<option value="${status}">${status}</option>`).join('');
                statusFilter.value = currentValue;
            }
            
            // Populate verdict filter
            const verdictFilter = document.getElementById('verdict-filter');
            if (verdictFilter) {
                const verdicts = [...new Set(interviews.map(i => i.verdict).filter(Boolean))];
                const currentValue = verdictFilter.value;
                verdictFilter.innerHTML = '<option value="">All Verdicts</option>' + 
                    verdicts.map(verdict => `<option value="${verdict}">${verdict}</option>`).join('');
                verdictFilter.value = currentValue;
            }
        }
        
        // NEW: Function to populate question filter options
        async function populateQuestionFilterOptions() {
            console.log('populateQuestionFilterOptions called, questions length:', questions?.length);
            if (!questions || questions.length === 0) return;
            
            // Populate category filter for questions
            await populateCategoryFilter();
        }

        // Function to populate category filter from API
        async function populateCategoryFilter() {
            console.log('populateCategoryFilter called');
            const categoryFilter = document.getElementById('category-filter');
            if (!categoryFilter) {
                console.error('Category filter element not found');
                return;
            }
            
            const currentValue = categoryFilter.value;
            categoryFilter.innerHTML = '<option value="">Loading categories...</option>';
            
            try {
                // Fetch categories from API
                const response = await fetch('/api/question-bank/categories');
                const result = await response.json();
                
                console.log('Categories API response:', result);
                
                if (result.success && result.data) {
                    categoryFilter.innerHTML = '<option value="">All Categories</option>';
                    result.data.forEach(categoryData => {
                        const categoryName = typeof categoryData === 'string' ? categoryData : categoryData.category;
                        const option = document.createElement('option');
                        option.value = categoryName;
                        option.textContent = categoryName;
                        categoryFilter.appendChild(option);
                    });
                    categoryFilter.value = currentValue;
                    console.log('Category filter populated with', result.data.length, 'categories');
                } else {
                    console.error('Failed to load categories:', result.error);
                    categoryFilter.innerHTML = '<option value="">Error loading categories</option>';
                }
            } catch (error) {
                console.error('Error loading categories:', error);
                categoryFilter.innerHTML = '<option value="">Error loading categories</option>';
            }
        }
        
        // NEW: Clear all filters function
        function clearAllFilters(tab) {
            console.log('Clearing all filters for tab:', tab);
            
            // Clear all filter inputs
            const searchInput = document.getElementById('search-input');
            if (searchInput) searchInput.value = '';
            
            const statusFilter = document.getElementById('status-filter');
            if (statusFilter) statusFilter.value = '';
            
            const verdictFilter = document.getElementById('verdict-filter');
            if (verdictFilter) verdictFilter.value = '';
            
            const dateFrom = document.getElementById('date-from');
            if (dateFrom) dateFrom.value = '';
            
            const dateTo = document.getElementById('date-to');
            if (dateTo) dateTo.value = '';
            
            const sortBy = document.getElementById('sort-by');
            if (sortBy) sortBy.value = '';
            
            // Reset grouping
            const groupNone = document.getElementById('group-none');
            if (groupNone) groupNone.checked = true;
            
            // Apply filters to refresh display
            applyFilters(tab);
        }

        // REMOVED: Old conflicting displayFilteredInterviews function

        // REMOVED: Old conflicting applyFiltersToInterviews function

        // REMOVED: Old conflicting applySortingToInterviews function
        
        function getSortFunction(sortKey) {
            switch (sortKey) {
                case 'created_at_desc':
                    return (a, b) => new Date(b.created_at) - new Date(a.created_at);
                case 'created_at_asc':
                    return (a, b) => new Date(a.created_at) - new Date(b.created_at);
                case 'student_name_asc':
                    return (a, b) => (a.student_name || '').localeCompare(b.student_name || '');
                case 'student_name_desc':
                    return (a, b) => (b.student_name || '').localeCompare(a.student_name || '');
                case 'duration_desc':
                    return (a, b) => (b.duration_seconds || 0) - (a.duration_seconds || 0);
                case 'duration_asc':
                    return (a, b) => (a.duration_seconds || 0) - (b.duration_seconds || 0);
                case 'status_asc':
                    return (a, b) => (a.status || '').localeCompare(b.status || '');
                case 'status_desc':
                    return (a, b) => (b.status || '').localeCompare(a.status || '');
                case 'verdict_asc':
                    return (a, b) => (a.verdict || '').localeCompare(b.verdict || '');
                case 'verdict_desc':
                    return (a, b) => (b.verdict || '').localeCompare(a.verdict || '');
                default:
                    return null;
            }
        }

        // REMOVED: Old conflicting applyGroupingToInterviews function

        // REMOVED: Old conflicting displayGroupedInterviews function

        // REMOVED: Old conflicting clearAllFilters function
        
        // REMOVED: Old conflicting updateResultsSummary function
        
        // REMOVED: Old conflicting exportInterviews function

        async function loadQuestions() {
            const tbody = document.getElementById('question-bank-list');
            if (tbody) {
                tbody.innerHTML = '<tr><td colspan="7" class="loading">Loading questions...</td></tr>';
            }

            try {
                // Always load analytics for Question Analysis view
                const response = await fetch('/api/admin/questions/analytics');
                const result = await response.json();

                let data = [];
                if (result && result.success && Array.isArray(result.data)) {
                    data = result.data;
                }

                // Fallback: load from question bank if analytics empty
                if (!data || data.length === 0) {
                    console.warn('‚ö†Ô∏è Analytics returned no questions. Falling back to /api/question-bank');
                    try {
                        const qbRes = await fetch('/api/question-bank');
                        const qbJson = await qbRes.json();
                        if (qbJson && qbJson.success && Array.isArray(qbJson.data)) {
                            // Normalize fields to analytics shape
                            data = qbJson.data.map(q => ({
                                id: q.id,
                                question: q.question || q.question_text || '',
                                category: q.category || null,
                                tags: q.tags || null,
                                times_asked: q.times_asked ?? q.count_of_times_asked ?? 0,
                                total_score: q.total_score ?? 0,
                                average_score: q.average_score ?? 0,
                                success_rate: q.success_rate ?? 0
                            }));
                        }
                    } catch (fallbackErr) {
                        console.error('‚ùå Fallback /api/question-bank failed:', fallbackErr);
                    }
                }

                questions = data || [];
                allQuestions = questions;

                // Display questions using the new unified system
                displayQuestionAnalytics(questions);
            } catch (error) {
                console.error('Error loading questions analytics:', error);
                if (tbody) {
                    tbody.innerHTML = '<tr><td colspan="7" class="empty-state">Error loading questions.</td></tr>';
                }
            }
        }

        function applyQuestionSorting(questions, sortBy) {
            const sorted = [...questions];
            
            switch (sortBy) {
                case 'popularity': // times asked desc
                    return sorted.sort((a, b) => ((b.times_asked ?? b.count_of_times_asked ?? 0) - (a.times_asked ?? a.count_of_times_asked ?? 0)));
                case 'recent': // fallback to id desc if created_at not present
                    return sorted.sort((a, b) => (b.created_at ? new Date(b.created_at) - new Date(a.created_at) : (b.id || 0) - (a.id || 0)));
                case 'alphabetical':
                    return sorted.sort((a, b) => (a.question || '').localeCompare(b.question || ''));
                case 'category':
                    return sorted.sort((a, b) => (a.category || '').localeCompare(b.category || ''));
                default:
                    return sorted;
            }
        }

        function clearQuestionFilters() {
            document.getElementById('bank-search-input').value = '';
            document.getElementById('bank-category-select').value = '';
            document.getElementById('question-sort-by').value = 'popularity';
            loadQuestions();
        }

        function updateQuestionResultsSummary(count) {
            const summaryElement = document.getElementById('question-results-summary');
            if (summaryElement) {
                summaryElement.innerHTML = `<strong>${count}</strong> questions found`;
                summaryElement.style.display = count > 0 ? 'block' : 'none';
            }
        }

        function exportQuestions() {
            if (!allQuestions || allQuestions.length === 0) {
                alert('No questions to export');
                return;
            }

            // Create CSV content
            const headers = ['Question', 'Category', 'Times Asked'];
            const csvContent = [
                headers.join(','),
                ...allQuestions.map(q => [
                    `"${q.question || ''}"`,
                    `"${q.category || ''}"`,
                    q.count_of_times_asked || 0
                ].join(','))
            ].join('\n');
            
            // Download CSV
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `question_bank_export_${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }

        function displayQuestionAnalytics(questionsToDisplay) {
            const tbody = document.getElementById('question-bank-list');
            const container = document.querySelector('#questions-section .table-container');
            if (!tbody) return;

            // Fallback to global questions if no argument provided
            let data = Array.isArray(questionsToDisplay) ? questionsToDisplay : (window.questions || window.allQuestions || []);

            // Inline search support
            const searchBox = document.getElementById('interviewer-questions-inline-search');
            const term = (searchBox?.value || '').toLowerCase().trim();
            if (term) {
                data = data.filter(q => {
                    const text = (q.question_text || q.question || '').toLowerCase();
                    const category = (q.category || '').toLowerCase();
                    const tagsHit = Array.isArray(q.tags) && q.tags.some(t => String(t).toLowerCase().includes(term));
                    return text.includes(term) || category.includes(term) || tagsHit;
                });
            }

            // Apply advanced filters
            data = applyAdvancedFiltersQuestionsInterviewer(data);

            // Sort using questionSortState
            const state = window.questionSortState || { field: 'times_asked', dir: 'desc' };
            let field = state.field;
            let dir = state.dir;
            const asc = dir === 'asc';
            const getVal = (q, f) => {
                if (f === 'question') return (q.question_text || q.question || '').toLowerCase();
                if (f === 'times_asked') return Number(q.times_asked || q.count_of_times_asked || 0);
                if (f === 'average_score') return Number(q.average_score || 0);
                if (f === 'success_rate') return Number(q.success_rate || 0);
                return (q[f] !== undefined ? q[f] : '').toString().toLowerCase();
            };
            data.sort((a,b)=>{ const av=getVal(a,field), bv=getVal(b,field); if(av<bv) return asc?-1:1; if(av>bv) return asc?1:-1; return 0; });

            // Check if no results after filtering
            if (!data || data.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" class="empty-state">No matches found for your search or filter criteria</td></tr>';
                // Remove pagination controls and info
                if (container) {
                    const existingPagination = container.querySelector('.pagination-controls');
                    if (existingPagination) existingPagination.remove();
                    const existingInfo = container.querySelector('.pagination-info');
                    if (existingInfo) existingInfo.remove();
                }
                return;
            }

            // Note: do not override header sort with created_at here
            
            // Update pagination
            updateTotalPages(data, 'questions');
            const paginatedData = getPaginatedData(data, 'questions');

            tbody.innerHTML = paginatedData.map(q => {
                const timesAsked = Number(q.times_asked ?? q.count_of_times_asked ?? 0) || 0;
                const avgScoreNum = Number(q.average_score ?? 0) || 0;
                const totalScore = Number(q.total_score ?? 0) || 0;
                const success = `${Number(q.success_rate ?? 0) || 0}%`;
                const isFavorited = favoriteQuestionIds.has(q.id);
                
                // Debug: Log first question's tags
                if (q === paginatedData[0]) {
                    console.log('üè∑Ô∏è First question tags debug (Interviewer):', {
                        id: q.id,
                        tags: q.tags,
                        tagsType: typeof q.tags,
                        isArray: Array.isArray(q.tags),
                        tagsLength: q.tags?.length,
                        category: q.category
                    });
                }
                
                // Format tags display
                let tagsDisplay = '-';
                if (q.tags && Array.isArray(q.tags) && q.tags.length > 0) {
                    tagsDisplay = q.tags.map(tag => `<span style="display:inline-block;background:#3b82f6;color:#fff;padding:2px 8px;border-radius:12px;font-size:11px;margin:2px">#${tag}</span>`).join(' ');
                } else if (q.category) {
                    tagsDisplay = `<span style="display:inline-block;background:#6b7280;color:#fff;padding:2px 8px;border-radius:12px;font-size:11px;margin:2px">#${q.category}</span>`;
                }
                
                return `
                    <tr>
                        <td><span class="question-text">${q.question || '-'}</span></td>
                        <td>${tagsDisplay}</td>
                        <td>${timesAsked}</td>
                        <td>
                            ${avgScoreNum > 0 ? `
                                <div style="display:flex;align-items:center;gap:0.5rem">
                                    <span style="font-weight:600">${avgScoreNum.toFixed(2)}</span>
                                    <span style="display:inline-block;background:${avgScoreNum > 8 ? '#10b981' : avgScoreNum >= 6 ? '#f59e0b' : '#ef4444'};color:#fff;padding:2px 6px;border-radius:8px;font-size:9px;font-weight:600">${avgScoreNum > 8 ? '#easy' : avgScoreNum >= 6 ? '#medium' : '#hard'}</span>
                                </div>
                            ` : '-'}
                        </td>
                        <td>${success}</td>
                        <td>
                            <button class="favorite-btn ${isFavorited ? 'favorited' : ''}" 
                                    onclick="toggleFavorite(${q.id})" 
                                    title="${isFavorited ? 'Remove from favorites' : 'Add to favorites'}">
                                ${isFavorited ? '‚òÖ' : '‚òÜ'}
                            </button>
                        </td>
                        <td>
                            <button class="btn btn-primary btn-sm" onclick="viewQuestionDetails(${q.id})">View</button>
                        </td>
                    </tr>
                `;
            }).join('');
            
            // Add pagination controls
            if (container) {
                const existingPagination = container.querySelector('.pagination-controls');
                if (existingPagination) {
                    existingPagination.remove();
                }
                
                const paginationHTML = createPaginationControls('questions');
                if (paginationHTML) {
                    container.insertAdjacentHTML('beforeend', paginationHTML);
                }
                
                // Add pagination info
                const existingInfo = container.querySelector('.pagination-info');
                if (existingInfo) {
                    existingInfo.remove();
                }
                
                const startIndex = (currentPage['questions'] - 1) * ITEMS_PER_PAGE + 1;
                const endIndex = Math.min(currentPage['questions'] * ITEMS_PER_PAGE, data.length);
                const infoHTML = `
                    <div class="pagination-info">
                        <span>Showing ${startIndex}-${endIndex} of ${data.length} questions</span>
                        <span>Page ${currentPage['questions']} of ${totalPages['questions']}</span>
                    </div>
                `;
                container.insertAdjacentHTML('beforeend', infoHTML);
            }
        }

        async function viewQuestionDetails(questionId) {
            try {
                const res = await fetch(`/api/admin/questions/${questionId}/details`);
                const json = await res.json();
                if (!res.ok || !json.success) throw new Error(json.error || `HTTP ${res.status}`);

                const q = json.data || json; // support both shapes
                const timesAsked = q.times_asked ?? q.count_of_times_asked ?? 0;
                const avgScore = q.average_score ?? 0;
                const totalScore = q.total_score ?? 0;
                const success = q.success_rate != null ? `${q.success_rate}%` : '-';

                const answersHtml = (q.student_answers || []).map(a => `
                    <div class="question-answer-item">
                        <p><strong>${a.student_name || 'Student'}</strong> (${a.zeta_id || '-'})</p>
                        <p>Answered at: ${a.answered_at ? formatDate(a.answered_at) : '-'}</p>
                        <p>Answer: ${a.answer_text || '-'}</p>
                    </div>
                `).join('') || '<p>No answers recorded.</p>';

                const content = `
                    <div class="detail-section">
                        <h4 class="detail-section-title">Question Information</h4>
                        <div class="detail-item"><div class="detail-label">Question</div><div class="detail-value">${q.question || '-'}</div></div>
                        <div class="detail-item"><div class="detail-label">Category</div><div class="detail-value">${q.category || '-'}</div></div>
                        <div class="detail-item"><div class="detail-label">Times Asked</div><div class="detail-value">${timesAsked}</div></div>
                        <div class="detail-item">
                            <div class="detail-label">Average Score</div>
                            <div class="detail-value">
                                ${avgScore > 0 ? `
                                    <div style="display:flex;align-items:center;gap:0.5rem">
                                        <span>${avgScore.toFixed(2)}</span>
                                        <span style="display:inline-block;background:${avgScore > 8 ? '#10b981' : avgScore >= 6 ? '#f59e0b' : '#ef4444'};color:#fff;padding:2px 6px;border-radius:8px;font-size:9px;font-weight:600">${avgScore > 8 ? '#easy' : avgScore >= 6 ? '#medium' : '#hard'}</span>
                                    </div>
                                ` : '-'}
                            </div>
                        </div>
                        <div class="detail-item"><div class="detail-label">Total Score</div><div class="detail-value">${totalScore}</div></div>
                        <div class="detail-item"><div class="detail-label">Success Rate</div><div class="detail-value">${success}</div></div>
                    </div>
                    <div class="detail-section">
                        <h4 class="detail-section-title">Student Answers</h4>
                        ${answersHtml}
                    </div>
                `;

                openDetailPanel('Question Details', content);
            } catch (e) {
                console.error('Error loading question details:', e);
                showError(e.message || 'Failed to load question details');
            }
        }

        async function toggleFavorite(questionId) {
            try {
                const isFavorited = favoriteQuestionIds.has(questionId);
                const method = isFavorited ? 'DELETE' : 'POST';
                const userEmail = currentUser?.email || '';
                
                const response = await fetch(`/api/interviewer/favorites?email=${encodeURIComponent(userEmail)}`, {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ question_id: questionId })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    if (isFavorited) {
                        favoriteQuestionIds.delete(questionId);
                    } else {
                        favoriteQuestionIds.add(questionId);
                    }
                    
                    updateFavoriteButtons();
                    updateFavoriteCount();
                    
                    const activeCategory = document.getElementById('bank-category-select').value;
                    if (activeCategory === 'Favorites') {
                        loadQuestions();
                    }
                } else {
                    console.error('Error toggling favorite:', result.error);
                }
            } catch (error) {
                console.error('Error toggling favorite:', error);
            }
        }

        function updateFavoriteButtons() {
            document.querySelectorAll('.favorite-btn').forEach(btn => {
                const questionId = parseInt(btn.onclick.toString().match(/\d+/)[0]);
                if (favoriteQuestionIds.has(questionId)) {
                    btn.classList.add('favorited');
                    btn.textContent = '‚òÖ';
                    btn.title = 'Remove from favorites';
                } else {
                    btn.classList.remove('favorited');
                    btn.textContent = '‚òÜ';
                    btn.title = 'Add to favorites';
                }
            });
        }

        function updateFavoriteCount() {
            document.getElementById('favorite-questions').textContent = favoriteQuestionIds.size;
        }

        async function viewInterview(interviewId) {
            try {
                // Get interview details
                const interviewResponse = await fetch(`/api/interviews/${interviewId}`);
                const interviewData = await interviewResponse.json();
                
                if (!interviewData.success) {
                    showError('Interview not found');
                    return;
                }


                const interview = interviewData.data;

                // Get student details
                let studentInfo = 'Unknown Student';
                if (interview.student_id) {
                    try {
                        const studentResponse = await fetch(`/api/students/${interview.student_id}`);
                        const studentData = await studentResponse.json();
                        if (studentData.success) {
                            const student = studentData.data;
                            studentInfo = `${student.first_name} ${student.last_name} (${student.zeta_id})`;
                        }
                    } catch (error) {
                        console.error('Error loading student details:', error);
                    }
                }

                // Get interview questions
                let questionsHtml = '<p>No questions found</p>';
                try {
                    const questionsResponse = await fetch(`/api/interviews/${interviewId}/questions`);
                    const questionsData = await questionsResponse.json();
                    if (questionsData.success && questionsData.data.length > 0) {
                        questionsHtml = questionsData.data.map((q, index) => `
                            <div class="question-answer-item" id="question-${q.id}">
                                <div class="question-header">
                                    <p><strong>Q${index + 1}:</strong> 
                                        ${q.question_rich_content ? 
                                            `<div class="question-text-display rich-content-wrapper">${q.question_rich_content}</div>` : 
                                            `<span class="question-text-display">${q.question_text}</span>`
                                        }
                                    </p>
                                    <button class="icon-btn edit-btn edit-question-btn" data-question-id="${q.id}" data-question-text="${(q.question_text || '').replace(/"/g, '&quot;')}" title="Edit Question"><img src="/edit.png" alt="Edit" style="width:16px;height:16px;vertical-align:middle"></button>
                                </div>
                                <div class="answer-section">
                                    <p><strong>Answer:</strong> <span class="answer-text-display">${q.student_answer || 'No answer provided'}</span></p>
                                    <button class="icon-btn edit-btn edit-answer-btn" data-question-id="${q.id}" data-answer-text="${(q.student_answer || '').replace(/"/g, '&quot;')}" data-answer-photo-url="${encodeURIComponent(q.answer_photo_url || '')}" title="Edit Answer"><img src="/edit.png" alt="Edit" style="width:16px;height:16px;vertical-align:middle"></button>
                                </div>
                                ${q.answer_photo_url ? `
                                    <div class="photo-gallery">
                                        ${(() => {
                                            try {
                                                console.log('Raw answer_photo_url:', q.answer_photo_url);
                                                console.log('Type of answer_photo_url:', typeof q.answer_photo_url);
                                                
                                                // Handle different formats of answer_photo_url
                                                let photoUrls;
                                                
                                                if (typeof q.answer_photo_url === 'string') {
                                                    // Try to parse as JSON
                                                    try {
                                                        photoUrls = JSON.parse(q.answer_photo_url);
                                                    } catch (parseError) {
                                                        console.log('Not valid JSON, treating as single URL');
                                                        photoUrls = q.answer_photo_url;
                                                    }
                                                } else {
                                                    photoUrls = q.answer_photo_url;
                                                }
                                                
                                                console.log('Parsed photoUrls:', photoUrls);
                                                
                                                if (Array.isArray(photoUrls)) {
                                                    return photoUrls.map((url, index) => {
                                                        // Clean up URL if it has malformed characters
                                                        const cleanUrl = url.replace(/^\[|\]$/g, '').replace(/^"|"$/g, '');
                                                        console.log(`Processing URL ${index}:`, cleanUrl);
                                                        return `
                                                            <div class="photo-item">
                                                                <img src="${cleanUrl}" alt="Answer photo" class="answer-image" onclick="openImageModal('${cleanUrl}')">
                                                            </div>
                                                        `;
                                                    }).join('');
                                                } else if (typeof photoUrls === 'string' && photoUrls.trim()) {
                                                    // Handle single image (backward compatibility)
                                                    const cleanUrl = photoUrls.replace(/^\[|\]$/g, '').replace(/^"|"$/g, '');
                                                    console.log('Single URL:', cleanUrl);
                                                    return `
                                                        <div class="photo-item">
                                                            <img src="${cleanUrl}" alt="Answer photo" class="answer-image" onclick="openImageModal('${cleanUrl}')">
                                                        </div>
                                                    `;
                                                } else {
                                                    console.log('No valid photo URLs found');
                                                    return '<p>No valid images found</p>';
                                                }
                                            } catch (e) {
                                                console.error('Error processing photo URLs:', e);
                                                console.log('Raw value:', q.answer_photo_url);
                                                return '<p>Error loading images</p>';
                                            }
                                        })()}
                                    </div>
                                ` : ''}
                            </div>
                        `).join('');
                    }
                } catch (error) {
                    console.error('Error loading interview questions:', error);
                }

                const content = `
                    <div class="detail-section">
                        <h4 class="detail-section-title">Interview Information</h4>
                        <div class="detail-item">
                            <div class="detail-label">Interview ID</div>
                            <div class="detail-value">#${interview.id}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Student</div>
                            <div class="detail-value">${studentInfo}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Date</div>
                            <div class="detail-value">${formatDate(interview.interview_date)}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Status</div>
                            <div class="detail-value"><span class="status-badge status-${interview.status}">${interview.status}</span></div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Duration</div>
                            <div class="detail-value">${interview.duration_seconds ? formatDuration(interview.duration_seconds) : 'N/A'}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Verdict</div>
                            <div class="detail-value">${interview.verdict || 'No Verdict'}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Overall Notes</div>
                            <div class="detail-value">${interview.overall_notes || 'No notes available'}</div>
                        </div>
                    </div>
                    
                    <div class="detail-section">
                        <h4 class="detail-section-title">Questions & Answers</h4>
                        <div class="detail-section-content">
                            ${questionsHtml}
                        </div>
                    </div>
                `;

                openDetailPanel(`Interview #${interview.id}`, content);

            } catch (error) {
                console.error('Error loading interview details:', error);
                showError('Error loading interview details');
            }
        }

        function resumeMyInterview(interviewId) {
            try {
                const item = (interviews || []).find(i => i.id === interviewId);
                if (!item) {
                    showError('Interview not found');
                    return;
                }
                const zeta = item.zeta_id || '';
                const sessionId = item.session_id || item.session || '';
                if (!zeta || !sessionId) {
                    showError('Missing Zeta ID or Session');
                    return;
                }
                const url = `/interview-session.html?zeta_id=${encodeURIComponent(zeta)}&session_id=${encodeURIComponent(sessionId)}&resume=1`;
                window.location.href = url;
            } catch (e) {
                console.error('Error resuming interview', e);
                showError('Unable to resume interview');
            }
        }

        function showEmptyState(tableBodyId, message) {
            const tbody = document.getElementById(tableBodyId);
            tbody.innerHTML = `
                <tr>
                    <td colspan="8" class="empty-state">
                        <i>üìã</i>
                        <div>${message}</div>
                    </td>
                </tr>
            `;
        }

        function formatDuration(seconds) {
            if (seconds === null || seconds === undefined) return 'N/A';
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function formatDate(dateString) {
            if (!dateString) return 'N/A';
            const d = new Date(dateString);
            if (isNaN(d.getTime())) return 'N/A';
            const dd = String(d.getDate()).padStart(2, '0');
            const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            const mmm = months[d.getMonth()];
            const yyyy = d.getFullYear();
            return `${dd}/${mmm}/${yyyy}`;
        }

        function showError(message) {
            alert('Error: ' + message);
        }

        function openDetailPanel(title, content) {
            // Create detail panel if it doesn't exist
            let detailPanel = document.getElementById('detail-panel');
            if (!detailPanel) {
                detailPanel = document.createElement('div');
                detailPanel.id = 'detail-panel';
                detailPanel.className = 'detail-panel';
                document.body.appendChild(detailPanel);
            }

            // Create overlay if it doesn't exist
            let overlay = document.getElementById('detail-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'detail-overlay';
                overlay.className = 'detail-overlay';
                overlay.onclick = closeDetailPanel;
                document.body.appendChild(overlay);
            }

            // Set content
            detailPanel.innerHTML = `
                <div class="detail-panel-header">
                    <h3>${title}</h3>
                    <button class="detail-panel-close" onclick="closeDetailPanel()">&times;</button>
                </div>
                <div class="detail-panel-content">
                    ${content}
                </div>
            `;

            // Show panel
            detailPanel.classList.add('active');
            overlay.classList.add('active');
            
            // Add event listeners for edit buttons after content is loaded
            setupEditButtonListeners();
        }
        
        // Setup event listeners for edit buttons using data attributes
        function setupEditButtonListeners() {
            // Question edit buttons
            document.querySelectorAll('.edit-question-btn').forEach(button => {
                button.removeEventListener('click', handleEditQuestionClick); // Remove existing listeners
                button.addEventListener('click', handleEditQuestionClick);
            });
            
            // Answer edit buttons  
            document.querySelectorAll('.edit-answer-btn').forEach(button => {
                button.removeEventListener('click', handleEditAnswerClick); // Remove existing listeners
                button.addEventListener('click', handleEditAnswerClick);
            });
        }
        
        // Handle question edit button clicks
        function handleEditQuestionClick(event) {
            // Use currentTarget to get the button element, not the clicked child (e.g., img)
            const button = event.currentTarget;
            const questionId = button.getAttribute('data-question-id');
            const questionText = button.getAttribute('data-question-text');
            editQuestionText(questionId, questionText);
        }
        
        // Handle answer edit button clicks
        function handleEditAnswerClick(event) {
            // Use currentTarget to get the button element, not the clicked child (e.g., img)
            const button = event.currentTarget;
            const questionId = button.getAttribute('data-question-id');
            const answerText = button.getAttribute('data-answer-text');
            const answerPhotoUrl = decodeURIComponent(button.getAttribute('data-answer-photo-url') || ''); // Decode URL-encoded value
            console.log('üîò Edit button clicked, photo URL:', answerPhotoUrl);
            editQuestionAnswer(questionId, answerText, answerPhotoUrl);
        }

        function closeDetailPanel() {
            const detailPanel = document.getElementById('detail-panel');
            const overlay = document.getElementById('detail-overlay');
            
            if (detailPanel) detailPanel.classList.remove('active');
            if (overlay) overlay.classList.remove('active');
        }

        function openImageModal(imageUrl) {
            // Create image modal if it doesn't exist
            let imageModal = document.getElementById('image-modal');
            if (!imageModal) {
                imageModal = document.createElement('div');
                imageModal.id = 'image-modal';
                imageModal.className = 'image-modal';
                imageModal.innerHTML = `
                    <div class="image-modal-content">
                        <span class="image-modal-close" onclick="closeImageModal()">&times;</span>
                        <img id="modal-image" src="" alt="Full size image">
                    </div>
                `;
                imageModal.onclick = closeImageModal;
                document.body.appendChild(imageModal);
            }

            // Set image source and show modal
            document.getElementById('modal-image').src = imageUrl;
            imageModal.classList.add('active');
        }

        function closeImageModal() {
            const imageModal = document.getElementById('image-modal');
            if (imageModal) {
                imageModal.classList.remove('active');
            }
        }

        // Store tags for the current question
        let interviewerModalTags = [];

        // Add Question Modal Functions
        async function openAddQuestionModal() {
            console.log('openAddQuestionModal called');
            interviewerModalTags = [];
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.35);display:flex;align-items:center;justify-content:center;z-index:2000;';
            modal.innerHTML = `
                <div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;min-width:500px;max-width:90%;padding:24px;box-shadow:0 10px 20px rgba(0,0,0,0.15)">
                    <div style="font-weight:600;margin-bottom:16px;color:#111827;font-size:1.2rem">Add New Question</div>
                    <div style="margin-bottom:16px">
                        <label style="display:block;margin-bottom:8px;font-weight:500;color:#374151">Question Text *</label>
                        <textarea id="new-question-text" style="width:100%;padding:12px;border:1px solid #d1d5db;border-radius:6px;font-size:14px;min-height:100px;resize:vertical" placeholder="Enter your question here..."></textarea>
                    </div>
                    <div style="margin-bottom:16px">
                        <label style="display:block;margin-bottom:8px;font-weight:500;color:#374151">Tags (Hashtags) *</label>
                        <div id="modal-tags-container" style="display:flex;flex-wrap:wrap;gap:8px;padding:8px;border:1px solid #d1d5db;border-radius:6px;min-height:42px;background:#fff;cursor:text">
                            <input type="text" id="modal-tags-input" placeholder="Type tag and press Enter..." style="border:none;outline:none;flex:1;min-width:150px;font-size:14px">
                        </div>
                        <div style="margin-top:4px;font-size:12px;color:#6b7280">
                            üí° Suggested: <span id="modal-suggested-tags"></span>
                        </div>
                    </div>
                    <div style="display:flex;gap:8px;justify-content:flex-end">
                        <button id="add-question-cancel" style="border:1px solid #e5e7eb;background:#fff;padding:8px 16px;border-radius:6px;cursor:pointer">Cancel</button>
                        <button id="add-question-save" style="background:#059669;color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer">Add Question</button>
                    </div>
                </div>`;
            document.body.appendChild(modal);
            
            // Load suggested tags from database
            await loadSuggestedTagsForModal();
            
            // Setup tag input
            const input = modal.querySelector('#modal-tags-input');
            const container = modal.querySelector('#modal-tags-container');
            
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const tag = input.value.trim();
                    if (tag && !interviewerModalTags.includes(tag)) {
                        interviewerModalTags.push(tag);
                        addModalTagChip(tag, container, input);
                        input.value = '';
                    }
                }
            });
            
            container.addEventListener('click', () => input.focus());
            
            modal.querySelector('#add-question-cancel').onclick = () => modal.remove();
            
            modal.querySelector('#add-question-save').onclick = async () => {
                const questionText = document.getElementById('new-question-text').value.trim();
                
                if (!questionText) {
                    alert('Please enter a question text');
                    return;
                }
                
                if (interviewerModalTags.length === 0) {
                    alert('Please add at least one tag');
                    return;
                }
                
                try {
                    const response = await fetch('/api/question-bank', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            question: questionText,
                            tags: interviewerModalTags
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        modal.remove();
                        showSuccess('Question added with tags: ' + interviewerModalTags.map(t => '#' + t).join(' '));
                        loadQuestions(); // Refresh the question list
                    } else {
                        showError('Error adding question: ' + (result.error || 'Unknown error'));
                    }
                } catch (error) {
                    console.error('Error adding question:', error);
                    showError('Error adding question');
                }
            };
        }

        // Add tag chip to modal
        function addModalTagChip(tag, container, input) {
            const chip = document.createElement('span');
            chip.style.cssText = 'display:inline-flex;align-items:center;background:#3b82f6;color:#fff;padding:4px 10px;border-radius:16px;font-size:13px';
            chip.innerHTML = `#${tag} <span style="margin-left:6px;cursor:pointer;font-weight:bold">&times;</span>`;
            chip.querySelector('span').onclick = () => {
                interviewerModalTags = interviewerModalTags.filter(t => t !== tag);
                chip.remove();
            };
            container.insertBefore(chip, input);
        }

        // Load suggested tags for modal
        async function loadSuggestedTagsForModal() {
            try {
                const response = await fetch('/api/question-bank/tags');
                const result = await response.json();
                
                const suggestedSpan = document.getElementById('modal-suggested-tags');
                if (result.success && result.data && result.data.length > 0) {
                    const topTags = result.data.slice(0, 6);
                    suggestedSpan.innerHTML = topTags.map(tagData => {
                        const tagName = typeof tagData === 'string' ? tagData : tagData.tag;
                        return `<span onclick="addModalSuggestedTag('${tagName}')" style="margin-right:10px;color:#3b82f6;text-decoration:underline;cursor:pointer">#${tagName}</span>`;
                    }).join('');
                } else {
                    suggestedSpan.innerHTML = '<span style="color:#9ca3af">No tags yet</span>';
                }
            } catch (error) {
                console.error('Error loading tags:', error);
            }
        }

        // Add suggested tag to modal
        window.addModalSuggestedTag = function(tag) {
            const input = document.getElementById('modal-tags-input');
            const container = document.getElementById('modal-tags-container');
            if (!interviewerModalTags.includes(tag)) {
                interviewerModalTags.push(tag);
                addModalTagChip(tag, container, input);
            }
        }

        // Load categories for the modal
        async function loadCategoriesForModal() {
            try {
                const response = await fetch('/api/question-bank/categories');
                const result = await response.json();
                
                const categorySelect = document.getElementById('new-question-category');
                if (result.success && result.data) {
                    categorySelect.innerHTML = '<option value="">Select Category</option>';
                    result.data.forEach(categoryData => {
                        const categoryName = typeof categoryData === 'string' ? categoryData : categoryData.category;
                        const option = document.createElement('option');
                        option.value = categoryName;
                        option.textContent = categoryName;
                        categorySelect.appendChild(option);
                    });
                } else {
                    categorySelect.innerHTML = '<option value="">No categories found</option>';
                }
            } catch (error) {
                console.error('Error loading categories:', error);
                document.getElementById('new-question-category').innerHTML = '<option value="">Error loading categories</option>';
            }
        }

        // Add new category
        async function addNewCategory(categoryName, modal) {
            try {
                const response = await fetch('/api/question-bank/categories', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ category: categoryName })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Add to dropdown
                    const categorySelect = document.getElementById('new-question-category');
                    const option = document.createElement('option');
                    option.value = categoryName;
                    option.textContent = categoryName;
                    option.selected = true;
                    categorySelect.appendChild(option);
                    
                    // Hide input
                    document.getElementById('new-category-input').style.display = 'none';
                    document.getElementById('new-category-name').value = '';
                    
                    showSuccess('Category added successfully!');
                } else {
                    showError('Error adding category: ' + (result.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error adding category:', error);
                showError('Error adding category');
            }
        }

        // Bulk Import Modal Functions
        function openBulkImportModal() {
            console.log('openBulkImportModal called');
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.35);display:flex;align-items:center;justify-content:center;z-index:2000;';
            modal.innerHTML = `
                <div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;min-width:700px;max-width:90%;padding:24px;box-shadow:0 10px 20px rgba(0,0,0,0.15)">
                    <div style="font-weight:600;margin-bottom:16px;color:#111827;font-size:1.2rem">Bulk Import Questions</div>
                    
                    <!-- Import Method Tabs -->
                    <div style="margin-bottom:16px">
                        <div style="display:flex;gap:8px;margin-bottom:16px">
                            <button id="text-import-tab" class="import-tab active" style="padding:8px 16px;border:1px solid #d1d5db;background:#f9fafb;border-radius:6px;cursor:pointer">Text Input</button>
                            <button id="file-import-tab" class="import-tab" style="padding:8px 16px;border:1px solid #d1d5db;background:#f9fafb;border-radius:6px;cursor:pointer">File Upload</button>
                        </div>
                    </div>
                    
                    <!-- Text Input Section -->
                    <div id="text-import-section">
                        <div style="margin-bottom:16px;padding:12px;background:#f3f4f6;border-radius:6px;font-size:14px;color:#374151">
                            <strong>Instructions:</strong><br>
                            ‚Ä¢ Enter one question per line<br>
                            ‚Ä¢ Use format: "Question text | #tag1 #tag2 #tag3"<br>
                            ‚Ä¢ Example: "What is JavaScript? | #technical #javascript #frontend"<br>
                            ‚Ä¢ Multiple tags supported, separated by spaces with # prefix
                        </div>
                        <div style="margin-bottom:16px">
                            <label style="display:block;margin-bottom:8px;font-weight:500;color:#374151">Questions *</label>
                            <textarea id="bulk-questions-text" style="width:100%;padding:12px;border:1px solid #d1d5db;border-radius:6px;font-size:14px;min-height:200px;resize:vertical;font-family:monospace" placeholder="Enter questions here, one per line..."></textarea>
                        </div>
                    </div>
                    
                    <!-- File Upload Section -->
                    <div id="file-import-section" style="display:none">
                        <div style="margin-bottom:16px;padding:12px;background:#f3f4f6;border-radius:6px;font-size:14px;color:#374151">
                            <strong>CSV Format Instructions:</strong><br>
                            ‚Ä¢ First row can be a header (will be skipped)<br>
                            ‚Ä¢ Format: "Question,Tags" where Tags is like "#tag1 #tag2 #tag3"<br>
                            ‚Ä¢ <strong>Important:</strong> Use quotes around questions that contain commas<br>
                            ‚Ä¢ Example: "What is JavaScript, and how does it work?","#technical #javascript"<br>
                            ‚Ä¢ Example: "Tell me about yourself","#behavioral #interview"<br>
                            ‚Ä¢ Multiple tags should be separated by spaces and start with #
                        </div>
                        <div style="margin-bottom:16px">
                            <label style="display:block;margin-bottom:8px;font-weight:500;color:#374151">Upload File *</label>
                            <div style="border:2px dashed #d1d5db;border-radius:8px;padding:24px;text-align:center;background:#f9fafb">
                                <input type="file" id="bulk-import-file" accept=".csv,.xlsx,.xls" style="display:none">
                                <div style="margin-bottom:8px">
                                    <span style="font-size:24px">üìÅ</span>
                                </div>
                                <div style="margin-bottom:8px;font-weight:500">Click to select file or drag and drop</div>
                                <div style="font-size:12px;color:#6b7280">CSV, XLSX, XLS files only</div>
                                <button id="file-select-btn" style="margin-top:12px;background:#3b82f6;color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer">Select File</button>
                            </div>
                            <div id="selected-file-info" style="margin-top:8px;padding:8px;background:#e0f2fe;border-radius:4px;display:none">
                                <span id="selected-file-name"></span>
                                <button id="remove-file-btn" style="margin-left:8px;background:#ef4444;color:#fff;border:none;padding:4px 8px;border-radius:4px;cursor:pointer;font-size:12px">Remove</button>
                            </div>
                        </div>
                    </div>
                    
                    <div style="display:flex;gap:8px;justify-content:flex-end">
                        <button id="bulk-import-cancel" style="border:1px solid #e5e7eb;background:#fff;padding:8px 16px;border-radius:6px;cursor:pointer">Cancel</button>
                        <button id="bulk-import-save" style="background:#3b82f6;color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer">Import Questions</button>
                    </div>
                </div>`;
            document.body.appendChild(modal);
            
            // Tab switching
            modal.querySelector('#text-import-tab').onclick = () => {
                document.getElementById('text-import-section').style.display = 'block';
                document.getElementById('file-import-section').style.display = 'none';
                modal.querySelector('#text-import-tab').style.background = '#3b82f6';
                modal.querySelector('#text-import-tab').style.color = '#fff';
                modal.querySelector('#file-import-tab').style.background = '#f9fafb';
                modal.querySelector('#file-import-tab').style.color = '#000';
            };
            
            modal.querySelector('#file-import-tab').onclick = () => {
                document.getElementById('text-import-section').style.display = 'none';
                document.getElementById('file-import-section').style.display = 'block';
                modal.querySelector('#file-import-tab').style.background = '#3b82f6';
                modal.querySelector('#file-import-tab').style.color = '#fff';
                modal.querySelector('#text-import-tab').style.background = '#f9fafb';
                modal.querySelector('#text-import-tab').style.color = '#000';
            };
            
            // File selection
            modal.querySelector('#file-select-btn').onclick = () => {
                document.getElementById('bulk-import-file').click();
            };
            
            document.getElementById('bulk-import-file').onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    document.getElementById('selected-file-name').textContent = file.name;
                    document.getElementById('selected-file-info').style.display = 'block';
                }
            };
            
            modal.querySelector('#remove-file-btn').onclick = () => {
                document.getElementById('bulk-import-file').value = '';
                document.getElementById('selected-file-info').style.display = 'none';
            };
            
            modal.querySelector('#bulk-import-cancel').onclick = () => modal.remove();
            modal.querySelector('#bulk-import-save').onclick = async () => {
                const saveBtn = modal.querySelector('#bulk-import-save');
                
                // Prevent multiple simultaneous imports
                if (saveBtn.disabled) {
                    console.log('‚ö†Ô∏è Import already in progress, ignoring duplicate request');
                    return;
                }
                
                const textSection = document.getElementById('text-import-section');
                const fileSection = document.getElementById('file-import-section');
                let questions = [];
                
                if (textSection.style.display !== 'none') {
                    // Text import
                    const questionsText = document.getElementById('bulk-questions-text').value.trim();
                    
                    if (!questionsText) {
                        alert('Please enter questions to import');
                        return;
                    }
                    
                    // Parse questions (format: "Question text | #tag1 #tag2 #tag3")
                    const lines = questionsText.split('\n').filter(line => line.trim());
                    questions = lines.map((line, index) => {
                        const parts = line.split('|').map(part => part.trim());
                        if (parts.length === 0 || !parts[0]) {
                            throw new Error(`Line ${index + 1}: Empty question text`);
                        }
                        
                        // Parse tags from the second part
                        let tags = [];
                        if (parts[1]) {
                            // Extract hashtags (words starting with #)
                            tags = parts[1].match(/#\w+/g) || [];
                            tags = tags.map(tag => tag.substring(1)); // Remove # prefix
                        }
                        
                        return {
                            question: parts[0],
                            tags: tags.length > 0 ? tags : ['general']
                        };
                    });
                } else {
                    // File import
                    const fileInput = document.getElementById('bulk-import-file');
                    const file = fileInput.files[0];
                    
                    if (!file) {
                        alert('Please select a file to import');
                        return;
                    }
                    
                    try {
                        questions = await parseFile(file);
                    } catch (error) {
                        showError('Error parsing file: ' + error.message);
                        return;
                    }
                }
                
                if (questions.length === 0) {
                    alert('No valid questions found');
                    return;
                }
                
                // Disable button and show progress
                saveBtn.disabled = true;
                saveBtn.textContent = 'Importing...';
                console.log(`üöÄ Starting bulk import of ${questions.length} questions at ${new Date().toISOString()}`);
                
                try {
                    const response = await fetch('/api/question-bank/bulk', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ questions })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        modal.remove();
                        showSuccess(`Successfully imported ${result.imported || questions.length} questions!`);
                        loadQuestions(); // Refresh the question list
                    } else {
                        showError('Error importing questions: ' + (result.error || 'Unknown error'));
                    }
                } catch (error) {
                    console.error('Error importing questions:', error);
                    showError('Error importing questions');
                } finally {
                    saveBtn.disabled = false;
                    saveBtn.textContent = 'Import Questions';
                    console.log(`‚úÖ Bulk import completed at ${new Date().toISOString()}`);
                }
            };
        }

        // Parse uploaded file
        async function parseFile(file) {
            const questions = [];
            const fileExtension = file.name.split('.').pop().toLowerCase();
            
            if (fileExtension === 'csv') {
                const text = await file.text();
                const lines = text.split('\n').filter(line => line.trim());
                
                // Skip header row if it exists
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    // Skip header row if it contains 'question' or 'tag'
                    if (i === 0 && (line.toLowerCase().includes('question') || line.toLowerCase().includes('tag') || line.toLowerCase().includes('category'))) {
                        continue;
                    }
                    
                    // Use proper CSV parsing that handles quoted fields
                    const parsed = parseCSVLine(line);
                    if (parsed.length >= 2) {
                        // Parse tags from second column
                        const tagsString = parsed[1].trim();
                        let tags = [];
                        if (tagsString) {
                            // Extract hashtags (words starting with #)
                            tags = tagsString.match(/#\w+/g) || [];
                            tags = tags.map(tag => tag.substring(1)); // Remove # prefix
                        }
                        
                        questions.push({
                            question: parsed[0].trim(),
                            tags: tags.length > 0 ? tags : ['general']
                        });
                    } else if (parsed.length === 1) {
                        // If only one column, treat it as question with default tag
                        questions.push({
                            question: parsed[0].trim(),
                            tags: ['general']
                        });
                    }
                }
            } else if (fileExtension === 'xlsx' || fileExtension === 'xls') {
                // For Excel files, we'll need to use a library like SheetJS
                // For now, show an error message
                throw new Error('Excel file support requires additional setup. Please use CSV format for now.');
            } else {
                throw new Error('Unsupported file format. Please use CSV, XLSX, or XLS files.');
            }
            
            return questions;
        }

        // Proper CSV line parser that handles quoted fields and commas within questions
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            let i = 0;
            
            while (i < line.length) {
                const char = line[i];
                const nextChar = line[i + 1];
                
                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        // Escaped quote (double quote)
                        current += '"';
                        i += 2;
                    } else {
                        // Toggle quote state
                        inQuotes = !inQuotes;
                        i++;
                    }
                } else if (char === ',' && !inQuotes) {
                    // Field separator (only when not inside quotes)
                    result.push(current);
                    current = '';
                    i++;
                } else {
                    current += char;
                    i++;
                }
            }
            
            // Add the last field
            result.push(current);
            
            return result;
        }

        // Edit functionality
        let selectedRows = new Set();
        let currentEditRow = null;
        let currentEditData = null;

        function toggleRowSelection(rowId) {
            if (selectedRows.has(rowId)) {
                selectedRows.delete(rowId);
            } else {
                selectedRows.add(rowId);
            }
            updateBulkEditControls();
        }

        function selectAllRows() {
            const checkboxes = document.querySelectorAll('.row-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
                selectedRows.add(checkbox.dataset.rowId);
            });
            updateBulkEditControls();
        }

        function clearSelection() {
            selectedRows.clear();
            const checkboxes = document.querySelectorAll('.row-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            updateBulkEditControls();
        }

        function updateBulkEditControls() {
            const controls = document.querySelector('.bulk-edit-controls');
            const count = document.getElementById('bulk-edit-selected-count');
            
            if (selectedRows.size > 0) {
                controls.classList.add('active');
                count.textContent = `${selectedRows.size} records selected`;
            } else {
                controls.classList.remove('active');
            }
        }

        function openBulkEditModal() {
            if (selectedRows.size === 0) {
                showError('Please select records to edit');
                return;
            }
            
            const modal = document.getElementById('bulk-edit-modal');
            const fieldSelect = document.getElementById('bulk-edit-field');
            
            // Populate field options based on current tab
            fieldSelect.innerHTML = '<option value="">Select field...</option>';
            
            const currentTab = document.querySelector('.nav-link.active').textContent.trim();
            let fields = [];
            
            if (currentTab.includes('My Interviews')) {
                fields = [
                    { value: 'verdict', text: 'Verdict' },
                    { value: 'status', text: 'Status' },
                    { value: 'overall_notes', text: 'Notes' }
                ];
            } else if (currentTab.includes('Question Analysis')) {
                fields = [
                    { value: 'question', text: 'Question Text' },
                    { value: 'category', text: 'Category' }
                ];
            }
            
            fields.forEach(field => {
                const option = document.createElement('option');
                option.value = field.value;
                option.textContent = field.text;
                fieldSelect.appendChild(option);
            });
            
            modal.classList.add('active');
        }

        function closeBulkEditModal() {
            const modal = document.getElementById('bulk-edit-modal');
            if (modal) {
                modal.classList.remove('active');
            }
            const valueInput = document.getElementById('bulk-edit-value');
            if (valueInput) {
                valueInput.value = '';
            }
            const valueGroup = document.getElementById('bulk-edit-value-group');
            if (valueGroup) {
                valueGroup.style.display = 'none';
            }
        }

        function updateBulkEditFields() {
            const fieldSelect = document.getElementById('bulk-edit-field');
            const valueGroup = document.getElementById('bulk-edit-value-group');
            
            if (fieldSelect.value) {
                valueGroup.style.display = 'block';
            } else {
                valueGroup.style.display = 'none';
            }
        }

        async function applyBulkEdit() {
            const field = document.getElementById('bulk-edit-field').value;
            const value = document.getElementById('bulk-edit-value').value;
            
            if (!field || !value) {
                showError('Please select a field and enter a value');
                return;
            }
            
            try {
                // Map display field names to actual database field names
                const fieldMapping = {
                    'verdict': 'verdict',
                    'status': 'status',
                    'overall_notes': 'overall_notes',
                    'question': 'question',
                    'category': 'category'
                };
                
                const dbField = fieldMapping[field] || field;
                const updates = Array.from(selectedRows).map(rowId => ({
                    id: parseInt(rowId), // Ensure ID is an integer
                    data: { [dbField]: value }
                }));
                
                const currentTab = document.querySelector('.nav-link.active').textContent.trim();
                let endpoint = '';
                
                if (currentTab.includes('My Interviews')) {
                    endpoint = '/api/interviews/bulk';
                } else if (currentTab.includes('Question Analysis')) {
                    endpoint = '/api/question-bank/bulk';
                }
                
                console.log('Bulk edit request:', { endpoint, updates });
                
                const response = await fetch(endpoint, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ updates })
                });
                
                const result = await response.json();
                console.log('Bulk edit response:', result);
                
                if (result.success) {
                    showSuccess(`Successfully updated ${updates.length} records`);
                    closeBulkEditModal();
                    clearSelection();
                    // Refresh current tab data
                    const activeTab = document.querySelector('.nav-link.active');
                    if (activeTab) {
                        activeTab.click();
                    }
                } else {
                    showError('Error updating records: ' + result.error);
                }
            } catch (error) {
                console.error('Error applying bulk edit:', error);
                showError('Error applying bulk edit');
            }
        }

        function startEdit(rowId, data) {
            if (currentEditRow) {
                cancelEdit();
            }
            
            currentEditRow = rowId;
            currentEditData = { ...data };
            
            const row = document.querySelector(`[data-row-id="${rowId}"]`);
            row.classList.add('editing');
            
            // Replace content with edit form
            const cells = row.querySelectorAll('td:not(:last-child)');
            cells.forEach((cell, index) => {
                const field = cell.dataset.field;
                if (field && field !== 'id' && field !== 'interview_count' && field !== 'times_asked') {
                    const currentValue = cell.textContent.trim();
                    cell.innerHTML = `<input type="text" class="edit-input" value="${currentValue}" data-field="${field}">`;
                }
            });
            
            // Replace action buttons
            const actionCell = row.querySelector('td:last-child');
            actionCell.innerHTML = `
                <button class="icon-btn save-btn" onclick="saveEdit('${rowId}')" title="Save">‚úì</button>
                <button class="icon-btn cancel-btn" onclick="cancelEdit()" title="Cancel">‚úó</button>
            `;
        }

        function cancelEdit() {
            if (!currentEditRow) return;
            
            const row = document.querySelector(`[data-row-id="${currentEditRow}"]`);
            row.classList.remove('editing');
            
            // Restore original content by reloading the current tab
            const activeTab = document.querySelector('.nav-link.active');
            if (activeTab) {
                activeTab.click();
            }
            
            currentEditRow = null;
            currentEditData = null;
        }

        async function saveEdit(rowId) {
            try {
                const row = document.querySelector(`[data-row-id="${rowId}"]`);
                const inputs = row.querySelectorAll('.edit-input');
                const updateData = {};
                
                inputs.forEach(input => {
                    updateData[input.dataset.field] = input.value;
                });
                
                const currentTab = document.querySelector('.nav-link.active').textContent.trim();
                let endpoint = '';
                
                if (currentTab.includes('My Interviews')) {
                    endpoint = `/api/interviews/${rowId}`;
                } else if (currentTab.includes('Question Analysis')) {
                    endpoint = `/api/question-bank/${rowId}`;
                }
                
                const response = await fetch(endpoint, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updateData)
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showSuccess('Record updated successfully');
                    currentEditRow = null;
                    currentEditData = null;
                    // Refresh current tab data
                    const activeTab = document.querySelector('.nav-link.active');
                    if (activeTab) {
                        activeTab.click();
                    }
                } else {
                    showError('Error updating record: ' + result.error);
                }
            } catch (error) {
                console.error('Error saving edit:', error);
                showError('Error saving edit');
            }
        }

        function deleteRecord(rowId, type) {
            if (!confirm(`Are you sure you want to delete this ${type}?`)) {
                return;
            }
            
            // Implementation depends on the specific delete functionality
            // This would call the appropriate delete API endpoint
            console.log(`Delete ${type} with ID: ${rowId}`);
        }

        // Edit question text in interview details
        async function editQuestionText(questionId, currentText) {
            const questionElement = document.getElementById(`question-${questionId}`);
            const questionDisplay = questionElement.querySelector('.question-text-display');
            const editButton = questionElement.querySelector('.question-header .edit-btn');
            
            // Check if content contains HTML (like images)
            const hasHTML = /<[^>]*>/g.test(currentText);
            
            let input;
            if (hasHTML) {
                // Create rich text editor for HTML content
                const editorContainer = document.createElement('div');
                editorContainer.className = 'rich-text-editor-container';
                editorContainer.innerHTML = '<div id="question-editor-' + questionId + '"></div>';
                
                input = editorContainer;
                
                // Initialize Quill editor after adding to DOM
                setTimeout(() => {
                    const quill = new Quill('#question-editor-' + questionId, {
                        theme: 'snow',
                        modules: {
                            toolbar: [
                                ['bold', 'italic', 'underline'],
                                ['link', 'image'],
                                [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                                ['clean']
                            ]
                        }
                    });
                    
                    // Set content
                    quill.root.innerHTML = currentText;
                    
                    // Store quill instance for saving
                    editorContainer.quillInstance = quill;
                }, 100);
            } else {
                // Create textarea for plain text
                input = document.createElement('textarea');
                input.className = 'question-edit-input';
                input.value = currentText;
                input.rows = 3;
            }
            
            // Create action buttons
            const actions = document.createElement('div');
            actions.className = 'edit-actions';
            actions.innerHTML = `
                <button class="btn btn-success" onclick="saveQuestionText(${questionId})">Save</button>
                <button class="btn btn-secondary" onclick="cancelQuestionTextEdit(${questionId}, '${currentText.replace(/'/g, "\\'").replace(/\n/g, '\\n').replace(/\r/g, '\\r')}')">Cancel</button>
            `;
            
            // Replace display with input
            questionDisplay.style.display = 'none';
            editButton.style.display = 'none';
            questionDisplay.parentNode.insertBefore(input, questionDisplay);
            questionDisplay.parentNode.insertBefore(actions, questionDisplay);
            
            // Focus and select text
            input.focus();
            input.select();
        }
        
        // Save question text
        async function saveQuestionText(questionId) {
            const questionElement = document.getElementById(`question-${questionId}`);
            
            // Check if it's a rich text editor or textarea
            const richEditor = questionElement.querySelector('.rich-text-editor-container');
            const textarea = questionElement.querySelector('.question-edit-input');
            
            let newText;
            if (richEditor && richEditor.quillInstance) {
                // Get content from Quill editor
                newText = richEditor.quillInstance.root.innerHTML.trim();
            } else if (textarea) {
                // Get content from textarea
                newText = textarea.value.trim();
            } else {
                showError('No input found');
                return;
            }
            
            if (!newText) {
                showError('Question text cannot be empty');
                return;
            }
            
            try {
                const response = await fetch(`/api/interview-questions/${questionId}/text`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        question_text: newText
                    })
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    // Update display
                    const questionDisplay = questionElement.querySelector('.question-text-display');
                    
                    // Check if content is HTML and update accordingly
                    if (/<[^>]*>/g.test(newText)) {
                        // Rich content - use innerHTML and wrap in div
                        questionDisplay.outerHTML = `<div class="question-text-display rich-content-wrapper">${newText}</div>`;
                    } else {
                        // Plain text - use textContent
                        questionDisplay.textContent = newText;
                        questionDisplay.style.display = 'inline';
                    }
                    
                    // Show edit button
                    const editButton = questionElement.querySelector('.question-header .edit-btn');
                    editButton.style.display = 'inline-block';
                    
                    // Remove input and actions (handle both textarea and rich editor)
                    const richEditor = questionElement.querySelector('.rich-text-editor-container');
                    const textarea = questionElement.querySelector('.question-edit-input');
                    if (richEditor) richEditor.remove();
                    if (textarea) textarea.remove();
                    questionElement.querySelector('.edit-actions').remove();
                    
                    showSuccess('Question updated successfully');
                } else {
                    showError(result.error || 'Error updating question');
                }
            } catch (error) {
                console.error('Error updating question:', error);
                showError('Error updating question');
            }
        }
        
        // Cancel question text edit
        function cancelQuestionTextEdit(questionId, originalText) {
            const questionElement = document.getElementById(`question-${questionId}`);
            const questionDisplay = questionElement.querySelector('.question-text-display');
            const editButton = questionElement.querySelector('.question-header .edit-btn');
            
            // Restore display
            questionDisplay.style.display = 'inline';
            editButton.style.display = 'inline-block';
            
            // Remove input and actions (handle both textarea and rich editor)
            const richEditor = questionElement.querySelector('.rich-text-editor-container');
            const textarea = questionElement.querySelector('.question-edit-input');
            if (richEditor) richEditor.remove();
            if (textarea) textarea.remove();
            const editActions = questionElement.querySelector('.edit-actions');
            if (editActions) editActions.remove();
        }
        
        // Edit question answer in interview details
        async function editQuestionAnswer(questionId, currentAnswer, answerPhotoUrl) {
            console.log('üìù Editing answer with photo URL:', answerPhotoUrl);
            const questionElement = document.getElementById(`question-${questionId}`);
            const answerDisplay = questionElement.querySelector('.answer-text-display');
            const editButton = questionElement.querySelector('.answer-section .edit-btn');
            
            // Create input field
            const input = document.createElement('textarea');
            input.className = 'answer-edit-input';
            input.value = currentAnswer;
            input.rows = 3;
            // Store the photo URL as a data attribute to preserve it
            input.setAttribute('data-answer-photo-url', answerPhotoUrl || '');
            console.log('üìù Stored photo URL in textarea:', input.getAttribute('data-answer-photo-url'));
            
            // Create action buttons
            const actions = document.createElement('div');
            actions.className = 'edit-actions';
            actions.innerHTML = `
                <button class="btn btn-success" onclick="saveQuestionAnswer(${questionId})">Save</button>
                <button class="btn btn-secondary" onclick="cancelQuestionAnswerEdit(${questionId}, '${currentAnswer.replace(/'/g, "\\'").replace(/\n/g, '\\n').replace(/\r/g, '\\r')}')">Cancel</button>
            `;
            
            // Replace display with input
            answerDisplay.style.display = 'none';
            editButton.style.display = 'none';
            answerDisplay.parentNode.insertBefore(input, answerDisplay);
            answerDisplay.parentNode.insertBefore(actions, answerDisplay);
            
            // Focus and select text
            input.focus();
            input.select();
        }
        
        // Save question answer
        async function saveQuestionAnswer(questionId) {
            const questionElement = document.getElementById(`question-${questionId}`);
            const input = questionElement.querySelector('.answer-edit-input');
            const newAnswer = input.value.trim();
            // Get the preserved photo URL from the input's data attribute
            let answerPhotoUrl = input.getAttribute('data-answer-photo-url') || null;
            
            // If answerPhotoUrl is a non-empty string, keep it as is (it could be JSON string or plain string)
            // The backend will handle parsing if needed
            console.log('üíæ Saving answer with photo URL:', answerPhotoUrl);
            
            try {
                const response = await fetch(`/api/interview-questions/${questionId}/answer`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        student_answer: newAnswer,
                        answer_photo_url: answerPhotoUrl // Include the photo URL to preserve it
                    })
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    // Update display
                    const answerDisplay = questionElement.querySelector('.answer-text-display');
                    answerDisplay.textContent = newAnswer || 'No answer provided';
                    answerDisplay.style.display = 'inline';
                    
                    // Show edit button and update its data attribute with the photo URL
                    const editButton = questionElement.querySelector('.answer-section .edit-btn');
                    editButton.setAttribute('data-answer-photo-url', answerPhotoUrl || '');
                    editButton.style.display = 'inline-block';
                    
                    // Remove input and actions
                    input.remove();
                    questionElement.querySelector('.edit-actions').remove();
                    
                    showSuccess('Answer updated successfully');
                } else {
                    showError(result.error || 'Error updating answer');
                }
            } catch (error) {
                console.error('Error updating answer:', error);
                showError('Error updating answer');
            }
        }
        
        // Cancel question answer edit
        function cancelQuestionAnswerEdit(questionId, originalAnswer) {
            const questionElement = document.getElementById(`question-${questionId}`);
            const answerDisplay = questionElement.querySelector('.answer-text-display');
            const editButton = questionElement.querySelector('.answer-section .edit-btn');
            
            // Restore display
            answerDisplay.style.display = 'inline';
            editButton.style.display = 'inline-block';
            
            // Remove input and actions
            questionElement.querySelector('.answer-edit-input').remove();
            questionElement.querySelector('.edit-actions').remove();
        }
        
        // Show success message (replace alert with modal)
        function showSuccess(message) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.35);display:flex;align-items:center;justify-content:center;z-index:2000;';
            modal.innerHTML = `
                <div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;min-width:280px;max-width:90%;padding:16px;box-shadow:0 10px 20px rgba(0,0,0,0.15)">
                    <div style="font-weight:600;margin-bottom:8px;color:#059669">Success</div>
                    <div style="font-size:14px;color:#374151;margin-bottom:12px">${message}</div>
                    <div style="display:flex;gap:8px;justify-content:flex-end">
                        <button id="success-ok-btn" style="background:#059669;color:#fff;border:none;padding:6px 10px;border-radius:6px;cursor:pointer">OK</button>
                    </div>
                </div>`;
            document.body.appendChild(modal);
            
            // Add event listener for OK button
            modal.querySelector('#success-ok-btn').onclick = () => {
                modal.remove();
            };
        }
    </script>

    <!-- Bulk Edit Modal -->
    <div id="bulk-edit-modal" class="bulk-edit-modal" onclick="closeBulkEditModal()">
        <div class="bulk-edit-content" onclick="event.stopPropagation()">
            <div class="bulk-edit-header">
                <h3 class="bulk-edit-title">Bulk Edit Records</h3>
                <button class="close-modal" onclick="closeBulkEditModal()">&times;</button>
            </div>
            <form id="bulk-edit-form" class="bulk-edit-form">
                <div class="form-group">
                    <label class="form-label">Field to Update:</label>
                    <select id="bulk-edit-field" class="form-select" onchange="updateBulkEditFields()">
                        <option value="">Select field...</option>
                    </select>
                </div>
                <div id="bulk-edit-value-group" class="form-group" style="display: none;">
                    <label class="form-label">New Value:</label>
                    <input type="text" id="bulk-edit-value" class="form-input" placeholder="Enter new value...">
                </div>
                <div class="form-group">
                    <label class="form-label">Selected Records:</label>
                    <div id="bulk-edit-selected-count" class="bulk-edit-info">0 records selected</div>
                </div>
            </form>
            <div class="bulk-edit-footer">
                <button class="btn btn-secondary" onclick="closeBulkEditModal()">Cancel</button>
                <button class="btn btn-primary" onclick="applyBulkEdit()">Apply Changes</button>
            </div>
        </div>
    </div>
    <script src="/shared-auth.js"></script>
    <script>
      (function(){
        try {
          const data = localStorage.getItem('bees_user_data');
          if (data){
            const user = JSON.parse(data);
            if (user && user.email){
              document.cookie = `user_email=${encodeURIComponent(user.email)}; path=/; max-age=2592000`;
            }
          }
        } catch(e){}
      })();
    </script>
</body>
</html>