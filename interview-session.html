<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interview Session - Bees Platform</title>
    <link rel="icon" type="image/png" href="/logo3.png">
    
    <!-- Quill Rich Text Editor -->
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>
    
    <!-- Marked.js for Markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* Page Loader */
        #page-loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #ffffff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.3s ease-out, visibility 0.3s ease-out;
        }
        
        #page-loader.hidden {
            opacity: 0;
            visibility: hidden;
        }
        
        .loader-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid #e5e7eb;
            border-top: 4px solid #2563eb;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        .loader-text {
            margin-top: 20px;
            font-size: 16px;
            color: #6b7280;
            font-weight: 500;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @font-face {
            font-family: 'Zoho Puvi';
            src: url('/Zoho Puvi/OpenType-TT/Zoho Puvi Regular.ttf') format('truetype');
            font-weight: 400;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'Zoho Puvi';
            src: url('/Zoho Puvi/OpenType-TT/Zoho Puvi Medium.ttf') format('truetype');
            font-weight: 500;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'Zoho Puvi';
            src: url('/Zoho Puvi/OpenType-TT/Zoho Puvi Semibold.ttf') format('truetype');
            font-weight: 600;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'Zoho Puvi';
            src: url('/Zoho Puvi/OpenType-TT/Zoho Puvi Bold.ttf') format('truetype');
            font-weight: 700;
            font-style: normal;
            font-display: swap;
        }
        body {
            font-family: 'Zoho Puvi', -apple-system, BlinkMacSystemFont, 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f8fafc;
            min-height: 100vh;
            color: #4a5568;
        }
        
        .header {
            background: #1E1E1E;
            padding: 0.5rem 2rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 100;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header-actions {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }
        
        .interview-clock {
            background: transparent;
            color: #1f2937;
            padding: 0.25rem 0.5rem;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-weight: 600;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .clock-icon { font-size: 1rem; opacity: 0.75; }

        .timer-wrapper {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0.25rem 2rem 0.5rem;
            display: flex;
            justify-content: flex-end;
        }

        .interview-action-buttons {
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
            margin-top: 0.5rem;
        }
        
        .verdict-section.hidden {
            display: none;
        }
        
        .user-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .avatar {
            width: 36px;
            height: 36px;
            background: #2d3748;
            color: #ffffff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            cursor: pointer;
            user-select: none;
        }

        .avatar-menu {
            position: absolute;
            right: 16px;
            top: 56px;
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            display: none;
            min-width: 140px;
            z-index: 150;
        }

        .avatar-menu.active { display: block; }

        .avatar-menu button {
            width: 100%;
            background: #ffffff;
            border: none;
            text-align: left;
            padding: 10px 12px;
            cursor: pointer;
        }

        .avatar-menu button:hover { background: #f3f4f6; }
        
        .user-name {
            font-weight: 600;
            color: #2d3748;
            background: #f7fafc;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            border: 1px solid #e2e8f0;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .user-name:hover {
            background: #edf2f7;
            border-color: #cbd5e0;
        }
        
        .login-btn {
            background: #4299e1;
            color: white;
            border: none;
            padding: 0.9rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .login-btn:hover {
            background: #3182ce;
        }
        
        .header-actions .btn {
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
        }
        
        .logo {
            font-size: 2rem;
            font-weight: bold;
            color: #2d3748;
            text-decoration: none;
            display: flex;
            align-items: center;
        }
        
        .logo img {
            filter: none;
        }
        
        .back-btn {
            background: #2d3748;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s ease;
        }
        
        .back-btn:hover {
            background: #1a202c;
        }
        
        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0.75rem;
            display: grid;
            grid-template-columns: 3fr 1fr;
            gap: 0.75rem;
            height: calc(100vh - 70px);
            overflow: hidden; /* Prevent main container from scrolling */
        }
        
        .interview-main {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden; /* Prevent main section from scrolling */
        }
        
        .student-info-card {
            background: #f7fafc;
            border-radius: 6px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            border: 1px solid #e2e8f0;
            position: relative;
        }
        
        .student-info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.25rem;
        }

        .header-right-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .interview-controls-header {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .interview-controls-header .btn {
            padding: 0.9rem 0.75rem;
            font-size: 0.8rem;
            min-width: 100px;
            border-radius: 4px;
        }
        
        .student-info-title {
            font-size: 1rem;
            color: #2d3748;
            margin: 0;
        }
        
        .interview-timer-card {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            background: white;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            border: 2px solid #3b82f6;
            box-shadow: 0 1px 2px rgba(59, 130, 246, 0.1);
        }
        
        .interview-timer-card .clock-icon {
            font-size: 1.25rem;
        }
        
        .interview-timer-card #duration-display {
            font-size: 1.1rem;
            font-weight: 700;
            color: #1e40af;
            font-variant-numeric: tabular-nums;
            letter-spacing: 0.25px;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 0.5rem;
        }
        
        .info-item {
            background: white;
            padding: 0.5rem;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border: 1px solid #e2e8f0;
        }
        
        .info-label {
            font-weight: 600;
            color: #2d3748;
            font-size: 0.8rem;
            margin-bottom: 0.25rem;
        }
        
        .info-value {
            color: #4a5568;
            font-size: 0.9rem;
        }
        
        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }
        
        .chat-messages {
            flex: 2;
            overflow-y: auto;
            padding: 1rem;
            background: #f8f9fa;
            min-height: 0;
        }
        
        .question-item {
            margin-bottom: 0.75rem;
            background: white;
            border-radius: 6px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            overflow: hidden;
            border: 1px solid #e2e8f0;
            transition: all 0.3s ease;
        }
        
        .question-item.expanded {
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .question-header {
            background: #f8fafc;
            color: #2d3748;
            padding: 0.75rem;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            border-bottom: 1px solid #e2e8f0;
            transition: background 0.2s ease;
        }
        
        .question-header:hover {
            background: #edf2f7;
        }
        
        .question-header.expanded {
            background: #2563eb;
            color: white;
        }
        
        .question-number {
            font-size: 0.9rem;
            color: #6b7280;
            margin-right: 0.5rem;
        }
        
        .question-header.expanded .question-number {
            color: rgba(255, 255, 255, 0.8);
        }
        
        .question-preview {
            flex: 1;
            font-size: 1rem;
            line-height: 1.4;
            margin: 0 1rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .question-header.expanded .question-preview {
            display: none;
        }
        
        .question-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            min-width: 400px;
            justify-content: flex-end;
        }

        .correctness-slider-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.25rem 0.5rem;
            background: #f3f4f6;
            border-radius: 8px;
        }

        .slider-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: #4b5563;
            white-space: nowrap;
            min-width: 65px;
            cursor: default;
        }

        .slider-label span {
            color: #1f2937;
            font-weight: 700;
        }

        .correctness-slider {
            width: 100px;
            height: 6px;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, #ef4444 0%, #f59e0b 50%, #10b981 100%);
            cursor: pointer;
        }

        .correctness-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #1f2937;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }

        .correctness-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #1f2937;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }

        .correctness-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            background: #3b82f6;
        }

        .correctness-slider::-moz-range-thumb:hover {
            transform: scale(1.2);
            background: #3b82f6;
        }

        .correctness-slider.scored {
            opacity: 1;
        }

        .correctness-slider:not(.scored) {
            opacity: 0.6;
            color: white;
        }
        
        .expand-icon {
            font-size: 1.2rem;
            transition: transform 0.3s ease;
        }
        
        .question-header.expanded .expand-icon {
            transform: rotate(180deg);
        }
        
        .question-content {
            display: none;
            padding: 0;
        }
        
        .question-content.expanded {
            display: block;
        }
        
        .question-text-section {
            position: relative;
            padding: 0.75rem;
            background: #f7fafc;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .question-text-display {
            font-size: 1rem;
            line-height: 1.5;
            color: #1f2937;
            padding: 1rem;
            padding-left: 1.5rem;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .question-text {
            font-size: 1rem;
            line-height: 1.5;
            color: #1f2937;
            padding: 0.75rem;
            background: #f7fafc;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .edit-question-btn {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        
        .edit-question-btn:hover {
            opacity: 1;
        }
        
        /* Fixed images in question display */
        .question-text img {
            width: 200px;
            height: 200px;
            display: block;
            margin: 10px 0;
            object-fit: cover;
        }
        
        .answer-section {
            padding: 1rem;
            background: white;
        }
        
        .answer-label {
            font-weight: 600;
            color: #374151;
            margin-bottom: 0.5rem;
            display: block;
        }
        
        .message-header {
            font-weight: 600;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }
        
        .message-text {
            margin-bottom: 0.5rem;
        }
        
        .image-preview {
            position: relative;
            display: inline-block;
            margin-top: 0.5rem;
        }
        
        .message-image {
            max-width: 200px;
            border-radius: 8px;
            cursor: pointer;
            display: block;
        }
        
        .delete-image-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(255, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .delete-image-btn:hover {
            background: rgba(255, 0, 0, 1);
        }
        
        .add-question-form {
            background: #f7fafc;
            padding: 0.75rem;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
            position: sticky;
            bottom: 0;
        }

        .question-actions {
            display: flex;
            gap: 0.75rem;
            padding: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .action-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: #2563eb;
            color: white;
            border: 1px solid #2563eb;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Zoho Puvi', sans-serif;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .action-btn:hover {
            background: #1d4ed8;
            border-color: #1d4ed8;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }

        .action-btn.custom-question-btn:hover {
            border-color: #10b981;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.15);
        }

        .action-btn.ai-question-btn:hover {
            border-color: #8b5cf6;
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.15);
        }

        
        .interview-controls {
            display: flex;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: #f1f5f9;
            border-top: 1px solid #e2e8f0;
            justify-content: center;
            flex-wrap: wrap;
        }

        .interview-controls .btn {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
        }

        .top-section {
            display: flex;
            gap: 1rem;
            margin-bottom: 0.5rem;
            align-items: flex-start;
        }

        .top-section .student-info-card {
            flex: 1;
            margin-bottom: 0;
        }

        /* Side Panel Styles */
        .side-panel {
            position: fixed;
            top: 0;
            right: -500px;
            width: 500px;
            height: 100vh;
            background: white;
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            transition: right 0.3s ease;
            overflow-y: auto;
            border-left: 1px solid #e2e8f0;
        }

        .side-panel.active {
            right: 0;
        }

        .side-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #e2e8f0;
            background: #f8f9fa;
        }

        .side-panel-header h3 {
            margin: 0;
            font-size: 1.25rem;
            color: #1f2937;
            font-weight: 600;
        }

        .close-panel-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #6b7280;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .close-panel-btn:hover {
            background: #f3f4f6;
            color: #374151;
        }

        .side-panel-content {
            padding: 1.5rem;
        }

        .side-panel-content .form-group {
            margin-bottom: 1.5rem;
        }

        .side-panel-content .editor-wrapper {
            height: 400px;
            overflow: auto;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            background: white;
            display: flex;
            flex-direction: column;
        }

        .side-panel-content .editor-wrapper .ql-toolbar {
            border: none;
            border-bottom: 1px solid #d1d5db;
            flex-shrink: 0;
        }

        .side-panel-content .editor-wrapper .ql-container {
            flex: 1;
            border: none;
            display: flex;
            flex-direction: column;
        }

        .side-panel-content .editor-wrapper .ql-editor {
            flex: 1;
            padding: 12px 15px;
            overflow-y: auto;
            max-height: none;
            min-height: 0;
        }

        .panel-actions {
            display: flex;
            gap: 0.75rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        .panel-actions .btn {
            flex: 1;
            min-width: 120px;
        }

        .form-help {
            display: block;
            margin-top: 0.25rem;
            font-size: 0.875rem;
            color: #6b7280;
        }

        /* Panel Overlay */
        .panel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .panel-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Ensure all ql-editor instances have overflow scroll */
        .ql-editor {
            overflow-y: auto !important;
        }

        .form-label-with-action {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .form-group {
            margin-bottom: 0.5rem;
        }
        
        .form-label {
            display: block;
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 0.25rem;
            font-size: 0.9rem;
        }
        
        .form-textarea {
            width: 100%;
            min-height: 60px;
            padding: 0.5rem;
            border: 2px solid #e9ecef;
            border-radius: 5px;
            font-size: 0.9rem;
            resize: vertical;
            transition: border-color 0.3s ease;
        }
        
        .form-textarea:focus {
            outline: none;
            border-color: #2d3748;
        }
        
        .textarea-container {
            position: relative;
            display: flex;
            align-items: flex-end;
        }
        
        /* Quill Rich Text Editor Styles */
        #question-editor-container {
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            height: 200px;
            display: flex;
            flex-direction: column;
        }
        
        #question-editor-container .ql-toolbar {
            border: none;
            border-bottom: 2px solid #e2e8f0;
            background: #f7fafc;
            border-radius: 8px 8px 0 0;
            flex-shrink: 0;
        }
        
        #question-editor-container .ql-container {
            border: none;
            font-family: 'Zoho Puvi', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            flex: 1;
            overflow-y: auto;
        }
        
        #question-editor-container .ql-editor {
            height: 100%;
            max-height: none;
            padding: 12px 15px;
            overflow-y: auto;
        }
        
        #question-editor-container .ql-editor.ql-blank::before {
            color: #a0aec0;
            font-style: normal;
        }
        
        /* Fixed image sizes in the editor - 200x200 with aspect ratio preserved */
        #question-editor-container .ql-editor img {
            width: 200px;
            height: 200px;
            display: inline-block;
            object-fit: contain;
            object-position: center;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .editor-wrapper {
            flex: 1;
            margin-right: 10px;
        }
        
        .add-to-bank-btn {
            background: #2d3748;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s ease;
            z-index: 10;
        }
        
        .add-to-bank-btn:hover {
            background: #1a202c;
            transform: scale(1.05);
        }
        
        .add-to-bank-btn:disabled {
            background: #a0aec0;
            cursor: not-allowed;
            transform: none;
        }
        
        .question-actions {
            margin-top: 0.5rem;
            display: flex;
            justify-content: flex-end;
            min-width: 400px;
        }
        
        .add-to-bank-btn-small {
            background: #2d3748;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s ease;
        }
        
        .add-to-bank-btn-small:hover {
            background: #1a202c;
            transform: scale(1.05);
        }
        
        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .modal-content {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .modal-header h3 {
            margin: 0;
            color: #2d3748;
        }
        
        .close-modal {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #718096;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .close-modal:hover {
            color: #2d3748;
        }
        
        .modal-body {
            padding: 1.5rem;
        }
        
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            padding: 1rem 1.5rem;
            border-top: 1px solid #e2e8f0;
        }
        
        .question-source-tabs {
            display: flex;
            margin-bottom: 1rem;
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid #e2e8f0;
        }
        
        .tab-btn {
            flex: 1;
            padding: 0.5rem 1rem;
            background: #f7fafc;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            border-right: 1px solid #e2e8f0;
        }
        
        .tab-btn:last-child {
            border-right: none;
        }
        
        .tab-btn.active {
            background: #2d3748;
            color: white;
        }
        
        .tab-btn:hover:not(.active) {
            background: #edf2f7;
        }
        
        .question-tab {
            display: none;
        }
        
        .question-tab.active {
            display: block;
        }
        
        
        .question-bank-filters {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        
        .question-bank-list {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .question-bank-item {
            padding: 1rem;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .question-bank-item:hover {
            background: #f3f4f6;
        }
        
        .question-bank-item.selected {
            background: #dbeafe;
            border-color: #2563eb;
        }
        
        .form-select, .form-input {
            width: 100%;
            padding: 0.5rem;
            border: 2px solid #e9ecef;
            border-radius: 5px;
            font-size: 0.9rem;
            transition: border-color 0.3s ease;
        }
        
        .form-select:focus, .form-input:focus {
            outline: none;
            border-color: #2d3748;
        }
        
        .question-bank-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 5px;
            background: white;
            transition: max-height 0.3s ease;
        }
        
        .question-bank-list.expanded {
            max-height: 500px;
        }
        
        .resize-handle {
            height: 4px;
            background: #e2e8f0;
            cursor: ns-resize;
            position: relative;
            margin: 0.5rem 0;
            border-radius: 2px;
            transition: background 0.2s ease;
        }
        
        .resize-handle:hover {
            background: #2563eb;
        }
        
        .resize-handle::before {
            content: '⋮⋮';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #9ca3af;
            font-size: 12px;
            line-height: 1;
        }
        
        .delete-question-btn {
            background: #dc2626;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            margin-left: 0.5rem;
            transition: background 0.2s ease;
        }
        
        .delete-question-btn:hover {
            background: #b91c1c;
        }

        .icn{
            width:25px;
            height:25px;
            vertical-align:middle;
            cursor: pointer;
        }
        /* Question Bank Sliding Panel */
        .question-bank-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: #ffffff;
            box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            z-index: 1000;
            transition: right 0.3s ease;
            overflow-y: auto;
            border-left: 1px solid #e2e8f0;
        }

        .question-bank-panel.open {
            right: 0;
        }

        .question-bank-panel-header {
            padding: 1rem;
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 1001;
        }

        .question-bank-panel-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #1f2937;
        }

        .question-bank-close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6b7280;
            padding: 0.25rem;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .question-bank-close-btn:hover {
            background: #e5e7eb;
            color: #374151;
        }

        .question-bank-panel-content {
            padding: 1rem;
        }

        .question-bank-panel-filters {
            margin-bottom: 1rem;
        }

        .question-bank-panel-list {
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }

        .question-bank-panel-item {
            padding: 0.75rem;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            background: #ffffff;
        }

        .question-bank-panel-item:hover {
            background: #f8fafc;
            border-color: #3b82f6;
        }

        .question-bank-panel-item.selected {
            background: #dbeafe;
            border-color: #2563eb;
        }

        .question-bank-panel-item-text {
            font-size: 0.9rem;
            line-height: 1.4;
            margin-bottom: 0.5rem;
        }

        .question-bank-panel-item-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            color: #6b7280;
        }

        .question-bank-panel-item-category {
            background: #f3f4f6;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
        }

        .question-bank-panel-item-stats {
            display: flex;
            gap: 0.5rem;
        }

        .question-bank-panel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .question-bank-panel-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .question-bank-trigger-btn {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .question-bank-trigger-btn:hover {
            background: #2563eb;
        }
        
        .question-bank-item {
            padding: 0.75rem;
            border-bottom: 1px solid #f1f5f9;
            cursor: pointer;
            transition: background 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .question-bank-item:hover {
            background: #f8fafc;
        }
        
        .question-bank-item:last-child {
            border-bottom: none;
        }
        
        .question-text {
            flex: 1;
            font-size: 0.9rem;
            color: #2d3748;
        }
        
        .question-meta {
            font-size: 0.8rem;
            color: #718096;
            margin-left: 0.5rem;
        }
        
        .question-category {
            background: #e2e8f0;
            color: #4a5568;
            padding: 0.25rem 0.5rem;
            border-radius: 3px;
            font-size: 0.75rem;
            margin-right: 0.5rem;
        }
        
        .question-times-asked {
            color: #718096;
            font-size: 0.75rem;
        }
        
        .btn {
            background: #2d3748;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s ease;
            margin: 0.25rem;
            font-size: 0.9rem;
        }
        
        .btn:hover {
            background: #1d4ed8;
        }
        
        .btn-primary {
            background: #2563eb;
        }
        
        .btn-success {
            background: #059669;
        }
        
        .btn-success:hover {
            background: #047857;
        }
        
        .btn-danger {
            background: #dc2626;
        }

        /* Use full page with small padding */
        html, body { height: 100%; }
        body { margin: 0; }
        .main-container { width: 100%; max-width: 100%; padding: 0.5rem; box-sizing: border-box; }
        .interview-main, .right-panel { box-sizing: border-box; }
        
        .btn-danger:hover {
            background: #b91c1c;
        }
        
        .btn-warning {
            background: #d97706;
        }
        
        .btn-warning:hover {
            background: #b45309;
        }
        
        .right-panel {
            background: white;
            border-radius: 8px;
            padding: 0.75rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 1px solid #e2e8f0;
            height: 100%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .panel-title {
            font-size: 1.1rem;
            color: #2d3748;
            margin-bottom: 0.75rem;
            text-align: center;
        }
        
        .score-verdict-container {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }
        
        .total-score-section {
            flex: 1;
            padding: 0.75rem;
            background: #f0f9ff;
            border-radius: 6px;
            border: 2px solid #3b82f6;
        }
        
        .total-score-title {
            font-size: 0.9rem;
            color: #1e3a8a;
            margin-bottom: 0.5rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .total-score-display {
            display: flex;
            align-items: baseline;
            gap: 0.5rem;
        }
        
        .total-score-value {
            font-size: 2rem;
            font-weight: 700;
            color: #1e40af;
        }
        
        .total-score-max {
            font-size: 1.2rem;
            color: #64748b;
            font-weight: 500;
        }
        
        .total-score-breakdown {
            font-size: 0.8rem;
            color: #475569;
            margin-top: 0.5rem;
            font-style: italic;
        }
        
        .verdict-section {
            flex: 1;
            padding: 0.75rem;
            background: #f7fafc;
            border-radius: 6px;
            border: 2px solid #3b82f6;
            font-size: 1.3rem;
        }
        
        .verdict-title {
            font-size: 1rem;
            color: #2d3748;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }
        
        .verdict-select {
            width: 100%;
            padding: 0.5rem;
            border: 2px solid #e9ecef;
            border-radius: 5px;
            font-size: 0.9rem;
            background: white;
        }
        
        .verdict-select:focus {
            outline: none;
            border-color: #2d3748;
        }
        
        .notes-section {
            margin-bottom: 1.5rem;
            width: 100%;
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
        }
        
        .notes-title {
            font-size: 1rem;
            color: #2d3748;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }
        
        .notes-textarea {
            width: 100%;
            flex: 1;
            padding: 0.5rem;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 1.3rem;
            resize: none;
            transition: border-color 0.3s ease;
        }
        
        .notes-textarea:focus {
            outline: none;
            border-color: #2d3748;
        }
        
        .previous-interviews-section {
            margin-bottom: 1.5rem;
        }
        
        .previous-interviews-title {
            font-size: 1rem;
            color: #2d3748;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }
        
        .previous-interviews-list {
            max-height: 300px;
            overflow-y: auto;
        }
        
        .previous-interview-item {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        
        .previous-interview-item:hover {
            background: #edf2f7;
        }
        
        .previous-interview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.25rem;
        }
        
        .previous-interview-date {
            font-size: 0.8rem;
            color: #6b7280;
        }
        
        .previous-interview-status {
            background: #059669;
            color: white;
            padding: 0.2rem 0.4rem;
            border-radius: 10px;
            font-size: 0.7rem;
        }
        
        .previous-interview-verdict {
            background: #2d3748;
            color: white;
            padding: 0.2rem 0.4rem;
            border-radius: 10px;
            font-size: 0.7rem;
        }

        .status-completed {
            background: #059669 !important;
        }

        .status-in-progress {
            background: #d97706 !important;
        }

        .previous-interview-details {
            margin: 0.5rem 0;
            padding: 0.5rem;
            background: #ffffff;
            border-radius: 6px;
            border: 1px solid #e5e7eb;
        }

        .interview-detail-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.25rem;
            font-size: 0.8rem;
        }

        .interview-detail-row:last-child {
            margin-bottom: 0;
        }

        .detail-label {
            font-weight: 600;
            color: #6b7280;
            min-width: 80px;
        }

        .detail-value {
            color: #374151;
            text-align: right;
            flex: 1;
            margin-left: 0.25rem;
        }
        
        .previous-interview-questions {
            font-size: 0.8rem;
            color: #4a5568;
        }
        
        .previous-interview-questions-count {
            font-weight: 600;
            color: #2d3748;
        }
        
        .no-data-container {
            text-align: center;
            padding: 1rem;
            color: #6b7280;
        }
        
        .no-data-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            opacity: 0.5;
        }
        
        .no-data-text {
            font-size: 0.9rem;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 0.25rem;
        }
        
        .no-data-subtext {
            font-size: 0.8rem;
            color: #6b7280;
        }
        
        .interview-actions {
            text-align: center;
        }
        
        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .hidden {
            display: none;
        }
        
        .loading {
            text-align: center;
            padding: 1rem;
            color: #6b7280;
        }
        
        .error {
            background: #fed7d7;
            color: #c53030;
            padding: 0.5rem;
            border-radius: 6px;
            margin: 0.5rem 0;
            border: 1px solid #feb2b2;
            font-size: 0.9rem;
        }
        
        .success {
            background: #c6f6d5;
            color: #2f855a;
            padding: 0.5rem;
            border-radius: 6px;
            margin: 0.5rem 0;
            border: 1px solid #9ae6b4;
            font-size: 0.9rem;
        }
        
        .photo-capture {
            margin: 0.5rem 0;
            display: flex;
            gap: 0.5rem;
        }
        
        .photo-btn {
            background: #059669;
            color: white;
            border: none;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.8rem;
            flex: 1;
        }

        /* Camera Modal Styles */
        .camera-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .camera-container {
            background: white;
            border-radius: 12px;
            padding: 1rem;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        .camera-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .camera-header h3 {
            margin: 0;
            color: #1e293b;
        }

        .close-camera {
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .camera-preview {
            flex: 1;
            display: flex;
            justify-content: center;
            margin-bottom: 1rem;
        }

        .camera-preview video {
            width: 100%;
            max-width: 400px;
            border-radius: 8px;
            background: #000;
        }

        .camera-controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .camera-controls .btn {
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
        }
        
        .photo-btn:hover {
            background: #047857;
        }
        
        .photo-input {
            display: none;
        }
        
        .upload-loading {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #059669;
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }
        
        .loading-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #e5e7eb;
            border-top: 2px solid #059669;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .photo-gallery {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .photo-item {
            position: relative;
            display: inline-block;
        }
        
        .photo-item img {
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: 4px;
            border: 1px solid #d1d5db;
            cursor: pointer;
        }
        
        .photo-delete {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #dc2626;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .photo-preview {
            max-width: 150px;
            max-height: 150px;
            border-radius: 6px;
            display: none;
            border: 2px solid #e2e8f0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            object-fit: cover;
            margin-top: 0.25rem;
        }
        
        .delete-photo-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #dc2626;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background 0.2s ease;
        }
        
        .delete-photo-btn:hover {
            background: #b91c1c;
        }
        
        .photo-container {
            position: relative;
            display: inline-block;
            margin-top: 0.25rem;
        }
        
        .upload-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 1000;
            font-size: 12px;
        }
        
        .loading-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #ffffff;
            border-top: 2px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @media (max-width: 1024px) {
            .main-container {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .right-panel {
                order: -1;
                max-height: 400px;
            }
        }
        
        @media (max-width: 768px) {
            .main-container {
                padding: 0.5rem;
            }
            
            .interview-main {
                padding: 0.5rem;
            }
            
            .info-grid {
                grid-template-columns: 1fr;
            }
            
            .header-actions {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .header-actions .btn {
                padding: 0.4rem 0.8rem;
                font-size: 0.8rem;
            }
        }
        
        /* Markdown content styling in Quill editor */
        .ql-editor h1 {
            font-size: 1.5rem;
            font-weight: 700;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
            color: #1a202c;
        }
        
        .ql-editor h2 {
            font-size: 1.25rem;
            font-weight: 600;
            margin-top: 0.875rem;
            margin-bottom: 0.5rem;
            color: #2d3748;
        }
        
        .ql-editor h3 {
            font-size: 1.125rem;
            font-weight: 600;
            margin-top: 0.75rem;
            margin-bottom: 0.5rem;
            color: #374151;
        }
        
        .ql-editor p {
            margin-bottom: 0.75rem;
            line-height: 1.6;
        }
        
        .ql-editor ul, .ql-editor ol {
            margin-left: 1.5rem;
            margin-bottom: 0.75rem;
        }
        
        .ql-editor li {
            margin-bottom: 0.375rem;
            line-height: 1.5;
        }
        
        .ql-editor code {
            background: #f3f4f6;
            padding: 0.125rem 0.375rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #e53e3e;
        }
        
        .ql-editor pre {
            background: #1a202c;
            color: #f7fafc;
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
            margin-bottom: 0.75rem;
        }
        
        .ql-editor pre code {
            background: transparent;
            color: #f7fafc;
            padding: 0;
        }
        
        .ql-editor blockquote {
            border-left: 4px solid #3b82f6;
            padding-left: 1rem;
            margin-left: 0;
            margin-bottom: 0.75rem;
            color: #4b5563;
            font-style: italic;
        }
        
        .ql-editor strong {
            font-weight: 600;
        }
        
        .ql-editor em {
            font-style: italic;
        }
        
        .ql-editor a {
            color: #3b82f6;
            text-decoration: underline;
        }
        
        .ql-editor table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 0.75rem;
        }
        
        .ql-editor table th,
        .ql-editor table td {
            border: 1px solid #d1d5db;
            padding: 0.5rem;
            text-align: left;
        }
        
        .ql-editor table th {
            background: #f3f4f6;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <!-- Page Loader -->
    <div id="page-loader">
        <div class="loader-spinner"></div>
        <div class="loader-text">Loading Interview Session...</div>
    </div>
    
    <header class="header">
        <div class="header-content">
            <a href="/" class="logo">
                <img src="/logo3.png" alt="BEES Logo" style="height: 45px; width: auto;">
            </a>
            
            <div class="header-actions">
                
                <div class="user-info">
                    <div id="avatar" class="avatar hidden">U</div>
                    <div id="avatar-menu" class="avatar-menu">
                        <button id="logout-btn-dropdown">Logout</button>
                    </div>
                    <button id="login-btn" class="login-btn hidden">Sign in with Zoho</button>
                </div>
                
            </div>
        </div>
    </header>

    <!-- Question Bank Sliding Panel -->
    <div class="question-bank-panel-overlay" id="question-bank-overlay" onclick="closeQuestionBankPanel()"></div>
    <div class="question-bank-panel" id="question-bank-panel">
        <div class="question-bank-panel-header">
            <div class="question-bank-panel-title">📚 Question Bank</div>
            <button class="question-bank-close-btn" onclick="closeQuestionBankPanel()">✕</button>
        </div>
        <div class="question-bank-panel-content">
            <div class="question-bank-panel-filters">
                <div class="form-group">
                    <label class="form-label">Search</label>
                    <input type="text" id="panel-search-input" class="form-input" placeholder="Search questions..." onkeyup="searchPanelQuestions()">
                </div>
                <div class="form-group">
                    <label class="form-label">Tags</label>
                    <select id="panel-category-select" class="form-select" onchange="loadPanelQuestionsByCategory()">
                        <option value="">All Tags</option>
                        <option value="Favorites">My Favorites</option>
                    </select>
                </div>
            </div>
            <div id="question-bank-panel-list" class="question-bank-panel-list">
                <div class="loading">Loading questions...</div>
            </div>
        </div>
    </div>

    <main class="main-container">
        <div class="interview-main">
            <div class="top-section">
            <div class="student-info-card">
                    <div class="student-info-header">
                <h2 class="student-info-title">Candidate Information</h2>
                        <div class="header-right-section">
                            <div class="interview-timer-card">
                                <span class="clock-icon">⏱️</span>
                                <span id="duration-display">00:00:00</span>
                            </div>
                            <!-- Interview Control Buttons -->
                            <div class="interview-controls-header">
                                <button id="save-interview-btn" class="btn btn-success" onclick="saveInterview()">Save Interview</button>
                                <button class="btn btn-danger" onclick="endInterview()">End Interview</button>
                                <button class="btn btn-warning" onclick="cancelInterview()">Cancel Interview</button>
                            </div>
                        </div>
                    </div>
                <div class="info-grid">
                    <div class="info-item">
                        <div class="info-label">Name</div>
                        <div class="info-value" id="candidate-name">Loading...</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Email</div>
                        <div class="info-value" id="candidate-email">Loading...</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Phone</div>
                        <div class="info-value" id="candidate-phone">Loading...</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Zeta ID</div>
                        <div class="info-value" id="candidate-zeta-id">Loading...</div>
                    </div>
                    </div>
                </div>
            </div>
            
            <div class="chat-container">
                <div id="chat-messages" class="chat-messages">
                    <div class="loading">Loading questions...</div>
                </div>
                
                <!-- Question Action Buttons -->
                <div class="question-actions">
                    <button class="action-btn custom-question-btn" onclick="openCustomQuestionPanel()">
                        Add Custom Question
                </button>
                    <button class="action-btn question-bank-btn" onclick="openQuestionBankPanel()">
                        Add from Question Bank
                    </button>
                    <button class="action-btn ai-question-btn" onclick="openAIQuestionPanel()">
                        Generate Question from AI
                </button>
                </div>
                
                <div class="add-question-form" style="display: none;">
                    <!-- Custom Question Tab -->
                    <div id="custom-question-tab" class="question-tab active">
                        <div class="form-group">
                            <label class="form-label" for="question-editor-container">Add New Question</label>
                            <div style="position: relative;">
                                <div class="editor-wrapper">
                                    <div id="question-editor-container"></div>
                                </div>
                                <button class="add-to-bank-btn" onclick="addToQuestionBank()" title="Add to Question Bank" style="position:absolute;top:0.5rem;right:0.5rem;z-index:100">📚</button>
                            </div>
                        </div>
                        <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:1rem">
                            <div style="display:flex;gap:0.5rem;align-items:center">
                                <button id="add-question-btn" class="btn btn-primary" onclick="addQuestion()">Add Question</button>
                                <button class="question-bank-trigger-btn" onclick="openQuestionBankPanel()">📚 Ask from Question bank</button>
                            </div>
                            <div style="display:flex;gap:0.5rem;align-items:center">
                                <button id="save-interview-btn" class="btn btn-success" onclick="saveInterview()">Save Interview</button>
                                <button class="btn btn-danger" onclick="endInterview()">End Interview</button>
                                <button class="btn btn-warning" onclick="cancelInterview()">Cancel Interview</button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Question Bank Tab -->
                    <div id="question-bank-tab" class="question-tab">
                        <div class="question-bank-filters">
                            <div class="form-group">
                                <label class="form-label">Category</label>
                                <select id="bank-category-select" class="form-select" onchange="loadQuestionsByCategory()">
                                    <option value="">All Categories</option>
                                    <option value="Favorites">My Favorites</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Search</label>
                                <input type="text" id="bank-search-input" class="form-input" placeholder="Search questions..." onkeyup="searchQuestions()">
                            </div>
                        </div>
                        <div class="resize-handle" onmousedown="startResize(event)"></div>
                        <div id="question-bank-list" class="question-bank-list">
                            <div class="loading">Loading questions...</div>
                        </div>
                    </div>

                </div>
            </div>
        </div>
        
        <div class="right-panel">
            <h3 class="panel-title">Interview Management</h3>
            
            <div class="score-verdict-container">
                <div class="total-score-section" id="total-score-section">
                    <h4 class="total-score-title">Total Score</h4>
                    <div class="total-score-display">
                        <span class="total-score-value" id="total-score-value">0</span>
                        <span class="total-score-max">/ <span id="max-score-value">0</span></span>
                    </div>
                    <div class="total-score-breakdown" id="score-breakdown">
                        0 questions scored
                    </div>
                </div>
                
                <div class="verdict-section" id="verdict-section">
                    <h4 class="verdict-title">Interview Verdict</h4>
                    <select id="verdict-select" class="verdict-select" onchange="updateVerdict()" required>
                        <option value="">Select Verdict *</option>
                        <option value="Tiger">Tiger</option>
                        <option value="Cow">Cow</option>
                        <option value="Sheep">Sheep</option>
                    </select>
                </div>
            </div>
            
            <div class="notes-section">
                <h4 class="notes-title">Interview Notes</h4>
                <textarea 
                    id="interview-notes" 
                    class="notes-textarea" 
                    placeholder="Add your overall interview notes here..."
                ></textarea>
                <button id="save-notes-btn" class="btn btn-primary" onclick="saveNotes()">
                    Save Notes
                </button>
            </div>
            
            <div class="previous-interviews-section">
                <h4 class="previous-interviews-title">Previous Interviews</h4>
                <div id="previous-interviews-list" class="previous-interviews-list">
                    <div class="loading">Loading previous interviews...</div>
            </div>
            </div>
            
        </div>
    </main>

    <script>
        let currentInterview = null;
        let currentStudent = null;
        let questions = []; // Session-specific questions for the current interview
        let previousInterviews = [];
        let interviewStartTime = null;
        let durationInterval = null;
        let userRole = 'interviewer'; // Default role
        let questionEditor = null; // Quill editor instance

        // Hide page loader
        function hidePageLoader() {
            const loader = document.getElementById('page-loader');
            if (loader) {
                loader.classList.add('hidden');
                // Remove from DOM after animation completes
                setTimeout(() => {
                    loader.style.display = 'none';
                }, 300);
            }
        }

        // Helper function to get current interviewer ID
        async function getCurrentInterviewerId() {
            let interviewerId = null;
            
            // Try to get from URL parameters first (from OAuth callback)
            const urlParams = new URLSearchParams(window.location.search);
            const userEmail = urlParams.get('email');
            
            if (userEmail) {
                // Get user ID from API
                try {
                    const response = await fetch(`/api/user/id?email=${encodeURIComponent(userEmail)}`);
                    const result = await response.json();
                    if (result.success) {
                        interviewerId = result.userId;
                        console.log('✅ Got interviewer ID from API:', interviewerId);
                    }
                } catch (error) {
                    console.error('Error getting user ID from API:', error);
                }
            }
            
            // Fallback: try to get from localStorage
            if (!interviewerId) {
                const storedUserData = localStorage.getItem('bees_user_data');
                if (storedUserData) {
                    try {
                        const userData = JSON.parse(storedUserData);
                        if (userData.email) {
                            const response = await fetch(`/api/user/id?email=${encodeURIComponent(userData.email)}`);
                            const result = await response.json();
                            if (result.success) {
                                interviewerId = result.userId;
                                console.log('✅ Got interviewer ID from localStorage:', interviewerId);
                            }
                        }
                    } catch (error) {
                        console.error('Error getting user ID from localStorage:', error);
                    }
                }
            }
            
            return interviewerId;
        }

        // Load student data and initialize interview
        async function loadStudentData() {
            try {
                console.log('loadStudentData called');
                
                // Reset questions array for this session to prevent cross-session contamination
                questions = [];
                
                // First try to get from sessionStorage
            const studentData = sessionStorage.getItem('currentStudent');
                console.log('sessionStorage studentData:', studentData);
                
            if (studentData) {
                    currentStudent = JSON.parse(studentData);
                    console.log('Loaded student from sessionStorage:', currentStudent);
                    console.log('currentStudent.id after parsing:', currentStudent?.id);
                    displayStudentData(currentStudent);
                    
                    // Add a small delay to ensure DOM is ready
                    setTimeout(async () => {
                        console.log('About to call initializeInterview from sessionStorage path');
                        await initializeInterview();
                    }, 100);
                    return;
                }

                // If not in sessionStorage, try to get from URL parameters
                const urlParams = new URLSearchParams(window.location.search);
                const zetaId = urlParams.get('zeta_id');
                console.log('zeta_id from URL:', zetaId);
                
                if (zetaId) {
                    await fetchStudentByZetaId(zetaId);
                } else {
                    console.error('No zeta_id found in URL');
                    showError('No student information found');
                    hidePageLoader();
                }
                } catch (error) {
                    console.error('Error loading student data:', error);
                    showError('Error loading student data');
                    hidePageLoader();
                }
        }

        async function fetchStudentByZetaId(zetaId) {
            try {
                console.log('Fetching student with zeta_id:', zetaId);
                const response = await fetch(`/api/students/search/${zetaId}`);
                const result = await response.json();
                
                console.log('API response:', result);
                
                if (response.ok && result.success && result.data && result.data.length > 0) {
                    currentStudent = result.data[0];
                    console.log('Student data set:', currentStudent);
                    console.log('currentStudent.id after API fetch:', currentStudent?.id);
                    
                    // Ensure the student has an id field - if not, try to get it from the database
                    if (!currentStudent.id) {
                        console.log('Student missing id field, attempting to fetch full student data...');
                        try {
                            const fullStudentResponse = await fetch(`/api/students/zeta/${currentStudent.zeta_id}`);
                            if (fullStudentResponse.ok) {
                                const fullStudentResult = await fullStudentResponse.json();
                                if (fullStudentResult.success && fullStudentResult.data) {
                                    currentStudent = fullStudentResult.data;
                                    console.log('Updated student with id:', currentStudent.id);
                                }
                            }
                        } catch (error) {
                            console.error('Error fetching full student data:', error);
                        }
                    }
                    
                    displayStudentData(currentStudent);
                    
                    // Add a small delay to ensure DOM is ready
                    setTimeout(async () => {
                        console.log('About to call initializeInterview from API fetch path');
                        await initializeInterview();
                    }, 100);
            } else {
                    console.error('Student not found or invalid response:', result);
                    showError('Student not found');
                }
            } catch (error) {
                console.error('Error fetching student:', error);
                showError('Error fetching student data');
            }
        }

        function displayStudentData(student) {
            console.log('displayStudentData called with:', student);
            
            if (!student) {
                console.error('No student data provided to displayStudentData');
                return;
            }
            
            try {
                document.getElementById('candidate-name').textContent = `${student.first_name} ${student.last_name}`;
                document.getElementById('candidate-email').textContent = student.email;
                document.getElementById('candidate-phone').textContent = student.phone || 'N/A';
                document.getElementById('candidate-zeta-id').textContent = student.zeta_id;
                console.log('Student data displayed successfully');
            } catch (error) {
                console.error('Error displaying student data:', error);
            }
        }

        async function initializeInterview() {
            console.log('🕐 initializeInterview called, currentStudent:', currentStudent);
            console.log('currentStudent type:', typeof currentStudent);
            console.log('currentStudent.id:', currentStudent?.id);
            
            if (!currentStudent) {
                console.error('currentStudent is null/undefined');
                await loadStudentData();
                return;
            }

            // Check user role for verdict access
            await checkUserRole();
            
            if (!currentStudent.id) {
                console.error('currentStudent exists but has no id property');
                console.error('currentStudent keys:', Object.keys(currentStudent));
                console.error('currentStudent full object:', JSON.stringify(currentStudent, null, 2));
                
                // Try to reload student data as a fallback
                console.log('Attempting to reload student data...');
                const urlParams = new URLSearchParams(window.location.search);
                const zetaId = urlParams.get('zeta_id');
                
                if (zetaId) {
                    console.log('Retrying with zeta_id:', zetaId);
                    await fetchStudentByZetaId(zetaId);
                    return;
                }
                
                showError('No student data available');
                return;
            }

            try {
                console.log('Initializing interview for student:', currentStudent.id);
                
                // Get current interviewer ID
                const currentInterviewerId = await getCurrentInterviewerId();
                if (!currentInterviewerId) {
                    console.error('❌ Could not determine interviewer ID');
                    showError('Unable to identify interviewer. Please log in again.');
                    return;
                }
                
                // Check if there's already an active interview for this student
                const response = await fetch(`/api/interviews/student/${currentStudent.id}?interviewer_id=${currentInterviewerId}`);
                const result = await response.json();
                
                if (response.ok && result.success && result.data) {
                    currentInterview = result.data;
                    console.log('Found existing interview:', currentInterview);
                    // Restore verdict
                    document.getElementById('verdict-select').value = currentInterview.verdict || '';
                    // Restore notes if present
                    const notesEl = document.getElementById('interview-notes');
                    if (notesEl) {
                        notesEl.value = currentInterview.overall_notes || '';
                    }
                    // Ensure timer starts for existing in-progress interview
                    if (!interviewStartTime && currentInterview.status === 'in_progress') {
                        startDurationTracking();
                    }
                    await loadQuestions();
                } else if (response.status === 400 && result.error) {
                    // Handle the case where another interviewer is already conducting the interview
                    console.error('Interview conflict:', result.error);
                    showError(result.error);
                    
                    // Redirect back to interview page after a short delay
                    setTimeout(() => {
                        window.location.href = '/interview.html';
                    }, 3000);
                    return;
                } else {
                    console.log('No existing interview found, creating new one');
                    // Create new interview
                    await createInterview();
                }
                
                // Load previous interviews
                await loadPreviousInterviews();
                
                // Hide page loader after everything is initialized
                hidePageLoader();
            } catch (error) {
                console.error('Error initializing interview:', error);
                showError('Error initializing interview');
                
                // Hide loader even on error
                hidePageLoader();
                
                // Check if it's a conflict error and redirect
                if (error.message && error.message.includes('already being interviewed')) {
                    setTimeout(() => {
                        window.location.href = '/interview.html';
                    }, 3000);
                }
            }
        }

        async function createInterview() {
            console.log('🕐 createInterview called, currentStudent:', currentStudent);
            try {
                if (!currentStudent || !currentStudent.id) {
                    console.error('No student data available for creating interview');
                    showError('No student data available');
                    return;
                }

                // Get current interviewer ID using helper function
                const interviewerId = await getCurrentInterviewerId();
                
                if (!interviewerId) {
                    console.error('❌ Could not determine interviewer ID');
                    showError('Unable to identify interviewer. Please log in again.');
                    return;
                }
                
                // Get session ID from URL or student data
                const sessionId = getUrlParameter('session_id') || currentStudent.sessionId;
                
                console.log('Creating interview for student:', currentStudent.id, 'interviewer:', interviewerId, 'session:', sessionId);
                
                const response = await fetch('/api/interviews', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        student_id: currentStudent.id,
                        interviewer_id: interviewerId,
                        session_id: sessionId
                    })
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    currentInterview = result.data;
                    console.log('Interview created:', currentInterview);
                    
                    // Start duration tracking
                    startDurationTracking();
                    
                    // Load questions for this new interview (will be empty initially)
                    await loadQuestions();
                } else {
                    console.error('Error creating interview:', result);
                    showError('Error creating interview: ' + (result.error || 'Unknown error'));
                    
                    // Check if it's a conflict error and redirect
                    if (result.error && result.error.includes('already being interviewed')) {
                        setTimeout(() => {
                            window.location.href = '/interview.html';
                        }, 3000);
                    }
                }
            } catch (error) {
                console.error('Error creating interview:', error);
                showError('Error creating interview');
                
                // Check if it's a conflict error and redirect
                if (error.message && error.message.includes('already being interviewed')) {
                    setTimeout(() => {
                        window.location.href = '/interview.html';
                    }, 3000);
                }
            }
        }

        // Duration tracking functions
        function startDurationTracking() {
            console.log('🕐 startDurationTracking called, interviewStartTime:', interviewStartTime);
            if (interviewStartTime) {
                console.log('⏱️ Timer already started, returning');
                return; // Already started
            }
            
            // Check if we have an existing interview with created_at timestamp
            if (currentInterview && currentInterview.created_at) {
                // Calculate elapsed time since interview was created
                const createdAt = new Date(currentInterview.created_at);
                const now = new Date();
                const elapsedMs = now - createdAt;
                
                // Set start time to account for elapsed time
                interviewStartTime = new Date(now - elapsedMs);
                console.log('⏱️ Loading existing interview:');
                console.log('   - Created at:', createdAt);
                console.log('   - Current time:', now);
                console.log('   - Elapsed time:', Math.floor(elapsedMs / 1000), 'seconds');
                console.log('   - Adjusted start time:', interviewStartTime);
            } else if (currentInterview && currentInterview.duration_seconds) {
                // Fallback: use duration_seconds if available (for old interviews)
                const existingDurationMs = currentInterview.duration_seconds * 1000;
                interviewStartTime = new Date(Date.now() - existingDurationMs);
                console.log('⏱️ Resuming interview with stored duration:', currentInterview.duration_seconds, 'seconds');
                console.log('⏱️ Adjusted start time:', interviewStartTime);
            } else {
                // For brand new interviews, start from current time
                interviewStartTime = new Date();
                console.log('⏱️ New interview started at:', interviewStartTime);
            }
            
            // Update clock every second
            durationInterval = setInterval(updateDurationDisplay, 1000);
            console.log('⏱️ Timer interval set:', durationInterval);
            updateDurationDisplay();
        }

        function stopDurationTracking() {
            if (durationInterval) {
                clearInterval(durationInterval);
                durationInterval = null;
            }
            
            if (interviewStartTime) {
                const endTime = new Date();
                const duration = Math.floor((endTime - interviewStartTime) / 1000);
                console.log('⏱️ Interview ended. Duration:', duration, 'seconds');
                
                // Update database with duration
                updateInterviewDuration(duration, endTime);
            }
        }

        function updateDurationDisplay() {
            console.log('🕐 updateDurationDisplay called, interviewStartTime:', interviewStartTime);
            if (!interviewStartTime) {
                console.log('⏱️ No interview start time, returning');
                    return;
                }
            
            const now = new Date();
            const duration = Math.floor((now - interviewStartTime) / 1000);
            console.log('⏱️ Duration calculated:', duration, 'seconds');
            
            const hours = Math.floor(duration / 3600);
            const minutes = Math.floor((duration % 3600) / 60);
            const seconds = duration % 60;
            
            const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            console.log('⏱️ Time string:', timeString);
            
            const durationDisplay = document.getElementById('duration-display');
            console.log('⏱️ Duration display element:', durationDisplay);
            if (durationDisplay) {
                durationDisplay.textContent = timeString;
                console.log('⏱️ Updated display to:', timeString);
            } else {
                console.error('⏱️ Duration display element not found!');
            }
        }

        async function updateInterviewDuration(durationSeconds, endTime) {
            if (!currentInterview) return;
            
            try {
                const response = await fetch(`/api/interviews/${currentInterview.id}/duration`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        duration_seconds: durationSeconds,
                        end_time: endTime.toISOString()
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    console.log('✅ Interview duration updated:', durationSeconds, 'seconds');
                }
            } catch (error) {
                console.error('Error updating interview duration:', error);
            }
        }

        // Role-based access control
        async function checkUserRole() {
            try {
                // Get user role from server
                // Prefer email from URL or localStorage to resolve role accurately
                const urlParams = new URLSearchParams(window.location.search);
                const urlEmail = urlParams.get('email');
                let email = urlEmail;
                if (!email) {
                    try {
                        const stored = localStorage.getItem('bees_user_data');
                        const data = stored ? JSON.parse(stored) : null;
                        email = data?.email || '';
                    } catch {}
                }
                const roleEndpoint = email ? `/api/user/role?email=${encodeURIComponent(email)}` : '/api/user/role';
                const response = await fetch(roleEndpoint);
                const result = await response.json();
                
                if (result.success) {
                    userRole = result.role;
                    console.log('User role:', userRole);
                    
                    // Show verdict section for all users
                    const verdictSection = document.getElementById('verdict-section');
                    if (verdictSection) {
                        verdictSection.classList.remove('hidden');
                    }

                    // Show role-appropriate dashboard button in header
                    const dashboardBtn = document.getElementById('dashboard-btn');
                    if (dashboardBtn) {
                        const urlParams = new URLSearchParams(window.location.search);
                        const email = urlParams.get('email') || '';
                        const name = urlParams.get('name') || '';
                        const qs = `?${[email?`email=${encodeURIComponent(email)}`:'', name?`name=${encodeURIComponent(name)}`:''].filter(Boolean).join('&')}`;
                        const isAdmin = userRole === 'admin' || userRole === 'superadmin';
                        const target = isAdmin ? `/admin-dashboard.html${qs}` : `/interviewer-dashboard.html${qs}`;
                        dashboardBtn.classList.remove('hidden');
                        dashboardBtn.onclick = () => {
                            const isSafe = !currentInterview || (currentInterview && currentInterview.status === 'completed');
                            if (isSafe) {
                                window.location.href = target;
                                return;
                            }
                            const overlay = document.createElement('div');
                            overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.35);display:flex;align-items:center;justify-content:center;z-index:2000;';
                            overlay.innerHTML = `
                              <div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;min-width:280px;max-width:90%;padding:16px;box-shadow:0 10px 20px rgba(0,0,0,0.15)">
                                <div style=\"font-weight:600;margin-bottom:8px;color:#111827\">Leave without saving?</div>
                                <div style=\"font-size:14px;color:#374151;margin-bottom:12px\">You have an active interview. Unsaved changes may be lost. Continue to Dashboard?</div>
                                <div style=\"display:flex;gap:8px;justify-content:flex-end\">
                                  <button id=\"db-cancel\" style=\"border:1px solid #e5e7eb;background:#fff;padding:6px 10px;border-radius:6px;cursor:pointer\">Cancel</button>
                                  <button id=\"db-continue\" style=\"background:#111827;color:#fff;border:none;padding:6px 10px;border-radius:6px;cursor:pointer\">Continue</button>
                                </div>
                              </div>`;
                            document.body.appendChild(overlay);
                            overlay.querySelector('#db-cancel').onclick = ()=> overlay.remove();
                            overlay.querySelector('#db-continue').onclick = ()=> { overlay.remove(); window.location.href = target; };
                        };
                    }
                }
            } catch (error) {
                console.error('Error checking user role:', error);
                // Default to showing verdict section for all users
                const verdictSection = document.getElementById('verdict-section');
                if (verdictSection) {
                    verdictSection.classList.remove('hidden');
                }
            }
        }

        function getUrlParameter(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }

        function formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            
            if (hours > 0) {
                return `${hours}h ${minutes}m ${secs}s`;
            } else if (minutes > 0) {
                return `${minutes}m ${secs}s`;
                } else {
                return `${secs}s`;
            }
        }

        async function addQuestion() {
            // Check if editor is initialized
            if (!questionEditor) {
                console.error('❌ Quill editor not initialized');
                showError('Editor not ready. Please refresh the page.');
                return;
            }
            
            // Get content from rich text editor
            const questionHTML = questionEditor.root.innerHTML;
            const questionText = questionEditor.getText().trim();
            
            console.log('➕ Adding custom question:', questionText);
            console.log('➕ Question length:', questionText.length);
            console.log('➕ Rich content length:', questionHTML.length);
            console.log('➕ Rich content preview:', questionHTML.substring(0, 100));
            console.log('➕ Current questions count before adding:', questions.length);
            
            if (!questionText || questionText === '' || questionText.length === 0) {
                showError('Please enter a question');
                return;
            }

            if (!currentInterview) {
                showError('No active interview found');
                return;
            }

            // Show loading state
            const addButton = document.getElementById('add-question-btn');
            const originalText = addButton.textContent;
            addButton.textContent = 'Adding...';
            addButton.disabled = true;

            try {
                console.log('📤 Sending POST request to save custom question...');
                console.log('Request details:', {
                    url: `/api/interviews/${currentInterview.id}/questions`,
                    question_text: questionText.substring(0, 50) + '...',
                    has_rich_content: !!questionHTML,
                    rich_content_length: questionHTML?.length
                });
                
                const response = await fetch(`/api/interviews/${currentInterview.id}/questions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        question_text: questionText,
                        question_rich_content: questionHTML
                    })
                });
                
                console.log('📥 Response status:', response.status, response.statusText);
                
                const result = await response.json();
                console.log('📥 Server response for custom question:', result);
                
                if (response.ok && result.success) {
                    console.log('✅ Custom question saved successfully, reloading questions...');
                    // Reload questions from server to get the latest state for this specific interview
                    await loadQuestions();
                    // Clear the editor
                    questionEditor.setContents([]);
                    showSuccess('Question added successfully!');
                } else {
                    console.error('❌ Error saving custom question:', result);
                    showError(result.error || result.message || 'Error adding question');
                }
            } catch (error) {
                console.error('❌ Error adding custom question:', error);
                console.error('Error name:', error.name);
                console.error('Error message:', error.message);
                console.error('Error stack:', error.stack);
                showError('Error adding question: ' + (error.message || 'Unknown error'));
            } finally {
                // Restore button state
                addButton.textContent = originalText;
                addButton.disabled = false;
            }
        }

        async function loadQuestions() {
            if (!currentInterview) return;

            try {
                console.log('🔄 Loading questions for interview:', currentInterview.id);
                const response = await fetch(`/api/interviews/${currentInterview.id}/questions`);
                const result = await response.json();
                
                if (response.ok && result.success) {
                    console.log('📋 Loaded questions from server:', result.data.length, 'questions');
                    console.log('📋 Questions data:', result.data);
                    // Reverse the order to show newest questions first
                    questions = result.data.reverse();
                    await displayQuestions();
                } else {
                    console.error('❌ Error loading questions:', result);
                    showError('Error loading questions');
                }
            } catch (error) {
                console.error('❌ Error loading questions:', error);
                showError('Error loading questions');
            }
        }

        // Helper function to extract first few words from HTML content
        function getQuestionPreview(htmlContent, maxWords = 8) {
            // Create a temporary div to parse HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlContent;
            
            // Get text content without HTML tags
            const textContent = tempDiv.textContent || tempDiv.innerText || '';
            
            // Split into words and take first maxWords
            const words = textContent.trim().split(/\s+/);
            const preview = words.slice(0, maxWords).join(' ');
            
            // Add ellipsis if there are more words
            return words.length > maxWords ? preview + '...' : preview;
        }

        async function displayQuestions() {
            const chatMessages = document.getElementById('chat-messages');
            
            console.log('displayQuestions called with questions:', questions);
            console.log('Number of questions:', questions.length);
            
            // Ensure question bank data is loaded for button visibility logic
            if (!questionBankData || questionBankData.length === 0) {
                console.log('🔄 Question bank data not loaded, loading now...');
                await loadQuestionBankData();
            }
            
            questions.forEach((q, i) => {
                console.log(`Question ${i}:`, {
                    id: q.id,
                    text: q.question_text,
                    answer_photo_url: q.answer_photo_url
                });
                if (q.answer_photo_url) {
                    console.log(`📸 Question ${i} has image:`, q.answer_photo_url);
                }
            });
            
            if (questions.length === 0) {
                chatMessages.innerHTML = '<div class="loading">No questions added yet</div>';
                    return;
                }

            // Track which questions are currently expanded
            const expandedQuestions = new Set();
            questions.forEach(question => {
                const questionItem = document.querySelector(`[data-question-id="${question.id}"]`);
                if (questionItem && questionItem.classList.contains('expanded')) {
                    expandedQuestions.add(question.id);
                }
            });

            chatMessages.innerHTML = questions.map((question, index) => {
                // Check if this question already exists in question bank
                // Check both question_text and question_rich_content for comparison
                const questionText = question.question_text || '';
                const questionRichContent = question.question_rich_content || '';
                console.log('🔍 Checking question for bank status:', {
                    questionText: questionText.substring(0, 50) + '...',
                    questionRichContent: questionRichContent.substring(0, 50) + '...',
                    questionBankDataLength: questionBankData?.length || 0
                });
                
                const isFromQuestionBank = questionBankData && questionBankData.length > 0 && 
                    questionBankData.some(bankQuestion => {
                        const bankText = (bankQuestion.question || bankQuestion.question_text || '').trim().toLowerCase();
                        const interviewText = questionText.trim().toLowerCase();
                        const interviewRichText = questionRichContent.trim().toLowerCase();
                        
                        // Match if either question_text or question_rich_content matches
                        const isMatch = (interviewText && bankText === interviewText) || 
                                       (interviewRichText && bankText === interviewRichText);
                        
                        if (isMatch) {
                            console.log('✅ Found match in question bank:', {
                                bankText: bankText.substring(0, 50) + '...',
                                interviewText: interviewText.substring(0, 50) + '...',
                                interviewRichText: interviewRichText.substring(0, 50) + '...'
                            });
                        }
                        return isMatch;
                    });
                
                console.log('📊 Question bank status:', {
                    questionText: questionText.substring(0, 30) + '...',
                    isFromQuestionBank,
                    willShowButton: !isFromQuestionBank
                });
                
                return `
                <div class="question-item" data-question-id="${question.id}">
                    <div class="question-header" onclick="toggleQuestion(${question.id})">
                        <span class="question-number">Q${questions.length - index}</span>
                        <div class="question-preview">${getQuestionPreview(question.question_text)}</div>
                        <div class="question-actions">
                            <div class="correctness-slider-container">
                                <label class="slider-label" onclick="event.stopPropagation()">Score: <span id="score-value-${question.id}">${question.correctness_score !== null && question.correctness_score !== undefined ? question.correctness_score : '0'}</span>/10</label>
                                <input type="range" 
                                       min="0" 
                                       max="10" 
                                       value="${question.correctness_score !== null && question.correctness_score !== undefined ? question.correctness_score : 0}" 
                                       class="correctness-slider ${question.correctness_score !== null && question.correctness_score !== undefined ? 'scored' : ''}"
                                       id="slider-${question.id}"
                                       oninput="event.stopPropagation(); updateScoreDisplay(${question.id}, this.value)"
                                       onchange="event.stopPropagation(); markQuestionScore(${question.id}, this.value)"
                                       onclick="event.stopPropagation()"
                                       title="Rate answer quality (0-10)">
                            </div>
                            <button class="ai-eval-btn" onclick="event.stopPropagation(); evaluateQuestionAI(${question.id})" title="AI Evaluate">
                                <img src="/generative.png" class="icn" alt="AI" style="width:25px;height:25px;vertical-align:middle">
                            </button>
                            ${(isFromQuestionBank || question.__fromBank) ? '' : `
                            <button class="add-to-bank-btn-small" onclick="event.stopPropagation(); addQuestionToBankById(${question.id})" title="Add to Question Bank">
                                📚
                            </button>
                            `}
                            <button class="delete-question-btn" onclick="event.stopPropagation(); deleteQuestion(${question.id})" title="Delete Question">
                                <img src="/delete.png" class="icn" alt="Delete" style="width:25px;height:25px;vertical-align:middle">
                            </button>
                            <span class="expand-icon">▼</span>
                        </div>
                    </div>
                    <div class="question-content" id="content-${question.id}">
                        <div class="question-text-section">
                            <div class="question-text-display" id="question-text-display-${question.id}">${question.question_rich_content || question.question_text}</div>
                            <button class="edit-question-btn" onclick="event.stopPropagation(); editQuestionText(${question.id})" title="Edit Question">
                                <img src="/edit.png" alt="Edit" style="width:16px;height:16px;vertical-align:middle">
                            </button>
                        </div>
                        <div class="answer-section">
                            <label class="answer-label">Student Answer</label>
                            <textarea 
                                class="form-textarea" 
                                placeholder="Enter student's answer here..."
                                oninput="debouncedAutoSaveAnswer(${question.id}, this.value)"
                                onchange="updateAnswer(${question.id}, this.value)"
                                style="background: white; border: 1px solid #d1d5db; color: #1f2937; resize: vertical; min-height: 80px;"
                            >${question.student_answer || ''}</textarea>
                            ${question.answer_photo_url ? `
                                <div class="photo-gallery">
                                    ${(() => {
                                        try {
                                            const photoUrls = JSON.parse(question.answer_photo_url);
                                            if (Array.isArray(photoUrls)) {
                                                return photoUrls.map((url, index) => `
                                                    <div class="photo-item">
                                                        <img src="${url}" class="message-image" onclick="openImageModal('${url}')" title="Click to view full size" onerror="console.error('Image failed to load:', this.src)" onload="console.log('✅ Image loaded successfully:', this.src)">
                                                        <button class="photo-delete" onclick="deletePhoto(${question.id}, ${index})" title="Delete image"><img src="/close.png" class="icn" alt="Delete" style="width:16px;height:16px"></button>
                                                    </div>
                                                `).join('');
                                            } else {
                                                // Handle single image (backward compatibility)
                                                return `
                                                    <div class="photo-item">
                                                        <img src="${question.answer_photo_url}" class="message-image" onclick="openImageModal('${question.answer_photo_url}')" title="Click to view full size" onerror="console.error('Image failed to load:', this.src)" onload="console.log('✅ Image loaded successfully:', this.src)">
                                                        <button class="photo-delete" onclick="deletePhoto(${question.id})" title="Delete image"><img src="/close.png" class="icn" alt="Delete" style="width:16px;height:16px"></button>
                                                    </div>
                                                `;
                                            }
                                        } catch (e) {
                                            // Handle single image (backward compatibility)
                                            return `
                                                <div class="photo-item">
                                                    <img src="${question.answer_photo_url}" class="message-image" onclick="openImageModal('${question.answer_photo_url}')" title="Click to view full size" onerror="console.error('Image failed to load:', this.src)" onload="console.log('✅ Image loaded successfully:', this.src)">
                                                    <button class="photo-delete" onclick="deletePhoto(${question.id})" title="Delete image">🗑</button>
                                                </div>
                                            `;
                                        }
                                    })()}
                                </div>
                            ` : ''}
                            <div class="photo-capture">
                                <button class="photo-btn" onclick="document.getElementById('photo-input-${question.id}').click()">
                                    📁 Upload Image
                                </button>
                                <button class="photo-btn" onclick="openCamera('${question.id}')">
                                    📷 Camera
                                </button>
                                <input type="file" class="photo-input" id="photo-input-${question.id}" 
                                       accept="image/*" multiple onchange="handlePhotoUpload('${question.id}', this)">
                                <input type="file" class="photo-input" id="camera-input-${question.id}" 
                                       accept="image/*" capture="environment" onchange="handlePhotoUpload('${question.id}', this)">
                            </div>
                        </div>
                    </div>
                </div>
            `
            }).join('');
            
            // Restore expanded state for questions that were previously expanded
            setTimeout(() => {
                expandedQuestions.forEach(questionId => {
                    const questionItem = document.querySelector(`[data-question-id="${questionId}"]`);
                    if (questionItem) {
                        const content = questionItem.querySelector('.question-content');
                        const header = questionItem.querySelector('.question-header');
                        if (content && header) {
                            content.classList.add('expanded');
                            header.classList.add('expanded');
                            questionItem.classList.add('expanded');
                            console.log(`Restored expanded state for question ${questionId}`);
                        }
                    }
                });
            }, 50);
            
            // Debug: Check if elements were created and ensure DOM is ready
            setTimeout(() => {
                console.log('Checking created question elements...');
                let allElementsReady = true;
                questions.forEach(q => {
                    const questionItem = document.querySelector(`[data-question-id="${q.id}"]`);
                    const content = questionItem?.querySelector('.question-content');
                    const header = questionItem?.querySelector('.question-header');
                    const isReady = !!(questionItem && content && header);
                    allElementsReady = allElementsReady && isReady;
                    
                    console.log(`Question ${q.id}:`, {
                        questionItem: !!questionItem,
                        content: !!content,
                        header: !!header,
                        isReady: isReady,
                        questionItemElement: questionItem,
                        contentElement: content,
                        headerElement: header
                    });
                    
                    // Test if click handler works
                    if (header) {
                        console.log(`Testing click handler for question ${q.id}`);
                        // Don't actually trigger the click, just verify the element exists
                    }
                });
                
                if (allElementsReady) {
                    console.log('✅ All question elements are ready for interaction');
                } else {
                    console.warn('⚠️ Some question elements are not ready for interaction');
                }
            }, 100);
            
            // Update total score after displaying questions
            updateTotalScore();
        }

        async function evaluateQuestionAI(questionId) {
            let loadingModal = null;
            try {
                const q = questions.find(x => String(x.id) === String(questionId));
                if (!q) { showError('Question not found'); return; }
                
                // Check if there's an answer (text or image)
                const hasTextAnswer = q.student_answer && q.student_answer.trim().length > 0;
                const hasImageAnswer = q.answer_photo_url && q.answer_photo_url.trim().length > 0;
                
                if (!hasTextAnswer && !hasImageAnswer) {
                    showError('Please provide an answer first before requesting AI evaluation.');
                    return;
                }
                
                // Show loading modal
                loadingModal = document.createElement('div');
                loadingModal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.45);display:flex;align-items:center;justify-content:center;z-index:2000;';
                loadingModal.innerHTML = `
                    <div style="background:#fff;border:1px solid #e5e7eb;border-radius:10px;padding:24px;text-align:center;box-shadow:0 10px 24px rgba(0,0,0,0.2);">
                        <div style="display:inline-block;width:40px;height:40px;border:4px solid #f3f4f6;border-top:4px solid #3b82f6;border-radius:50%;animation:spin 1s linear infinite;margin-bottom:12px"></div>
                        <div style="font-size:16px;color:#374151;font-weight:500">Evaluating Question ${q.questionNumber || questions.indexOf(q) + 1}...</div>
                        <div style="font-size:14px;color:#6b7280;margin-top:4px">Please wait while AI analyzes the answer</div>
                    </div>`;
                document.body.appendChild(loadingModal);
                
                // Build safe text inputs for AI: strip images and convert HTML to text for answer
                const questionText = (q.question_rich_content || q.question_text || '')
                    .replace(/<img[^>]*>/gi, '')
                    .replace(/<br\s*\/?>/gi, '\n')
                    .replace(/<[^>]+>/g, '')
                    .trim();
                const answerText = (q.student_answer || '')
                    .replace(/<img[^>]*>/gi, '[image omitted]')
                    .replace(/<br\s*\/?>/gi, '\n')
                    .replace(/<[^>]+>/g, '')
                    .trim();
                const payload = {
                    question_text: questionText,
                    answer_text: answerText,
                    answer_image_url: q.answer_photo_url || undefined
                };
                const res = await fetch('/api/evaluate-question', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const json = await res.json();
                
                // Remove loading modal
                if (loadingModal) {
                    loadingModal.remove();
                    loadingModal = null;
                }
                
                if (!res.ok || !json.success) {
                    showError(json.error || 'AI evaluation failed');
                    return;
                }

                const data = json.data || {};
                const questionNumber = q.questionNumber || questions.indexOf(q) + 1;
                const modal = document.createElement('div');
                modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.45);display:flex;align-items:center;justify-content:center;z-index:2000;';
                modal.innerHTML = `
                    <div style="background:#fff;border:1px solid #e5e7eb;border-radius:10px;max-width:620px;width:92%;padding:16px;box-shadow:0 10px 24px rgba(0,0,0,0.2)">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                            <h3 style="margin:0;color:#111827">AI Evaluation - Question ${questionNumber}</h3>
                            <button onclick="this.closest('div').parentElement.parentElement.remove()" style="background:#f3f4f6;border:1px solid #e5e7eb;border-radius:6px;padding:4px 8px;cursor:pointer">✕</button>
                        </div>
                        <div style="font-size:14px;color:#374151;line-height:1.6">
                            <div style="display:flex;gap:12px;flex-wrap:wrap">
                               <div><strong>Difficulty:</strong> <span style="text-transform:capitalize">${data.difficulty_label || 'unknown'}</span> (${data.difficulty_score ?? '-'}/10)</div>
                               <div><strong>Answer Score:</strong> ${data.answer_score == null ? '-' : data.answer_score + '/10'}</div>
                            </div>
                            <div style="margin-top:10px">
                               <div style="font-weight:600;color:#111827;margin-bottom:4px">Detailed Evaluation</div>
                               <div><strong>What was assessed:</strong> Clarity, completeness, technical depth, and correctness.</div>
                               <div style="margin-top:6px"><strong>Strengths:</strong> ${data.strengths || '—'}</div>
                               <div style="margin-top:4px"><strong>Gaps:</strong> ${data.gaps || '—'}</div>
                               <div style="margin-top:8px"><strong>Summary:</strong> ${data.rationale || '—'}</div>
                               ${data.explanation ? `<div style=\"margin-top:8px\"><strong>Explanation:</strong> ${data.explanation}</div>` : ''}
                            </div>
                            <div style="margin-top:12px;display:flex;gap:8px;justify-content:flex-end">
                               ${data.answer_score != null ? `<button id="set-ai-score-btn" class="btn btn-primary btn-sm">Set this score</button>` : ''}
                            </div>
                        </div>
                    </div>`;
                modal.onclick = (e)=>{ if(e.target===modal) modal.remove(); };
                document.body.appendChild(modal);

                // Bind score setter
                const setBtn = modal.querySelector('#set-ai-score-btn');
                if (setBtn && data.answer_score != null) {
                    setBtn.onclick = async ()=>{
                        try{
                            const scoreValue = Number(data.answer_score);
                            // Validate score is a valid number between 0-10
                            if (isNaN(scoreValue) || scoreValue < 0 || scoreValue > 10) {
                                showError('Invalid score value. Must be between 0 and 10.');
                                return;
                            }
                            
                            // Update backend score
                            const resp = await fetch(`/api/interview-questions/${questionId}/score`,{
                                method:'PUT', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ correctness_score: scoreValue })
                            });
                            const js = await resp.json();
                            if (!resp.ok || js.success===false){ showError(js.error||'Failed to set score'); return; }
                            
                            // Update local slider and label (correct IDs)
                            const slider = document.getElementById(`slider-${questionId}`);
                            const label = document.getElementById(`score-value-${questionId}`);
                            if (slider){ 
                                slider.value = scoreValue; 
                                slider.classList.add('scored'); 
                            }
                            if (label){ label.textContent = scoreValue; }
                            
                            // Update local questions array
                            const questionIndex = questions.findIndex(q => q.id === questionId);
                            if (questionIndex !== -1) {
                                questions[questionIndex].correctness_score = scoreValue;
                            }
                            
                            // Update total score
                            updateTotalScore();
                            
                            showSuccess('Score updated from AI');
                            modal.remove();
                        }catch(err){ console.error(err); showError('Failed to set score'); }
                    };
                }
            } catch (e) {
                console.error('AI evaluation error:', e);
                showError('AI evaluation error');
            } finally {
                // Always remove loading modal if it exists
                if (loadingModal) {
                    loadingModal.remove();
                }
            }
        }


        async function updateVerdict() {
            if (!currentInterview) return;

            const verdict = document.getElementById('verdict-select').value;
            console.log('📝 Updating verdict:', { interviewId: currentInterview.id, verdict, isEmpty: verdict === '' });
            
            // Allow empty verdict (clearing selection)
            const verdictValue = verdict === '' ? null : verdict;
            
            try {
                const response = await fetch(`/api/interviews/${currentInterview.id}/verdict`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        verdict: verdictValue
                    })
                });
                
                console.log('📥 Verdict response status:', response.status, 'OK:', response.ok);
                const result = await response.json();
                console.log('📥 Verdict response data:', result);
                
                if (response.ok && result.success) {
                    currentInterview.verdict = verdictValue;
                    if (verdictValue === null) {
                        showSuccess('Verdict cleared successfully!');
                    } else {
                        showSuccess('Verdict updated successfully!');
                    }
                } else {
                    console.error('❌ Server returned error:', result.error);
                    showError(`Error: ${result.error || 'Error updating verdict'}`);
                }
            } catch (error) {
                console.error('❌ Error updating verdict:', error);
                console.error('❌ Error details:', { message: error.message, stack: error.stack });
                showError('Error updating verdict: ' + error.message);
            }
        }

        // Debounced auto-save for answers to reduce server load while typing
        let __autoSaveTimers = {};
        function debouncedAutoSaveAnswer(questionId, val){
            try { if (__autoSaveTimers[questionId]) clearTimeout(__autoSaveTimers[questionId]); } catch {}
            __autoSaveTimers[questionId] = setTimeout(()=>{
                updateAnswer(questionId, val);
            }, 600);
        }

        async function loadPreviousInterviews() {
            if (!currentStudent || !currentStudent.id) {
                console.log('No student data available for loading previous interviews');
                displayPreviousInterviews();
                return;
            }

            try {
                console.log('Loading previous interviews for student:', currentStudent.id);
                const response = await fetch(`/api/interviews/student/${currentStudent.id}/history`);
                const result = await response.json();
                
                if (response.ok && result.success) {
                    previousInterviews = result.data;
                    displayPreviousInterviews();
                } else {
                    console.log('No previous interviews found');
                    previousInterviews = [];
                    displayPreviousInterviews();
                }
            } catch (error) {
                console.error('Error loading previous interviews:', error);
                previousInterviews = [];
                displayPreviousInterviews();
            }
        }

        function displayPreviousInterviews() {
            const previousInterviewsList = document.getElementById('previous-interviews-list');
            
            if (previousInterviews.length === 0) {
                previousInterviewsList.innerHTML = `
                    <div class="no-data-container">
                        <div class="no-data-icon">📋</div>
                        <div class="no-data-text">No Previous Interviews</div>
                        <div class="no-data-subtext">This student hasn't completed any interviews yet</div>
                    </div>
                `;
                return;
            }

            // Check if user is admin/superadmin to show verdict
            const isAdmin = userRole === 'admin' || userRole === 'superadmin';

            previousInterviewsList.innerHTML = previousInterviews.map(interview => {
                const date = new Date(interview.created_at).toLocaleDateString();
                const sessionName = interview.session_name || 'General Interview';
                const interviewerName = interview.interviewer_name || 'Unknown Interviewer';
                const duration = interview.duration_seconds ? formatDuration(interview.duration_seconds) : 'N/A';
                const status = interview.status || 'completed';
                const statusClass = status === 'completed' ? 'status-completed' : 'status-in-progress';
                const statusText = status === 'completed' ? 'Completed' : 'In Progress';
                
                return `
                    <div class="previous-interview-item" onclick="viewPreviousInterview(${interview.id})">
                        <div class="previous-interview-header">
                            <span class="previous-interview-date">${date}</span>
                            <div>
                                <span class="previous-interview-status ${statusClass}">${statusText}</span>
                                ${isAdmin && interview.verdict ? `<span class="previous-interview-verdict">${interview.verdict}</span>` : ''}
                            </div>
                        </div>
                        <div class="previous-interview-details">
                            <div class="interview-detail-row">
                                <span class="detail-label">Session:</span>
                                <span class="detail-value">${sessionName}</span>
                            </div>
                            <div class="interview-detail-row">
                                <span class="detail-label">Interviewer:</span>
                                <span class="detail-value">${interviewerName}</span>
                            </div>
                            <div class="interview-detail-row">
                                <span class="detail-label">Duration:</span>
                                <span class="detail-value">${duration}</span>
                            </div>
                        </div>
                        <div class="previous-interview-questions">
                            <span class="previous-interview-questions-count">Interview #${interview.id}</span>
                            ${interview.overall_notes ? `<br><small>Notes: ${interview.overall_notes.substring(0, 50)}${interview.overall_notes.length > 50 ? '...' : ''}</small>` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        async function viewPreviousInterview(interviewId) {
            try {
                // Load questions for the previous interview
                const response = await fetch(`/api/interviews/${interviewId}/questions`);
                const result = await response.json();
                
                if (response.ok && result.success) {
                    const previousQuestions = result.data;
                    showPreviousInterviewModal(interviewId, previousQuestions);
                } else {
                    showError('Error loading previous interview details');
                }
            } catch (error) {
                console.error('Error loading previous interview:', error);
                showError('Error loading previous interview');
            }
        }

        function openImageModal(imageUrl) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 2000;
                cursor: pointer;
            `;
            
            modal.innerHTML = `
                <div style="position: relative; max-width: 90vw; max-height: 90vh;">
                    <img src="${imageUrl}" style="max-width: 100%; max-height: 100%; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
                    <button onclick="this.closest('div').parentElement.remove()" 
                            style="position: absolute; top: -10px; right: -10px; background: #dc3545; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 16px; font-weight: bold;">
                        ✕
                    </button>
                </div>
            `;
            
            modal.onclick = function(e) {
                if (e.target === modal) {
                    modal.remove();
                }
            };
            
            document.body.appendChild(modal);
        }

        function showPreviousInterviewModal(interviewId, questions) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
            `;
            
            // Helper function to parse image URLs
            const parseImageUrls = (photoUrl) => {
                if (!photoUrl) return null;
                
                // If it's a string that looks like JSON array, parse it
                if (typeof photoUrl === 'string' && photoUrl.startsWith('[')) {
                    try {
                        const parsed = JSON.parse(photoUrl);
                        return Array.isArray(parsed) ? parsed : [photoUrl];
                    } catch (e) {
                        console.warn('Failed to parse photo URL as JSON:', photoUrl);
                        return [photoUrl];
                    }
                }
                
                // If it's already an array, return it
                if (Array.isArray(photoUrl)) {
                    return photoUrl;
                }
                
                // Otherwise, it's a single URL string
                return [photoUrl];
            };
            
            modal.innerHTML = `
                <div style="background: white; padding: 2rem; border-radius: 8px; max-width: 800px; max-height: 80vh; overflow-y: auto; margin: 1rem;">
                    <h3 style="margin-bottom: 1rem; color: #2d3748;">Previous Interview #${interviewId}</h3>
                    <div style="margin-bottom: 1rem;">
                        ${questions.map((q, index) => {
                            const imageUrls = parseImageUrls(q.answer_photo_url);
                            const hasImages = imageUrls && imageUrls.length > 0;
                            
                            // Process question content - use rich content if available, otherwise use plain text
                            let questionContent = '';
                            if (q.question_rich_content) {
                                // Apply 300x300 sizing to any images in rich content
                                questionContent = q.question_rich_content.replace(
                                    /<img([^>]*)>/gi,
                                    '<img$1 style="width: 300px; height: 300px; object-fit: contain; border: 1px solid #e2e8f0; border-radius: 4px; display: block; margin: 10px 0;">'
                                );
                            } else {
                                questionContent = q.question_text;
                            }
                            
                            return `
                            <div style="margin-bottom: 1rem; padding: 1rem; background: #f7fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
                                <div style="font-weight: 600; color: #2d3748; margin-bottom: 0.5rem;">
                                    <div>Q${index + 1}:</div>
                                    <div style="font-weight: 500; margin-top: 0.5rem;">${questionContent}</div>
                                </div>
                                <div style="color: #4a5568; margin-bottom: 0.5rem;">
                                    <strong>Answer:</strong> ${q.student_answer || 'No answer provided'}
                                </div>
                                ${hasImages ? `
                                    <div style="margin-top: 0.5rem; padding: 0.5rem; background: #e8f5e8; border-radius: 6px; border: 1px solid #c3e6c3;">
                                        <div style="font-weight: 600; color: #28a745; margin-bottom: 0.5rem; font-size: 0.9rem;">
                                            📷 Answer Sheet${imageUrls.length > 1 ? 's' : ''}
                                        </div>
                                        <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                            ${imageUrls.map(url => `
                                                <img src="${url}" style="width: 300px; height: 300px; border-radius: 6px; border: 2px solid #dee2e6; object-fit: contain; cursor: pointer;" 
                                                     onclick="openImageModal('${url}')" 
                                                     title="Click to view full size">
                                            `).join('')}
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        `}).join('')}
                    </div>
                    <button onclick="this.closest('div').parentElement.remove()" 
                            style="background: #2d3748; color: white; border: none; padding: 0.5rem 1rem; border-radius: 5px; cursor: pointer;">
                        Close
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
        }


        function openCamera(questionId) {
            // Check if getUserMedia is supported
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                // Fallback to file input with camera capture
                document.getElementById(`camera-input-${questionId}`).click();
                return;
            }

            // Request camera access
            navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: 'environment' // Prefer rear camera on mobile
                } 
            })
            .then(stream => {
                // Create a video element to show camera feed
                const video = document.createElement('video');
                video.style.width = '100%';
                video.style.maxWidth = '400px';
                video.style.borderRadius = '8px';
                video.srcObject = stream;
                video.play();

                // Create a modal for camera capture
                const modal = document.createElement('div');
                modal.className = 'camera-modal';
                modal.innerHTML = `
                    <div class="camera-container">
                        <div class="camera-header">
                            <h3>Take Photo</h3>
                            <button class="close-camera" onclick="closeCamera()">✕</button>
                        </div>
                        <div class="camera-preview">
                            <video id="camera-video" autoplay playsinline></video>
                        </div>
                        <div class="camera-controls">
                            <button class="btn btn-danger" onclick="closeCamera()">Cancel</button>
                            <button class="btn btn-success" onclick="capturePhoto('${questionId}')">Capture</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);
                document.getElementById('camera-video').srcObject = stream;

                // Store the stream globally so we can stop it later
                window.currentCameraStream = stream;
            })
            .catch(error => {
                console.error('Error accessing camera:', error);
                showError('Could not access camera. Please check permissions or use Upload Image instead.');
                // Fallback to file input
                document.getElementById(`camera-input-${questionId}`).click();
            });
        }

        function closeCamera() {
            // Stop the camera stream
            if (window.currentCameraStream) {
                window.currentCameraStream.getTracks().forEach(track => track.stop());
                window.currentCameraStream = null;
            }

            // Remove the modal
            const modal = document.querySelector('.camera-modal');
            if (modal) {
                modal.remove();
            }
        }

        function capturePhoto(questionId) {
            const video = document.getElementById('camera-video');
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');

            // Set canvas dimensions to match video
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            // Draw the current video frame to canvas
            context.drawImage(video, 0, 0, canvas.width, canvas.height);

            // Convert canvas to blob
            canvas.toBlob(blob => {
                if (blob) {
                    // Create a file from the blob
                    const file = new File([blob], `camera-capture-${Date.now()}.jpg`, {
                        type: 'image/jpeg'
                    });

                    // Create a mock input element with the captured file
                    const mockInput = {
                        files: [file]
                    };

                    // Close camera and upload the photo
                    closeCamera();
                    handlePhotoUpload(questionId, mockInput);
                } else {
                    showError('Failed to capture photo');
                }
            }, 'image/jpeg', 0.8);
        }

        // Note: Cloudinary ping endpoint doesn't support CORS, so we skip the connection test
        // and go directly to the upload endpoint which does support CORS

        async function handlePhotoUpload(questionId, input) {
            console.log('handlePhotoUpload called with questionId:', questionId, 'type:', typeof questionId);
            console.log('currentStudent:', currentStudent);
            console.log('currentStudent.id:', currentStudent?.id);
            
            // Validate questionId
            if (!questionId || questionId === 'undefined' || questionId === 'null') {
                console.error('Invalid questionId:', questionId);
                showError('Invalid question ID. Please refresh the page and try again.');
                return;
            }
            
            const files = Array.from(input.files);
            if (!files || files.length === 0) {
                console.log('No files selected');
                return;
            }

            console.log('Files selected:', files.length, 'files');

            // Show loading indicator
            showUploadLoading(questionId, files.length);

            try {
                const uploadedUrls = [];
                const cloudName = 'dokomrjyc';
                const uploadPreset = 'ml_default';

                // Upload each file
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    console.log(`Uploading file ${i + 1}/${files.length}:`, file.name, file.type, file.size);

                    const formData = new FormData();
                    formData.append('file', file);
                    formData.append('upload_preset', uploadPreset);
                    formData.append('folder', 'interview-answers');

                    const response = await fetch(`https://api.cloudinary.com/v1_1/${cloudName}/image/upload`, {
                        method: 'POST',
                        body: formData,
                        mode: 'cors'
                    });

                    const result = await response.json();

                    if (response.ok && result.secure_url) {
                        uploadedUrls.push(result.secure_url);
                        console.log(`✅ File ${i + 1} uploaded successfully:`, result.secure_url);
                    } else {
                        console.error(`❌ File ${i + 1} upload failed:`, result);
                        showError(`Failed to upload ${file.name}: ${result.error?.message || 'Unknown error'}`);
                    }
                }

                if (uploadedUrls.length > 0) {
                    // Update the question with all uploaded URLs
                    const currentAnswer = questions.find(q => q.id === questionId)?.student_answer || '';
                    const questionIndex = questions.findIndex(q => q.id == questionId);
                    
                    if (questionIndex !== -1) {
                        // Get existing images and merge with new ones
                        let existingImages = [];
                        const currentPhotoUrl = questions[questionIndex].answer_photo_url;
                        
                        if (currentPhotoUrl) {
                            try {
                                // Try to parse as JSON array first
                                const parsed = JSON.parse(currentPhotoUrl);
                                if (Array.isArray(parsed)) {
                                    existingImages = parsed;
                                } else {
                                    // Single image, convert to array
                                    existingImages = [currentPhotoUrl];
                                }
                            } catch (e) {
                                // Not JSON, treat as single image
                                existingImages = [currentPhotoUrl];
                            }
                        }
                        
                        // Merge existing images with new ones
                        const allImages = [...existingImages, ...uploadedUrls];
                        questions[questionIndex].answer_photo_url = JSON.stringify(allImages);
                        console.log('✅ Updated local question with merged photo URLs:', allImages);
                        console.log('📸 Existing images:', existingImages);
                        console.log('📸 New images:', uploadedUrls);
                    }
                    
                    // Update the database with merged images
                    const finalImages = questions[questionIndex]?.answer_photo_url || JSON.stringify(uploadedUrls);
                    await updateAnswer(questionId, currentAnswer, finalImages);
                    
                    // Hide loading indicator
                    hideUploadLoading(questionId);
                    
                    // Refresh the display
                    await displayQuestions();
                    showSuccess(`${uploadedUrls.length} image(s) uploaded successfully!`);
                } else {
                    hideUploadLoading(questionId);
                    showError('No images were uploaded successfully');
                }

            } catch (error) {
                console.error('Error uploading photos to Cloudinary:', error);
                hideUploadLoading(questionId);
                
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    showError('Network error: Unable to connect to Cloudinary. Please check your internet connection and try again.');
                } else if (error.name === 'NetworkError') {
                    showError('Network error: Please check your internet connection and try again.');
                } else {
                    showError('Error uploading photos to Cloudinary: ' + error.message);
                }
            }
        }

        function showUploadLoading(questionId, fileCount) {
            const questionElement = document.querySelector(`[data-question-id="${questionId}"]`);
            if (!questionElement) return;

            const photoCapture = questionElement.querySelector('.photo-capture');
            if (!photoCapture) return;

            // Create loading indicator
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'upload-loading';
            loadingDiv.id = `upload-loading-${questionId}`;
            loadingDiv.innerHTML = `
                <div class="loading-spinner"></div>
                <span>Uploading ${fileCount} image(s)...</span>
            `;

            // Disable upload buttons
            const uploadBtn = photoCapture.querySelector('.photo-btn');
            if (uploadBtn) uploadBtn.disabled = true;

            photoCapture.appendChild(loadingDiv);
        }

        function hideUploadLoading(questionId) {
            const loadingDiv = document.getElementById(`upload-loading-${questionId}`);
            if (loadingDiv) {
                loadingDiv.remove();
            }

            // Re-enable upload buttons
            const questionElement = document.querySelector(`[data-question-id="${questionId}"]`);
            if (questionElement) {
                const uploadBtn = questionElement.querySelector('.photo-btn');
                if (uploadBtn) uploadBtn.disabled = false;
            }
        }

        async function updateAnswer(questionId, answer, photoUrl = null) {
            try {
                const requestBody = {
                    student_answer: answer
                };
                
                if (photoUrl) {
                    requestBody.answer_photo_url = photoUrl;
                }
                
                const response = await fetch(`/api/interview-questions/${questionId}/answer`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    // Update local questions array
                    const questionIndex = questions.findIndex(q => q.id === questionId);
                    if (questionIndex !== -1) {
                        questions[questionIndex] = result.data;
                    }
                } else {
                    console.error('Error updating answer:', result);
                }
            } catch (error) {
                console.error('Error updating answer:', error);
            }
        }

        async function deletePhoto(questionId, imageIndex = null) {
            try {
                const questionIndex = questions.findIndex(q => q.id == questionId);
                if (questionIndex === -1) {
                    showError('Question not found');
                    return;
                }

                const currentPhotoUrl = questions[questionIndex].answer_photo_url;
                if (!currentPhotoUrl) {
                    showError('No images to delete');
                    return;
                }

                let newPhotoUrl = null;
                let deletedCount = 0;

                try {
                    const photoUrls = JSON.parse(currentPhotoUrl);
                    if (Array.isArray(photoUrls)) {
                        // Multiple images - delete specific one or all
                        if (imageIndex !== null && imageIndex >= 0 && imageIndex < photoUrls.length) {
                            photoUrls.splice(imageIndex, 1);
                            deletedCount = 1;
                            newPhotoUrl = photoUrls.length > 0 ? JSON.stringify(photoUrls) : null;
                        } else {
                            // Delete all images
                            newPhotoUrl = null;
                            deletedCount = photoUrls.length;
                        }
                    } else {
                        // Single image (backward compatibility)
                        newPhotoUrl = null;
                        deletedCount = 1;
                    }
                } catch (e) {
                    // Single image (backward compatibility)
                    newPhotoUrl = null;
                    deletedCount = 1;
                }

                const response = await fetch(`/api/interview-questions/${questionId}/answer`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        student_answer: questions[questionIndex].student_answer || '',
                        answer_photo_url: newPhotoUrl
                    })
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    // Update local questions array
                    questions[questionIndex].answer_photo_url = newPhotoUrl;
                    
                    // Refresh the display
                    await displayQuestions();
                    showSuccess(`${deletedCount} image(s) deleted successfully!`);
                } else {
                    console.error('Error deleting photo:', result);
                    showError('Failed to delete image');
                }
            } catch (error) {
                console.error('Error deleting photo:', error);
                showError('Error deleting image');
            }
        }

        async function saveNotes() {
            if (!currentInterview) return;

            const notes = document.getElementById('interview-notes').value;
            
            // Show loading state
            const saveButton = document.getElementById('save-notes-btn');
            const originalText = saveButton.textContent;
            saveButton.textContent = 'Saving...';
            saveButton.disabled = true;
            
            try {
                const response = await fetch(`/api/interviews/${currentInterview.id}/notes`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        notes: notes
                    })
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    showSuccess('Notes saved successfully!');
                } else {
                    showError('Error saving notes');
                }
            } catch (error) {
                console.error('Error saving notes:', error);
                showError('Error saving notes');
            } finally {
                // Restore button state
                saveButton.textContent = originalText;
                saveButton.disabled = false;
            }
        }

        async function saveInterview() {
            if (!currentInterview) {
                showError('No active interview found');
                return;
            }

            // Show loading state
            const saveButton = document.getElementById('save-interview-btn');
            const originalText = saveButton.textContent;
            saveButton.textContent = 'Saving...';
            saveButton.disabled = true;

            try {
                // Save notes first
                const notes = document.getElementById('interview-notes').value;
                if (notes) {
                    await saveNotes();
                }

                // Save current duration
                if (interviewStartTime) {
                    const currentTime = new Date();
                    const durationSeconds = Math.floor((currentTime - interviewStartTime) / 1000);
                    await updateInterviewDuration(durationSeconds, currentTime);
                    console.log('✅ Interview duration saved:', durationSeconds, 'seconds');
                }

                // Save all current question states (including images)
                if (Array.isArray(questions) && questions.length > 0) {
                    console.log('💾 Saving all question states...');
                    for (const question of questions) {
                        if (question.student_answer || question.answer_photo_url) {
                            await updateAnswer(question.id, question.student_answer, question.answer_photo_url);
                            console.log(`✅ Saved question ${question.id} with answer and images`);
                        }
                    }
                    console.log('✅ All question states saved successfully');
                }

                showSuccess('Interview saved successfully!');
            } catch (error) {
                console.error('Error saving interview:', error);
                showError('Error saving interview');
            } finally {
                // Restore button state
                saveButton.textContent = originalText;
                saveButton.disabled = false;
            }
        }

        async function endInterview() {
            if (!currentInterview) return;

            // Always show confirmation popup first
            const confirmProceed = await (async () => {
                return new Promise((resolve) => {
                    const overlay = document.createElement('div');
                    overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.35);display:flex;align-items:center;justify-content:center;z-index:2000;';
                    overlay.innerHTML = `
                      <div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;min-width:320px;max-width:90%;padding:20px;box-shadow:0 10px 20px rgba(0,0,0,0.15)">
                        <div style="font-weight:600;margin-bottom:8px;color:#111827;font-size:1.1rem">End Interview?</div>
                        <div style="font-size:14px;color:#374151;margin-bottom:16px">Are you sure you want to end this interview? This will mark the interview as completed.</div>
                        <div style="display:flex;gap:8px;justify-content:flex-end">
                          <button id="end-cancel" style="border:1px solid #e5e7eb;background:#fff;padding:8px 16px;border-radius:6px;cursor:pointer;font-size:14px">Cancel</button>
                          <button id="end-confirm" style="background:#dc2626;color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;font-size:14px">End Interview</button>
                        </div>
                      </div>`;
                    document.body.appendChild(overlay);
                    overlay.querySelector('#end-cancel').onclick = ()=> { overlay.remove(); resolve(false); };
                    overlay.querySelector('#end-confirm').onclick = ()=> { overlay.remove(); resolve(true); };
                });
            })();
            
            if (!confirmProceed) return;

            // Require verdict before ending in all cases
            const verdictSelect = document.getElementById('verdict-select');
            if (!verdictSelect || !verdictSelect.value) {
                // Prompt user to choose a verdict
                const overlay = document.createElement('div');
                overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.35);display:flex;align-items:center;justify-content:center;z-index:2000;';
                overlay.innerHTML = `
                  <div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;min-width:280px;max-width:90%;padding:16px;box-shadow:0 10px 20px rgba(0,0,0,0.15)">
                    <div style="font-weight:600;margin-bottom:8px;color:#111827">Select a verdict</div>
                    <div style="font-size:14px;color:#374151;margin-bottom:12px">Please choose a verdict to end the interview.</div>
                    <div style="display:flex;gap:8px;justify-content:flex-end">
                      <button id="verdict-ok" style="background:#111827;color:#fff;border:none;padding:6px 10px;border-radius:6px;cursor:pointer">OK</button>
                    </div>
                  </div>`;
                document.body.appendChild(overlay);
                overlay.querySelector('#verdict-ok').onclick = ()=> { overlay.remove(); verdictSelect?.focus(); };
                return;
            }

            // New behavior when there are no questions
            if (!Array.isArray(questions) || questions.length === 0) {
                const verdictVal = document.getElementById('verdict-select')?.value || '';
                const notesVal = document.getElementById('interview-notes')?.value?.trim() || '';
                if (verdictVal || notesVal) {
                    try {
                        // Stop duration tracking
                        stopDurationTracking();
                        // Save notes if present
                        if (notesVal) {
                            await saveNotes();
                        }
                        // Save verdict if present
                        if (verdictVal && verdictVal !== currentInterview.verdict) {
                            await updateVerdict();
                        }
                        // Mark complete
                        const resp = await fetch(`/api/interviews/${currentInterview.id}/complete`, { method: 'PUT' });
                        const json = await resp.json();
                        if (resp.ok && json.success) {
                            showSuccess('Interview completed successfully!');
                            await loadPreviousInterviews();
                            setTimeout(() => { goBack(); }, 800);
                        } else {
                            showError('Error completing interview');
                        }
                    } catch (err) {
                        console.error('Error completing interview without questions:', err);
                        showError('Error completing interview');
                    }
                } else {
                    // No questions, no verdict, no notes -> cancel
                    try {
                        stopDurationTracking();
                        const response = await fetch(`/api/interviews/${currentInterview.id}`, { method: 'DELETE' });
                        const result = await response.json();
                        if (response.ok && result.success) {
                            showSuccess('Interview cancelled (no questions, verdict, or notes).');
                            setTimeout(() => { goBack(); }, 500);
                        } else {
                            showError('Error cancelling empty interview');
                        }
                    } catch (error) {
                        console.error('Error auto-cancelling empty interview:', error);
                        showError('Error cancelling empty interview');
                    }
                }
                return;
            }

            // Stop duration tracking
            stopDurationTracking();

            try {
                // Save verdict if not already saved
                const verdict = document.getElementById('verdict-select').value;
                if (verdict && verdict !== currentInterview.verdict) {
                    console.log('💾 Saving verdict before completing interview...');
                    await updateVerdict();
                    console.log('✅ Verdict saved before completion');
                }

                // Save all current question states (including images) before completing
                if (Array.isArray(questions) && questions.length > 0) {
                    console.log('💾 Saving all question states before completing interview...');
                    for (const question of questions) {
                        if (question.student_answer || question.answer_photo_url) {
                            await updateAnswer(question.id, question.student_answer, question.answer_photo_url);
                            console.log(`✅ Saved question ${question.id} with answer and images`);
                        }
                    }
                    console.log('✅ All question states saved before completion');
                }

                const response = await fetch(`/api/interviews/${currentInterview.id}/complete`, {
                    method: 'PUT'
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    showSuccess('Interview completed successfully!');
                    // Refresh previous interviews list
                    await loadPreviousInterviews();
                    setTimeout(() => { goBack(); }, 1000);
                } else {
                    showError('Error completing interview');
                }
            } catch (error) {
                console.error('Error completing interview:', error);
                showError('Error completing interview');
            }
        }

        async function cancelInterview() {
            if (!currentInterview) return;

            // Show confirmation dialog
            const proceed = await (async () => {
                return new Promise((resolve) => {
                    const overlay = document.createElement('div');
                    overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.35);display:flex;align-items:center;justify-content:center;z-index:2000;';
                    overlay.innerHTML = `
                        <div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;min-width:320px;max-width:90%;padding:20px;box-shadow:0 10px 20px rgba(0,0,0,0.15)">
                            <div style="font-weight:600;margin-bottom:8px;color:#111827;font-size:1.1rem">Cancel Interview?</div>
                            <div style="font-size:14px;color:#374151;margin-bottom:16px">Are you sure you want to cancel this interview? All progress will be lost and the interview will not be saved.</div>
                            <div style="display:flex;gap:8px;justify-content:flex-end">
                                <button id="cancel-cancel" style="border:1px solid #e5e7eb;background:#fff;padding:8px 16px;border-radius:6px;cursor:pointer">Keep Interview</button>
                                <button id="cancel-confirm" style="background:#d97706;color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer">Cancel Interview</button>
                            </div>
                        </div>`;
                    document.body.appendChild(overlay);
                    overlay.querySelector('#cancel-cancel').onclick = ()=> { overlay.remove(); resolve(false); };
                    overlay.querySelector('#cancel-confirm').onclick = ()=> { overlay.remove(); resolve(true); };
                });
            })();
            
            if (!proceed) return;

            try {
                // Stop duration tracking
                stopDurationTracking();

                // Delete the interview from the database
                const response = await fetch(`/api/interviews/${currentInterview.id}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    showSuccess('Interview cancelled successfully!');
                    setTimeout(() => { goBack(); }, 1000);
                } else {
                    showError('Error cancelling interview');
                }
            } catch (error) {
                console.error('Error cancelling interview:', error);
                showError('Error cancelling interview');
            }
        }
            
        function goBack() {
            const isAdmin = userRole === 'admin' || userRole === 'superadmin';
            const params = new URLSearchParams(window.location.search);
            const email = params.get('email') || '';
            const name = params.get('name') || '';
            const qs = `?tab=my-interviews${email?`&email=${encodeURIComponent(email)}`:''}${name?`&name=${encodeURIComponent(name)}`:''}`;
            window.location.href = isAdmin ? `/admin-dashboard.html${qs}` : `/interviewer-dashboard.html${qs}`;
        }

        function showError(message) {
            // Remove existing messages
            const existingError = document.querySelector('.error');
            if (existingError) existingError.remove();
            
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            document.querySelector('.interview-main').insertBefore(errorDiv, document.querySelector('.chat-container'));
            
            setTimeout(() => errorDiv.remove(), 5000);
        }

        function showSuccess(message) {
            // Remove existing messages
            const existingSuccess = document.querySelector('.success');
            if (existingSuccess) existingSuccess.remove();
            
            const successDiv = document.createElement('div');
            successDiv.className = 'success';
            successDiv.textContent = message;
            document.querySelector('.interview-main').insertBefore(successDiv, document.querySelector('.chat-container'));
            
            setTimeout(() => successDiv.remove(), 3000);
        }

        // Question Bank Functions
        let questionBankData = [];
        let currentCategory = '';
        let panelQuestionBankData = [];
        let panelCurrentCategory = '';

        // Test function for debugging
        window.testQuestionBank = function() {
            console.log('Testing question bank functionality...');
            switchQuestionSource('bank');
        };

        // Additional test functions
        window.testLoadQuestions = function() {
            console.log('Testing loadQuestionBankData...');
            loadQuestionBankData();
        };

        window.testDisplayQuestions = function() {
            console.log('Testing displayQuestionBankList...');
            displayQuestionBankList([{id: 1, question: 'Test question', category: 'Test', times_asked: 0}]);
        };

        function toggleQuestion(questionId) {
            console.log('toggleQuestion called with questionId:', questionId);
            console.log('Current questions array:', questions.map(q => ({ id: q.id, text: q.question_text?.substring(0, 50) })));
            
            // Validate that the question exists in our data
            const questionExists = questions.some(q => q.id == questionId);
            if (!questionExists) {
                console.error('Question ID not found in current questions array:', questionId);
                console.error('Available question IDs:', questions.map(q => q.id));
                return;
            }
            
            // Try to find elements with retry mechanism
            const tryToggle = (retryCount = 0) => {
                const questionItem = document.querySelector(`[data-question-id="${questionId}"]`);
                
                if (!questionItem) {
                    if (retryCount < 5) {
                        console.log(`Question item not found for ID: ${questionId}, retrying... (${retryCount + 1}/5)`);
                        console.log('Available question items in DOM:', Array.from(document.querySelectorAll('[data-question-id]')).map(el => el.getAttribute('data-question-id')));
                        setTimeout(() => tryToggle(retryCount + 1), 200);
                        return;
                    }
                    console.error('Question item not found for ID:', questionId);
                    console.error('Available question items in DOM:', Array.from(document.querySelectorAll('[data-question-id]')).map(el => el.getAttribute('data-question-id')));
                    console.error('Current questions array:', questions.map(q => ({ id: q.id, text: q.question_text?.substring(0, 50) })));
                    return;
                }
                
                const header = questionItem.querySelector('.question-header');
                const content = questionItem.querySelector('.question-content');
                
                if (!content) {
                    if (retryCount < 5) {
                        console.log(`Question content not found for ID: ${questionId}, retrying... (${retryCount + 1}/5)`);
                        console.log('Question item found but content missing:', questionItem);
                        setTimeout(() => tryToggle(retryCount + 1), 200);
                        return;
                    }
                    console.error('Question content not found for ID:', questionId);
                    console.error('Question item HTML:', questionItem.outerHTML);
                    return;
                }
                
                if (!header) {
                    if (retryCount < 5) {
                        console.log(`Question header not found for ID: ${questionId}, retrying... (${retryCount + 1}/5)`);
                        console.log('Question item found but header missing:', questionItem);
                        setTimeout(() => tryToggle(retryCount + 1), 200);
                        return;
                    }
                    console.error('Question header not found for ID:', questionId);
                    console.error('Question item HTML:', questionItem.outerHTML);
                    return;
                }
                
                // All elements found, proceed with toggle
                if (content.classList.contains('expanded')) {
                    // Collapse
                    content.classList.remove('expanded');
                    header.classList.remove('expanded');
                    questionItem.classList.remove('expanded');
                    console.log('Question collapsed:', questionId);
                } else {
                    // Expand
                    content.classList.add('expanded');
                    header.classList.add('expanded');
                    questionItem.classList.add('expanded');
                    console.log('Question expanded:', questionId);
                }
            };
            
            tryToggle();
        }

        function switchQuestionSource(source) {
            console.log('switchQuestionSource called with:', source);
            
            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            const activeBtn = document.querySelector(`[onclick="switchQuestionSource('${source}')"]`);
            if (activeBtn) {
                activeBtn.classList.add('active');
            } else {
                console.error('Could not find tab button for source:', source);
            }
            
            // Update tab content
            document.querySelectorAll('.question-tab').forEach(tab => tab.classList.remove('active'));
            let activeTab;
            if (source === 'bank') {
                activeTab = document.getElementById('question-bank-tab');
            } else {
                activeTab = document.getElementById(`${source}-question-tab`);
            }
            if (activeTab) {
                activeTab.classList.add('active');
                console.log('Activated tab:', activeTab.id);
            } else {
                console.error('Could not find tab for source:', source);
            }
            
            // Load question bank data if switching to bank tab
            if (source === 'bank' && questionBankData.length === 0) {
                console.log('Loading question bank data...');
                loadQuestionBankData();
            } else if (source === 'bank') {
                console.log('Question bank data already loaded, displaying...');
                displayQuestionBankList(questionBankData);
            }
        }


        async function loadQuestionBankData() {
            console.log('🔍 loadQuestionBankData called');
            try {
                // Load categories
                console.log('📂 Fetching categories...');
                const categoriesResponse = await fetch('/api/question-bank/categories');
                console.log('📂 Categories response status:', categoriesResponse.status);
                
                if (!categoriesResponse.ok) {
                    throw new Error(`HTTP ${categoriesResponse.status}: ${categoriesResponse.statusText}`);
                }
                
                const categoriesResult = await categoriesResponse.json();
                console.log('📂 Categories result:', categoriesResult);
                
                if (categoriesResult.success) {
                    const categorySelect = document.getElementById('bank-category-select');
                    if (categorySelect) {
                        categorySelect.innerHTML = '<option value="">All Categories</option>';
                        // Add Favorites option
                        const favoritesOption = document.createElement('option');
                        favoritesOption.value = 'Favorites';
                        favoritesOption.textContent = 'My Favorites';
                        categorySelect.appendChild(favoritesOption);
                        
                        // Add all categories
                        categoriesResult.data.forEach(category => {
                            const option = document.createElement('option');
                            option.value = category.category;
                            option.textContent = `${category.category} (${category.question_count})`;
                            categorySelect.appendChild(option);
                        });
                        console.log('✅ Categories loaded into dropdown');
                    } else {
                        console.error('❌ Category select element not found');
                    }
                } else {
                    console.error('❌ Failed to load categories:', categoriesResult.error);
                }
                
                // Load all questions
                console.log('❓ Fetching questions...');
                const questionsResponse = await fetch('/api/question-bank');
                console.log('❓ Questions response status:', questionsResponse.status);
                
                if (!questionsResponse.ok) {
                    throw new Error(`HTTP ${questionsResponse.status}: ${questionsResponse.statusText}`);
                }
                
                const questionsResult = await questionsResponse.json();
                console.log('❓ Questions result:', questionsResult);
                
                if (questionsResult.success) {
                    questionBankData = questionsResult.data;
                    console.log('Question bank data loaded:', questionBankData.length, 'questions');
                    // Mark interview questions as from bank if matches
                    try{
                        const bankSet = new Set((questionBankData||[]).map(b=> (b.question||'').trim().toLowerCase()));
                        questions = (questions||[]).map(q=>{
                            const key = (q.question_text||'').trim().toLowerCase();
                            return { ...q, __fromBank: bankSet.has(key) };
                        });
                        await displayQuestions();
                    }catch(e){ console.warn('Bank sync marking failed', e); }
                    displayQuestionBankList(questionBankData);
                } else {
                    console.error('Failed to load questions:', questionsResult.error);
                }
            } catch (error) {
                console.error('Error loading question bank data:', error);
                showError('Error loading question bank');
            }
        }

        async function loadQuestionsByCategory() {
            const selectEl = document.getElementById('bank-category-select');
            if (!selectEl) return;
            const category = selectEl.value;
            try {
                let data = [];
                if (!category) {
                    // All
                    data = questionBankData || [];
                } else if (category === 'Favorites') {
                    const email = (JSON.parse(localStorage.getItem('bees_user_data') || '{}')?.email) || '';
                    const res = await fetch(`/api/interviewer/favorites${email ? `?email=${encodeURIComponent(email)}` : ''}`);
                    const json = await res.json();
                    if (json.success) {
                        data = (json.data || []).map(f => ({
                            id: f.id || f.question_id,
                            question: f.question,
                            question_text: f.question,
                            category: f.category,
                            times_asked: f.times_asked ?? 0
                        }));
                    }
                } else {
                    const res = await fetch(`/api/question-bank/category/${encodeURIComponent(category)}`);
                    const json = await res.json();
                    if (json.success) data = json.data || [];
                    console.log('[Panel] Questions by category =', data.length);
                    console.log('[Panel] Questions by category =', JSON.stringify(data.slice(0,3), null, 2));
                }
                displayQuestionBankList(data);
            } catch (error) {
                console.error('Error loading questions by category:', error);
                showError('Error loading questions');
            }
        }

        async function searchQuestions() {
            const searchTerm = document.getElementById('bank-search-input').value.trim();
            if (!searchTerm) {
                displayQuestionBankList(questionBankData);
                return;
            }
            
            try {
                const response = await fetch(`/api/question-bank/search?q=${encodeURIComponent(searchTerm)}`);
                const result = await response.json();
                
                if (result.success) {
                    displayQuestionBankList(result.data);
                }
            } catch (error) {
                console.error('Error searching questions:', error);
                showError('Error searching questions');
            }
        }

        function displayQuestionBankList(questions) {
            console.log('displayQuestionBankList called with:', questions);
            const listContainer = document.getElementById('question-bank-list');
            
            if (!listContainer) {
                console.error('Question bank list container not found');
                return;
            }
            
            if (questions.length === 0) {
                console.log('No questions to display');
                listContainer.innerHTML = '<div class="loading">No questions found</div>';
                return;
            }
            
            console.log('Displaying', questions.length, 'questions');
            listContainer.innerHTML = questions.map(question => {
                const qText = (question.question || question.question_text || '').toString();
                const escapedQuestion = qText.replace(/'/g, "\\'").replace(/"/g, '\\"').replace(/\n/g, '\\n');
                return `
                <div class="question-bank-item" data-question-id="${question.id}" data-question-text="${escapedQuestion}">
                    <div class="question-text">${qText}</div>
                    <div class="question-meta">
                        <span class="question-category">${question.category || 'Uncategorized'}</span>
                        <span class="question-times-asked">Asked ${(question.times_asked ?? question.count_of_times_asked ?? 0)} times</span>
                    </div>
                </div>
            `;
            }).join('');
            console.log('Question bank list updated in DOM');
            
            // Add event delegation for question bank items
            setupQuestionBankEventDelegation();
        }
        
        // Setup event delegation for question bank clicks
        function setupQuestionBankEventDelegation() {
            const listContainer = document.getElementById('question-bank-list');
            if (!listContainer) return;
            
            // Remove any existing listeners
            listContainer.removeEventListener('click', handleQuestionBankClick);
            
            // Add single delegated event listener
            listContainer.addEventListener('click', handleQuestionBankClick);
        }
        
        // Handle question bank item clicks with debouncing
        function handleQuestionBankClick(event) {
            const questionItem = event.target.closest('.question-bank-item');
            if (!questionItem) return;
            
            // Prevent event propagation
            event.preventDefault();
            event.stopPropagation();
            
            // Check if already processing
            if (questionItem.dataset.processing === 'true') {
                console.log('🚫 Question item already processing, ignoring click');
                return;
            }
            
            // Mark as processing immediately
            questionItem.dataset.processing = 'true';
            questionItem.style.pointerEvents = 'none';
            questionItem.style.opacity = '0.6';
            
            const questionId = questionItem.dataset.questionId;
            const questionText = questionItem.dataset.questionText;
            
            // Call the function
            selectQuestionFromBank(questionId, questionText, questionItem);
        }

        // Track questions being added to prevent duplicates
        const questionsBeingAdded = new Set();
        
        // Helper function to reset question item state
        function resetQuestionItem(el) {
            if (el) {
                el.dataset.processing = 'false';
                el.style.pointerEvents = '';
                el.style.opacity = '';
                
                // Restore original HTML if available
                const originalHtml = el.getAttribute('data-original-html');
                if (originalHtml) {
                    el.innerHTML = originalHtml;
                    el.removeAttribute('data-original-html');
                }
            }
        }

        async function selectQuestionFromBank(questionId, questionText, el) {
            console.log('🔍 selectQuestionFromBank called with:', { 
                questionId, 
                questionText, 
                questionTextType: typeof questionText,
                currentInterview: currentInterview?.id,
                elementProcessing: el?.dataset?.processing
            });
            
            if (!currentInterview) {
                console.error('❌ No current interview found');
                showError('No active interview found. Please start an interview first.');
                resetQuestionItem(el);
                return;
            }
            
            // Validate questionText
            if (!questionText || questionText.trim() === '') {
                console.error('❌ Invalid question text:', questionText);
                showError('Invalid question text. Please try again.');
                resetQuestionItem(el);
                return;
            }
            
            const normalizedQuestionText = questionText.trim().toLowerCase();
            
            // Check if this question is currently being added
            if (questionsBeingAdded.has(normalizedQuestionText)) {
                console.log('⏸️ Question already being added, ignoring duplicate request');
                showError('This question is already being added. Please wait...');
                return; // Keep disabled
            }
            
            // Check for duplicate questions in current interview
            const isDuplicate = questions.some(q => 
                q.question_text && q.question_text.trim().toLowerCase() === normalizedQuestionText
            );
            
            if (isDuplicate) {
                console.log('⚠️ Duplicate question detected');
                showError('This question has already been added to the interview. Please select a different question.');
                resetQuestionItem(el);
                return;
            }
            
            // Mark this question as being added
            questionsBeingAdded.add(normalizedQuestionText);
            
            try {
                // Show inline loading on clicked item
                if (el) {
                    const originalHtml = el.innerHTML;
                    el.setAttribute('data-original-html', originalHtml);
                    el.innerHTML = '<div class="question-text">Adding...</div><div class="question-meta">Please wait</div>';
                }
                // Add the question to the current interview
                console.log('📤 Sending request to add question to interview:', currentInterview.id);
                const response = await fetch(`/api/interviews/${currentInterview.id}/questions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        question_text: questionText
                    })
                });
                
                console.log('📥 Response status:', response.status);
                const result = await response.json();
                console.log('📥 Response result:', result);
                
                if (!response.ok) {
                    console.error('❌ HTTP Error:', response.status, response.statusText);
                }
                
                if (result.success) {
                    console.log('✅ Question added successfully, proceeding with increment...');
                    
                    // Increment the times asked counter (don't fail if this doesn't work)
                    try {
                        console.log('📤 Attempting to increment times asked for question:', questionId);
                        const incrementResponse = await fetch(`/api/question-bank/${questionId}/increment`, {
                            method: 'POST'
                        });
                        const incrementResult = await incrementResponse.json();
                        console.log('📥 Increment response:', incrementResult);
                        
                        if (!incrementResponse.ok) {
                            console.warn('⚠️ Increment failed but question was added:', incrementResult);
                        }
                    } catch (incrementError) {
                        console.warn('⚠️ Failed to increment times asked:', incrementError);
                        // Don't show error to user, question was added successfully
                    }
                    
                    console.log('🔄 Reloading questions from server...');
                    // Reload questions from server to get the latest state for this specific interview
                    await loadQuestions();
                    console.log('✅ Questions reloaded, showing success message');
                    showSuccess('Question added successfully');
                    
                    // Collapse question bank back to normal height
                    collapseQuestionBank();
                    
                    // Switch back to custom question tab
                    switchQuestionSource('custom');
                } else {
                    console.error('❌ Error adding question from bank:', result);
                    showError('Error adding question from bank');
                }
            } catch (error) {
                console.error('Error adding question from bank:', error);
                showError('Error adding question');
            } finally {
                // Always remove from tracking set
                questionsBeingAdded.delete(normalizedQuestionText);
                
                // Reset question item state
                resetQuestionItem(el);
            }
        }

        // Resize functionality for question bank
        let isResizing = false;
        let startY = 0;
        let startHeight = 0;

        function startResize(e) {
            isResizing = true;
            startY = e.clientY;
            const questionBankList = document.getElementById('question-bank-list');
            startHeight = questionBankList.offsetHeight;
            
            document.addEventListener('mousemove', doResize);
            document.addEventListener('mouseup', stopResize);
            e.preventDefault();
        }

        function doResize(e) {
            if (!isResizing) return;
            
            const questionBankList = document.getElementById('question-bank-list');
            const newHeight = startHeight + (e.clientY - startY);
            const minHeight = 200;
            const maxHeight = 600;
            
            if (newHeight >= minHeight && newHeight <= maxHeight) {
                questionBankList.style.maxHeight = newHeight + 'px';
                questionBankList.classList.add('expanded');
            }
        }

        function stopResize() {
            isResizing = false;
            document.removeEventListener('mousemove', doResize);
            document.removeEventListener('mouseup', stopResize);
        }

        function collapseQuestionBank() {
            const questionBankList = document.getElementById('question-bank-list');
            questionBankList.style.maxHeight = '300px';
            questionBankList.classList.remove('expanded');
        }

        // Delete question functionality
        async function deleteQuestion(questionId) {
            if (!confirm('Are you sure you want to delete this question? This action cannot be undone.')) {
                return;
            }

            try {
                const response = await fetch(`/api/interview-questions/${questionId}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Remove from local questions array
                    questions = questions.filter(q => q.id !== questionId);
                    
                    // Refresh the display
                    await displayQuestions();
                    showSuccess('Question deleted successfully');
                } else {
                    showError('Error deleting question');
                }
            } catch (error) {
                console.error('Error deleting question:', error);
                showError('Error deleting question');
            }
        }

        // Edit question text
        const questionEditEditors = {}; // Store editors per question ID
        async function editQuestionText(questionId) {
            const question = questions.find(q => q.id === questionId);
            if (!question) {
                showError('Question not found');
                return;
            }

            const displayDiv = document.getElementById(`question-text-display-${questionId}`);
            if (!displayDiv) {
                showError('Question display element not found');
                return;
            }

            // Check if editor already exists - if so, remove it first to prevent duplication
            const existingEditor = document.getElementById(`question-editor-${questionId}`);
            if (existingEditor) {
                existingEditor.remove();
                delete questionEditEditors[questionId];
            }

            // Get current question content
            const currentContent = question.question_rich_content || question.question_text || '';

            // Create editor container
            const editorContainer = document.createElement('div');
            editorContainer.id = `question-editor-${questionId}`;
            editorContainer.style.cssText = 'margin-bottom: 0.5rem;';
            
            // Create Quill editor
            const editorDiv = document.createElement('div');
            editorDiv.id = `question-quill-editor-${questionId}`;
            editorDiv.style.cssText = 'background: white; border: 1px solid #d1d5db; border-radius: 4px; min-height: 150px;';
            
            editorContainer.appendChild(editorDiv);
            
            // Create action buttons
            const actionsDiv = document.createElement('div');
            actionsDiv.style.cssText = 'display: flex; gap: 0.5rem; margin-top: 0.5rem;';
            actionsDiv.innerHTML = `
                <button class="btn btn-primary" onclick="saveQuestionText(${questionId})" style="padding: 0.5rem 1rem; font-size: 0.875rem;">Save</button>
                <button class="btn btn-secondary" onclick="cancelQuestionTextEdit(${questionId})" style="padding: 0.5rem 1rem; font-size: 0.875rem;">Cancel</button>
            `;
            editorContainer.appendChild(actionsDiv);

            // Replace display with editor
            displayDiv.style.display = 'none';
            displayDiv.parentElement.appendChild(editorContainer);

            // Initialize Quill editor
            const editor = new Quill(`#question-quill-editor-${questionId}`, {
                theme: 'snow',
                modules: {
                    toolbar: [
                        [{ 'header': [1, 2, 3, false] }],
                        ['bold', 'italic', 'underline', 'strike'],
                        [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                        ['link', 'image'],
                        ['clean']
                    ]
                }
            });

            // Store editor per question ID
            questionEditEditors[questionId] = editor;

            // Set initial content
            editor.root.innerHTML = currentContent;
            editor.focus();
        }

        // Save question text
        async function saveQuestionText(questionId) {
            const editor = questionEditEditors[questionId];
            if (!editor) {
                showError('Editor not found');
                return;
            }

            const newContent = editor.root.innerHTML;
            
            try {
                const response = await fetch(`/api/interview-questions/${questionId}/text`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        question_text: newContent
                    })
                });

                const result = await response.json();

                if (result.success) {
                    // Update local question data
                    const question = questions.find(q => q.id === questionId);
                    if (question) {
                        question.question_text = newContent;
                        question.question_rich_content = newContent;
                    }

                    // Refresh display
                    await displayQuestions();
                    showSuccess('Question updated successfully');
                } else {
                    showError(result.error || 'Error updating question');
                }
            } catch (error) {
                console.error('Error updating question:', error);
                showError('Error updating question');
            } finally {
                // Clean up editor
                delete questionEditEditors[questionId];
            }
        }

        // Cancel question text edit
        function cancelQuestionTextEdit(questionId) {
            const editorContainer = document.getElementById(`question-editor-${questionId}`);
            if (editorContainer) {
                editorContainer.remove();
            }
            
            const displayDiv = document.getElementById(`question-text-display-${questionId}`);
            if (displayDiv) {
                displayDiv.style.display = 'block';
            }
            
            // Clean up editor
            delete questionEditEditors[questionId];
        }

        // Update score display as user moves slider
        function updateScoreDisplay(questionId, score) {
            const scoreDisplay = document.getElementById(`score-value-${questionId}`);
            if (scoreDisplay) {
                scoreDisplay.textContent = score;
            }
            const slider = document.getElementById(`slider-${questionId}`);
            if (slider) {
                slider.classList.add('scored');
            }
        }

        // Mark question with score (0-10)
        async function markQuestionScore(questionId, score) {
            try {
                // Parse score and validate
                const parsedScore = parseInt(score);
                console.log('📊 Marking question score:', { questionId, originalScore: score, parsedScore, type: typeof parsedScore });
                
                const response = await fetch(`/api/interview-questions/${questionId}/score`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        correctness_score: parsedScore
                    })
                });
                
                console.log('📥 Response status:', response.status, 'OK:', response.ok);
                
                let result;
                try {
                    result = await response.json();
                    console.log('📥 Response data:', result);
                } catch (jsonError) {
                    console.error('❌ Failed to parse JSON response:', jsonError);
                    throw new Error('Invalid response from server');
                }
                
                // Check both response.ok and result.success
                if (response.ok && result.success) {
                    // Update local questions array
                    const questionIndex = questions.findIndex(q => q.id === questionId);
                    if (questionIndex !== -1) {
                        questions[questionIndex].correctness_score = parsedScore;
                    }
                    
                    // Refresh the display
                    await displayQuestions();
                    
                    // Update total score
                    updateTotalScore();
                    
                    showSuccess(`Question scored: ${parsedScore}/10`);
                } else {
                    console.error('❌ Server returned error:', {
                        status: response.status,
                        ok: response.ok,
                        success: result.success,
                        error: result.error
                    });
                    showError(`Error: ${result.error || 'Error updating question score'}`);
                }
            } catch (error) {
                console.error('❌ Error updating question score:', error);
                console.error('❌ Error details:', { message: error.message, stack: error.stack });
                showError('Error updating question score: ' + error.message);
            }
        }

        function updateTotalScore() {
            // Calculate total score from all questions
            let totalScore = 0;
            let maxScore = 0;
            let scoredCount = 0;
            
            questions.forEach(question => {
                maxScore += 10; // Each question is out of 10
                if (question.correctness_score !== null && question.correctness_score !== undefined) {
                    totalScore += parseInt(question.correctness_score) || 0;
                    scoredCount++;
                }
            });
            
            // Update the display
            document.getElementById('total-score-value').textContent = totalScore;
            document.getElementById('max-score-value').textContent = maxScore;
            
            // Update breakdown text
            const totalQuestions = questions.length;
            let breakdownText = `${scoredCount} of ${totalQuestions} question${totalQuestions !== 1 ? 's' : ''} scored`;
            
            if (scoredCount > 0 && totalQuestions > 0) {
                const percentage = ((totalScore / maxScore) * 100).toFixed(1);
                breakdownText += ` • ${percentage}% overall`;
            }
            
            document.getElementById('score-breakdown').textContent = breakdownText;
        }

        // Add to Question Bank Functions
        function addToQuestionBank() {
            const questionText = questionEditor.getText().trim();
            
            if (!questionText) {
                showError('Please enter a question first');
                return;
            }
            
            // Show the modal with the question text (plain text only for question bank)
            document.getElementById('modal-question-text').value = questionText;
            document.getElementById('modal-category-select').value = '';
            document.getElementById('custom-category').value = '';
            document.getElementById('custom-category-group').style.display = 'none';
            document.getElementById('category-modal').style.display = 'flex';
        }

        function addQuestionToBank(questionText) {
            // Show the modal with the question text
            document.getElementById('modal-question-text').value = questionText;
            document.getElementById('modal-tags').value = '';
            document.getElementById('category-modal').style.display = 'flex';
        }

        function addQuestionToBankById(questionId) {
            // Find the question by ID
            const question = questions.find(q => q.id === questionId);
            if (!question) {
                showError('Question not found');
                return;
            }
            
            // Use the rich content if available, otherwise use question_text
            const questionContent = question.question_rich_content || question.question_text || '';
            
            // Show the modal with the question content
            document.getElementById('modal-question-text').value = questionContent;
            document.getElementById('modal-tags').value = question.tags ? (Array.isArray(question.tags) ? question.tags.join(', ') : question.tags) : '';
            document.getElementById('category-modal').style.display = 'flex';
        }

        function closeCategoryModal() {
            document.getElementById('category-modal').style.display = 'none';
        }

        async function saveToQuestionBank() {
            const questionText = document.getElementById('modal-question-text')?.value?.trim();
            const tagsInput = document.getElementById('modal-tags')?.value?.trim();
            
            if (!questionText) {
                showError('Question text is required');
                return;
            }
            
            // Convert tags string to array
            const tags = tagsInput ? tagsInput.split(',').map(tag => tag.trim()).filter(tag => tag) : [];
            
            // Show loading state
            const saveBtn = document.querySelector('#category-modal button[onclick="saveToQuestionBank()"]');
            if (saveBtn) {
                saveBtn.disabled = true;
                const originalText = saveBtn.innerHTML;
                saveBtn.innerHTML = '<span class="loading-spinner" style="display: inline-block; width: 12px; height: 12px; border: 2px solid #ffffff; border-top: 2px solid transparent; border-radius: 50%; animation: spin 1s linear infinite; margin-right: 0.5rem;"></span> Saving...';
                
                try {
                    const response = await fetch('/api/question-bank', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            question: questionText,
                            tags: tags,
                            category: null // Using tags instead of category
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (!response.ok || !result.success) {
                        throw new Error(result.error || 'Failed to add question to bank');
                    }
                    
                    // Success - show message
                    showSuccess('Question added to question bank successfully');
                    
                    // Close modal if it exists
                    const modal = document.getElementById('category-modal');
                    if (modal) modal.style.display = 'none';
                    
                    // Clear the question textarea if it exists
                    const newQuestionField = document.getElementById('new-question');
                    if (newQuestionField) newQuestionField.value = '';
                    
                    // Refresh question bank data
                    await loadQuestionBankData();
                    
                    // Re-display questions to update button visibility
                    await displayQuestions();
                    
                } catch (error) {
                    console.error('Error adding question to bank:', error);
                    showError(error.message || 'Error adding question to bank');
                } finally {
                    // Restore button state
                    if (saveBtn) {
                        saveBtn.disabled = false;
                        saveBtn.innerHTML = originalText;
                    }
                }
            } else {
                // Fallback if button not found
                try {
                    const response = await fetch('/api/question-bank', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            question: questionText,
                            tags: tags,
                            category: null
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (!response.ok || !result.success) {
                        throw new Error(result.error || 'Failed to add question to bank');
                    }
                    
                    showSuccess('Question added to question bank successfully');
                    const modal = document.getElementById('category-modal');
                    if (modal) modal.style.display = 'none';
                    const newQuestionField = document.getElementById('new-question');
                    if (newQuestionField) newQuestionField.value = '';
                    await loadQuestionBankData();
                    await displayQuestions();
                } catch (error) {
                    console.error('Error adding question to bank:', error);
                    showError(error.message || 'Error adding question to bank');
                }
            }
        }

        // Side Panel Functions
        function openCustomQuestionPanel() {
            const panel = document.getElementById('custom-question-panel');
            const overlay = document.getElementById('panel-overlay');
            
            closeAllPanels(); // Close any open panels first
            
            panel.classList.add('active');
            overlay.classList.add('active');
            
            // Initialize custom question editor
            initializeCustomQuestionEditor();
        }

        function openAIQuestionPanel() {
            const panel = document.getElementById('ai-question-panel');
            const overlay = document.getElementById('panel-overlay');
            
            closeAllPanels(); // Close any open panels first
            
            panel.classList.add('active');
            overlay.classList.add('active');
        }

        function closeSidePanel(panelId) {
            const panel = document.getElementById(panelId);
            const overlay = document.getElementById('panel-overlay');
            
            if (panel) panel.classList.remove('active');
            if (overlay) overlay.classList.remove('active');
        }

        function closeAllPanels() {
            const panels = document.querySelectorAll('.side-panel');
            const overlay = document.getElementById('panel-overlay');
            
            panels.forEach(panel => panel.classList.remove('active'));
            if (overlay) overlay.classList.remove('active');
            
            // Also close question bank panel if open
            const questionBankPanel = document.getElementById('question-bank-panel');
            const questionBankOverlay = document.getElementById('question-bank-overlay');
            if (questionBankPanel) questionBankPanel.classList.remove('open');
            if (questionBankOverlay) questionBankOverlay.classList.remove('active');
        }

        // Custom Question Editor Functions
        let customQuestionEditor = null;
        let aiQuestionEditor = null;

        function initializeCustomQuestionEditor() {
            if (!customQuestionEditor) {
                const container = document.getElementById('custom-question-editor');
                if (container) {
                    customQuestionEditor = new Quill(container, {
                        theme: 'snow',
                        modules: {
                            toolbar: [
                                [{ 'header': [1, 2, false] }],
                                ['bold', 'italic', 'underline'],
                                ['image', 'code-block'],
                                [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                                ['clean']
                            ]
                        }
                    });
                }
            }
        }

        function initializeAIQuestionEditor() {
            if (!aiQuestionEditor) {
                const container = document.getElementById('ai-question-editor');
                if (container) {
                    aiQuestionEditor = new Quill(container, {
                        theme: 'snow',
                        modules: {
                            toolbar: [
                                [{ 'header': [1, 2, false] }],
                                ['bold', 'italic', 'underline'],
                                ['image', 'code-block'],
                                [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                                ['clean']
                            ]
                        }
                    });
                }
            }
        }

        // Add Custom Question Function
        async function addCustomQuestion() {
            if (!customQuestionEditor) {
                showError('Editor not initialized');
                return;
            }

            const questionText = customQuestionEditor.getText().trim();
            const questionHtml = customQuestionEditor.root.innerHTML;

            if (!questionText) {
                showError('Please enter a question');
                return;
            }

            // Show loading state
            const addBtn = document.getElementById('add-custom-question-btn');
            if (addBtn) {
                addBtn.disabled = true;
                const originalText = addBtn.innerHTML;
                addBtn.innerHTML = '<span class="loading-spinner" style="display: inline-block; width: 12px; height: 12px; border: 2px solid #ffffff; border-top: 2px solid transparent; border-radius: 50%; animation: spin 1s linear infinite; margin-right: 0.5rem;"></span> Adding...';
                
                try {
                    // Add question to current interview
                    await addQuestionToInterview(questionHtml, []);
                    
                    // Clear the form
                    customQuestionEditor.setText('');
                    
                    // Close panel
                    closeSidePanel('custom-question-panel');
                } finally {
                    // Restore button state
                    addBtn.disabled = false;
                    addBtn.innerHTML = originalText;
                }
            } else {
                // Fallback if button not found
                await addQuestionToInterview(questionHtml, []);
                customQuestionEditor.setText('');
                closeSidePanel('custom-question-panel');
            }
        }

        // AI Question Generation Functions
        async function generateAIQuestion() {
            const tagsInput = document.getElementById('ai-question-tags');
            const difficultySelect = document.getElementById('ai-difficulty-level');
            const generateBtn = document.getElementById('generate-ai-btn');
            
            const tags = tagsInput.value.trim();
            const difficulty = difficultySelect.value;
            
            if (!tags) {
                showError('Please enter tags for AI generation');
                tagsInput.focus();
                return;
            }

            // Show loading state
            generateBtn.disabled = true;
            const originalText = generateBtn.innerHTML;
            generateBtn.innerHTML = '<span class="loading-spinner" style="display: inline-block; width: 12px; height: 12px; border: 2px solid #ffffff; border-top: 2px solid transparent; border-radius: 50%; animation: spin 1s linear infinite; margin-right: 0.5rem;"></span> Generating...';

            try {
                const response = await fetch('/api/generate-ai-question', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        tags: tags.split(',').map(t => t.trim()),
                        difficulty: difficulty
                    })
                });

                const result = await response.json();

                if (result.success) {
                    // Initialize AI editor if not done already
                    initializeAIQuestionEditor();
                    
                    // Parse markdown to HTML
                    let htmlContent = result.question;
                    if (typeof marked !== 'undefined') {
                        try {
                            // Configure marked for better rendering
                            marked.setOptions({
                                breaks: true,
                                gfm: true,
                                headerIds: false,
                                mangle: false
                            });
                            htmlContent = marked.parse(result.question);
                        } catch (e) {
                            console.warn('Markdown parsing failed, using raw content:', e);
                        }
                    }
                    
                    // Clear previous content and set the generated question
                    if (aiQuestionEditor) {
                        aiQuestionEditor.root.innerHTML = htmlContent;
                    }
                    
                    // Show the generated question section
                    document.getElementById('ai-generated-question').style.display = 'block';
                    
                    showSuccess('Question generated successfully!');
                } else {
                    showError(result.error || 'Failed to generate question');
                }
            } catch (error) {
                console.error('Error generating AI question:', error);
                showError('Error generating question from AI');
            } finally {
                // Reset button state
                generateBtn.disabled = false;
                generateBtn.innerHTML = '🤖 Generate Question';
            }
        }

        async function addAIQuestion() {
            if (!aiQuestionEditor) {
                showError('No question generated');
                return;
            }

            const questionText = aiQuestionEditor.getText().trim();
            const questionHtml = aiQuestionEditor.root.innerHTML;
            const tags = document.getElementById('ai-question-tags').value.trim();

            if (!questionText) {
                showError('No question to add');
                return;
            }

            // Show loading state
            const addBtn = document.getElementById('add-ai-question-btn');
            if (addBtn) {
                addBtn.disabled = true;
                const originalText = addBtn.innerHTML;
                addBtn.innerHTML = '<span class="loading-spinner" style="display: inline-block; width: 12px; height: 12px; border: 2px solid #ffffff; border-top: 2px solid transparent; border-radius: 50%; animation: spin 1s linear infinite; margin-right: 0.5rem;"></span> Adding...';
                
                try {
                    // Add question to current interview
                    await addQuestionToInterview(questionHtml, tags ? tags.split(',').map(t => t.trim()) : []);
                    
                    // Refresh question bank data to ensure proper "Add to Bank" button state
                    await loadQuestionBankData();
                    
                    // Re-display questions to update button visibility
                    await displayQuestions();
                    
                    // Clear the form
                    document.getElementById('ai-question-tags').value = '';
                    document.getElementById('ai-generated-question').style.display = 'none';
                    if (aiQuestionEditor) aiQuestionEditor.setText('');
                    
                    // Close panel
                    closeSidePanel('ai-question-panel');
                } finally {
                    // Restore button state
                    addBtn.disabled = false;
                    addBtn.innerHTML = originalText;
                }
            } else {
                // Fallback if button not found
                await addQuestionToInterview(questionHtml, tags ? tags.split(',').map(t => t.trim()) : []);
                await loadQuestionBankData();
                await displayQuestions();
                document.getElementById('ai-question-tags').value = '';
                document.getElementById('ai-generated-question').style.display = 'none';
                if (aiQuestionEditor) aiQuestionEditor.setText('');
                closeSidePanel('ai-question-panel');
            }
        }

        // Helper function to add question to interview
        async function addQuestionToInterview(questionHtml, tags = []) {
            if (!currentInterview || !currentInterview.id) {
                showError('No active interview found');
                return;
            }

            try {
                // Save to database first
                const response = await fetch(`/api/interviews/${currentInterview.id}/questions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        question_text: questionHtml,
                        question_rich_content: questionHtml,
                        tags: tags
                    })
                });

                const result = await response.json();

                if (result.success) {
                    // Add to local array with the actual database ID
                    const newQuestion = {
                        id: result.data.id,
                        question_text: questionHtml,
                        tags: tags,
                        student_answer: '',
                        correctness_score: null,
                        answer_photo_url: null,
                        type: 'custom'
                    };

                    questions.unshift(newQuestion); // Add to beginning for newest-first order
                    await displayQuestions();
                    showSuccess('Question added successfully!');
                } else {
                    showError('Failed to save question to database');
                }
            } catch (error) {
                console.error('Error saving question:', error);
                showError('Error saving question');
            }
        }

        // Add to Question Bank Functions
        function addCustomToQuestionBank() {
            if (!customQuestionEditor) {
                showError('Editor not initialized');
                return;
            }

            const questionText = customQuestionEditor.getText().trim();
            const questionHtml = customQuestionEditor.root.innerHTML;

            if (!questionText) {
                showError('Please enter a question');
                return;
            }

            addToQuestionBankAPI(questionHtml, []);
        }

        async function addAIToQuestionBank() {
            if (!aiQuestionEditor) {
                showError('No question generated');
                return;
            }

            const questionText = aiQuestionEditor.getText().trim();
            const questionHtml = aiQuestionEditor.root.innerHTML;
            const tags = document.getElementById('ai-question-tags').value.trim();

            if (!questionText) {
                showError('No question to add');
                return;
            }

            // Show loading state
            const addToBankBtn = document.getElementById('add-ai-to-bank-btn');
            if (addToBankBtn) {
                addToBankBtn.disabled = true;
                const originalText = addToBankBtn.innerHTML;
                addToBankBtn.innerHTML = '<span class="loading-spinner" style="display: inline-block; width: 12px; height: 12px; border: 2px solid #ffffff; border-top: 2px solid transparent; border-radius: 50%; animation: spin 1s linear infinite; margin-right: 0.5rem;"></span> Adding...';
                
                try {
                    await addToQuestionBankAPI(questionHtml, tags ? tags.split(',').map(t => t.trim()) : []);
                } finally {
                    // Restore button state
                    addToBankBtn.disabled = false;
                    addToBankBtn.innerHTML = originalText;
                }
            } else {
                await addToQuestionBankAPI(questionHtml, tags ? tags.split(',').map(t => t.trim()) : []);
            }
        }

        async function addToQuestionBankAPI(questionHtml, tags = []) {
            try {
                const response = await fetch('/api/question-bank', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        question: questionHtml,
                        tags: tags,
                        category: null // Using tags instead of category
                    })
                });

                const result = await response.json();
                if (result.success) {
                    showSuccess('Question added to Question Bank!');
                    // Refresh question bank data to include the newly added question
                    await loadQuestionBankData();
                } else {
                    showError('Failed to add question to bank: ' + (result.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error adding question to bank:', error);
                showError('Error adding question to bank: ' + error.message);
            }
        }

        // Question Bank Panel Functions
        function openQuestionBankPanel() {
            const panel = document.getElementById('question-bank-panel');
            const overlay = document.getElementById('question-bank-overlay');
            
            panel.classList.add('open');
            overlay.classList.add('active');
            
            // Load question bank data if not already loaded
            if (panelQuestionBankData.length === 0) {
                loadPanelQuestionBankData();
            } else {
                displayPanelQuestionBankList(panelQuestionBankData);
            }
        }

        function closeQuestionBankPanel() {
            const panel = document.getElementById('question-bank-panel');
            const overlay = document.getElementById('question-bank-overlay');
            
            panel.classList.remove('open');
            overlay.classList.remove('active');
        }

        async function loadPanelQuestionBankData() {
            console.log('🔍 Loading panel question bank data...');
            try {
                // Load tags
                console.log('🏷️ Fetching tags...');
                const tagsResponse = await fetch('/api/question-bank/tags');
                console.log('🏷️ Tags response status:', tagsResponse.status);
                
                if (!tagsResponse.ok) {
                    throw new Error(`HTTP ${tagsResponse.status}: ${tagsResponse.statusText}`);
                }
                
                const tagsResult = await tagsResponse.json();
                console.log('🏷️ Tags result:', tagsResult);
                
                if (tagsResult.success && tagsResult.data) {
                    const categorySelect = document.getElementById('panel-category-select');
                    // Clear existing options except "All Tags" and "My Favorites"
                    categorySelect.innerHTML = '<option value="">All Tags</option><option value="Favorites">My Favorites</option>';
                    
                    tagsResult.data.forEach(tagData => {
                        const option = document.createElement('option');
                        // Handle both string and object formats
                        const tagName = typeof tagData === 'string' ? tagData : tagData.tag;
                        const questionCount = typeof tagData === 'object' ? tagData.question_count : '';
                        option.value = tagName;
                        option.textContent = questionCount ? `#${tagName} (${questionCount})` : `#${tagName}`;
                        categorySelect.appendChild(option);
                    });
                }
                
                // Load all questions
                console.log('❓ Fetching questions...');
                const questionsResponse = await fetch('/api/question-bank');
                console.log('❓ Questions response status:', questionsResponse.status);
                
                if (!questionsResponse.ok) {
                    throw new Error(`HTTP ${questionsResponse.status}: ${questionsResponse.statusText}`);
                }
                
                const questionsResult = await questionsResponse.json();
                console.log('❓ Questions result:', questionsResult);
                
                if (questionsResult.success && questionsResult.data) {
                    panelQuestionBankData = questionsResult.data;
                    console.log('✅ Loaded questions:', panelQuestionBankData.length);
                    displayPanelQuestionBankList(panelQuestionBankData);
                } else {
                    throw new Error(questionsResult.error || 'Failed to load questions');
                }
                
            } catch (error) {
                console.error('❌ Error loading panel question bank data:', error);
                document.getElementById('question-bank-panel-list').innerHTML = 
                    `<div class="error">Error loading questions: ${error.message}</div>`;
            }
        }

        async function loadPanelQuestionsByCategory() {
            const selectEl = document.getElementById('panel-category-select');
            if (!selectEl) return;
            const category = (selectEl.value || '').trim();
            console.log('[Panel] Category changed ->', category);
            // persist current category for search filtering
            try { window.panelCurrentCategory = category; } catch {}
            try {
                let data = [];
                if (!category) {
                    data = panelQuestionBankData || [];
                    console.log('[Panel] Using all questions, count =', data.length);
                } else if (category.toLowerCase().includes('favorite')) {
                    const email = (JSON.parse(localStorage.getItem('bees_user_data') || '{}')?.email) || '';
                    console.log('[Panel][Favorites] Using email =', email);
                    const url = `/api/interviewer/favorites${email ? `?email=${encodeURIComponent(email)}` : ''}`;
                    console.log('[Panel][Favorites] Fetch URL =', url);
                    const res = await fetch(url , {
                        headers: email ? { 'x-user-email': email } : {}
                    });
                    console.log('[Panel][Favorites] Response status =', res.status);
                    const json = await res.json();
                    console.log('[Panel][Favorites] JSON =', json);
                    try { console.log('[Panel][Favorites] JSON (stringified) =', JSON.stringify(json, null, 2)); } catch {}
                    if (json && json.success) {
                        const favs = json.data || [];
                        console.log('[Panel][Favorites] Raw favorites count =', favs.length);
                        try { console.log('[Panel][Favorites] Raw favorites array =', JSON.stringify(favs, null, 2)); } catch { console.log('[Panel][Favorites] Raw favorites array (non-string) =', favs); }
                        // Normalize ID keys to strings to avoid number/string mismatch
                        const byId = new Map((panelQuestionBankData || []).map(q => [String(q.id), q]));
                        data = favs.map(f => {
                            const fid = String(f.question_id != null ? f.question_id : f.id);
                            const base = byId.get(fid) || {};
                            const text = f.question || base.question || base.question_text || `Favorite Question #${fid}`;
                            return {
                                id: Number(fid),
                                question: text,
                                question_text: text,
                                category: f.category || base.category || 'Uncategorized',
                                times_asked: (f.times_asked ?? base.times_asked ?? 0),
                                success_rate: (f.success_rate ?? base.success_rate ?? 0)
                            };
                        });
                        // If enrichment produced empty list but we had raw favorites, fall back to building rows from raw favorites directly
                        if (data.length === 0 && favs.length > 0) {
                            console.warn('[Panel][Favorites] Enrichment yielded empty; attempting backend details join');
                            try {
                                const ids = favs.map(f => (f.question_id != null ? f.question_id : f.id)).filter(Boolean);
                                // Fallback 1: if backend supports bulk by ids
                                let built = [];
                                try {
                                    const bulkUrl = `/api/admin/questions/details?ids=${encodeURIComponent(ids.join(','))}`;
                                    console.log('[Panel][Favorites] Trying bulk details URL =', bulkUrl);
                                    const bulkRes = await fetch(bulkUrl);
                                    if (bulkRes.ok) {
                                        const bulkJson = await bulkRes.json();
                                        if (bulkJson && bulkJson.success && Array.isArray(bulkJson.data)) {
                                            built = bulkJson.data.map(q => ({
                                                id: q.id,
                                                question: q.question || q.question_text || `Favorite Question #${q.id}`,
                                                question_text: q.question || q.question_text || `Favorite Question #${q.id}`,
                                                category: q.category || 'Uncategorized',
                                                times_asked: q.times_asked ?? 0,
                                                success_rate: q.success_rate ?? 0
                                            }));
                                        }
                                    }
                                } catch (e) {
                                    console.warn('[Panel][Favorites] Bulk details not available:', e);
                                }
                                // Fallback 2: per-id details as last resort
                                if (built.length === 0) {
                                    console.log('[Panel][Favorites] Falling back to per-id details fetch');
                                    const details = await Promise.all(ids.map(async (qid) => {
                                        try {
                                            const r = await fetch(`/api/admin/questions/${qid}/details`);
                                            if (!r.ok) return null;
                                            const j = await r.json();
                                            const q = j.data || j;
                                            return {
                                                id: qid,
                                                question: q.question || q.question_text || `Favorite Question #${qid}`,
                                                question_text: q.question || q.question_text || `Favorite Question #${qid}`,
                                                category: q.category || 'Uncategorized',
                                                times_asked: q.times_asked ?? 0,
                                                success_rate: q.success_rate ?? 0
                                            };
                                        } catch {
                                            return null;
                                        }
                                    }));
                                    built = details.filter(Boolean);
                                    console.log('[Panel][Favorites] Built via per-id details count =', built.length);
                                }
                                if (built.length > 0) {
                                    data = built;
                                    try { console.log('[Panel][Favorites] Built data sample =', JSON.stringify(data.slice(0,3), null, 2)); } catch {}
                                } else {
                                    // Final fallback: raw favorites
                                    data = favs.map(f => {
                                        const fid = Number(f.question_id != null ? f.question_id : f.id);
                                        const text = f.question || `Favorite Question #${fid}`;
                                        return {
                                            id: fid,
                                            question: text,
                                            question_text: text,
                                            category: f.category || 'Uncategorized',
                                            times_asked: f.times_asked ?? 0,
                                            success_rate: f.success_rate ?? 0
                                        };
                                    });
                                    try { console.log('[Panel][Favorites] Raw mapped data sample =', JSON.stringify(data.slice(0,3), null, 2)); } catch {}
                                }
                            } catch (e) {
                                console.warn('[Panel][Favorites] Details join fallback failed:', e);
                                // Keep raw favorites rendering as last resort
                                data = favs.map(f => {
                                    const fid = Number(f.question_id != null ? f.question_id : f.id);
                                    const text = f.question || `Favorite Question #${fid}`;
                                    return {
                                        id: fid,
                                        question: text,
                                        question_text: text,
                                        category: f.category || 'Uncategorized',
                                        times_asked: f.times_asked ?? 0,
                                        success_rate: f.success_rate ?? 0
                                    };
                                });
                                try { console.log('[Panel][Favorites] Raw mapped data sample (fallback) =', JSON.stringify(data.slice(0,3), null, 2)); } catch {}
                            }
                        }
                        console.log('[Panel][Favorites] Enriched favorites count =', data.length);
                    } else {
                        console.warn('[Panel][Favorites] Favorite API not success');
                    }
                } else {
                    // Filter by tag (supports both new tags array and legacy category)
                    console.log('[Panel][Tag] Filtering by tag:', category);
                    const searchTag = category.toLowerCase();
                    data = (panelQuestionBankData || []).filter(q => {
                        // Check tags array first (new system)
                        if (q.tags && Array.isArray(q.tags)) {
                            return q.tags.some(tag => tag.toLowerCase() === searchTag);
                        }
                        // Fallback to category (legacy)
                        return (q.category || '').toLowerCase() === searchTag;
                    });
                    console.log('[Panel][Tag] Filtered count:', data.length);
                }
                console.log('[Panel] Final list length =', data.length);
                displayPanelQuestionBankList(data);
            } catch (e) {
                console.error('[Panel] Error filtering panel questions:', e);
            }
        }

        function displayPanelQuestionBankList(questions) {
            const listContainer = document.getElementById('question-bank-panel-list');
            
            if (!questions || questions.length === 0) {
                console.warn('[Panel] No questions to display for current filter');
                listContainer.innerHTML = '<div class="empty-state">No questions found</div>';
                return;
            }
            
            listContainer.innerHTML = questions.map(question => `
                <div class="question-bank-panel-item" data-question-id="${question.id}" onclick="selectPanelQuestion(${question.id})">
                    <div class="question-bank-panel-item-text">${question.question_text}</div>
                    <div class="question-bank-panel-item-meta">
                        <span class="question-bank-panel-item-category">${question.category || 'Uncategorized'}</span>
                        <div class="question-bank-panel-item-stats">
                            <span>Asked: ${question.times_asked || 0}</span>
                            <span>Success: ${question.success_rate || 0}%</span>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        // Track ongoing question additions to prevent duplicates
        const addingQuestions = new Set();
        
        async function selectPanelQuestion(questionId) {
            // Prevent duplicate additions - check if already adding this question
            if (addingQuestions.has(questionId)) {
                console.log('⚠️ Already adding question', questionId, '- ignoring duplicate click');
                return;
            }
            
            // Mark as being added
            addingQuestions.add(questionId);
            
            try {
                // Remove previous selection
                document.querySelectorAll('.question-bank-panel-item').forEach(item => {
                    item.classList.remove('selected');
                });
                
                // Add selection to clicked item
                const selectedItem = document.querySelector(`[data-question-id="${questionId}"]`);
                if (selectedItem) {
                    selectedItem.classList.add('selected');
                    // Disable the item to prevent further clicks
                    selectedItem.style.pointerEvents = 'none';
                    selectedItem.style.opacity = '0.6';
                    
                    // Find the question data
                    const question = panelQuestionBankData.find(q => q.id === questionId);
                    if (question) {
                        // Add the question to the interview
                        await addQuestionFromPanel(question.question_text);
                        
                        // Close the panel
                        closeQuestionBankPanel();
                    }
                }
            } finally {
                // Always remove from tracking set after operation completes
                addingQuestions.delete(questionId);
                
                // Re-enable the item if it still exists
                const selectedItem = document.querySelector(`[data-question-id="${questionId}"]`);
                if (selectedItem) {
                    selectedItem.style.pointerEvents = '';
                    selectedItem.style.opacity = '';
                }
            }
        }

        async function addQuestionFromPanel(questionText) {
            console.log('➕ Adding question from panel:', questionText);
            console.log('➕ Current interview ID:', currentInterview?.id);
            console.log('➕ Current questions count before adding:', questions.length);
            
            if (!currentInterview) {
                showError('No active interview found');
                return;
            }

            // Check for duplicate questions
            const isDuplicate = questions.some(q => 
                q.question_text && q.question_text.trim().toLowerCase() === questionText.trim().toLowerCase()
            );
            
            if (isDuplicate) {
                showError('This question has already been added to the interview. Please select a different question.');
                return;
            }

            try {
                // Save the question to the server first
                console.log('📤 Sending POST request to save question...');
                const response = await fetch(`/api/interviews/${currentInterview.id}/questions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        question_text: questionText
                    })
                });
                
                const result = await response.json();
                console.log('📥 Server response:', result);
                
                if (response.ok && result.success) {
                    console.log('✅ Question saved successfully, reloading questions...');
                    // Reload questions from server to get the latest state
                    await loadQuestions();
                    showSuccess('Question added from Question Bank!');
                } else {
                    console.error('❌ Error saving question:', result);
                    showError('Error adding question from bank');
                }
            } catch (error) {
                console.error('❌ Error adding question from panel:', error);
                showError('Error adding question from bank');
            }
        }

        // removed old simple loadPanelQuestionsByCategory (replaced by async version above)

        function searchPanelQuestions() {
            const searchInput = document.getElementById('panel-search-input');
            const searchTerm = searchInput.value.toLowerCase().trim();
            
            let filteredQuestions = [...panelQuestionBankData];
            
            // Apply category filter first
            if (panelCurrentCategory === 'Favorites') {
                filteredQuestions = filteredQuestions.filter(q => q.is_favorite);
            } else if (panelCurrentCategory) {
                filteredQuestions = filteredQuestions.filter(q => q.category === panelCurrentCategory);
            }
            
            // Apply search filter
            if (searchTerm) {
                filteredQuestions = filteredQuestions.filter(q => 
                    q.question_text.toLowerCase().includes(searchTerm)
                );
            }
            
            displayPanelQuestionBankList(filteredQuestions);
        }

        // Close panel when clicking outside
        document.addEventListener('click', function(event) {
            const panel = document.getElementById('question-bank-panel');
            const overlay = document.getElementById('question-bank-overlay');
            
            if (event.target === overlay) {
                closeQuestionBankPanel();
            }
        });

        // Initialize avatar
        async function initializeAvatar() {
            try {
                // Get user data from localStorage or URL parameters
                const urlParams = new URLSearchParams(window.location.search);
                const email = urlParams.get('email');
                const name = urlParams.get('name');
                
                // Check localStorage for existing user data
                const storedUserData = localStorage.getItem('bees_user_data');
                let userData = null;
                
                if (storedUserData) {
                    try {
                        userData = JSON.parse(storedUserData);
                    } catch (e) {
                        console.error('Error parsing stored user data:', e);
                        localStorage.removeItem('bees_user_data');
                    }
                }
                
                // Use URL params if available, otherwise use stored data
                const userEmail = email || userData?.email;
                const userName = name || userData?.name;
                
                if (userEmail || userName) {
                    const avatar = document.getElementById('avatar');
                    const avatarMenu = document.getElementById('avatar-menu');
                    const loginBtn = document.getElementById('login-btn');
                    
                    if (avatar) {
                        // Get user ID from API to ensure consistent avatar
                        try {
                            const userIdResponse = await fetch('/api/user/id');
                            const userIdData = await userIdResponse.json();
                            const userId = userIdData.success ? userIdData.userId : null;
                            const initial = userId ? userId.toString().charAt(0).toUpperCase() : (userEmail || userName || 'U').trim().charAt(0).toUpperCase();
                            avatar.textContent = initial || 'U';
                        } catch (error) {
                            console.error('Error fetching user ID:', error);
                            const initial = (userEmail || userName || 'U').trim().charAt(0).toUpperCase();
                            avatar.textContent = initial || 'U';
                        }
                        
                        avatar.classList.remove('hidden');
                        if (loginBtn) loginBtn.classList.add('hidden');
                        
                        avatar.onclick = () => {
                            avatarMenu.classList.toggle('active');
                        };
                        
                        document.addEventListener('click', (e) => {
                            if (!avatar.contains(e.target) && !avatarMenu.contains(e.target)) {
                                avatarMenu.classList.remove('active');
                            }
                        });
                        
                        const logoutBtn = document.getElementById('logout-btn-dropdown');
                        if (logoutBtn) {
                            logoutBtn.onclick = () => {
                                if (confirm('Are you sure you want to logout?')) {
                                    localStorage.removeItem('bees_user_data');
                                    window.location.href = '/';
                                }
                            };
                        }
                    }
                }
            } catch (error) {
                console.error('Error initializing avatar:', error);
            }
        }

        // Initialize Quill Rich Text Editor
        function initializeQuillEditor() {
            try {
                console.log('🔧 Initializing Quill editor...');
                
                // Check if container exists
                const container = document.getElementById('question-editor-container');
                if (!container) {
                    console.error('❌ Editor container not found!');
                    return;
                }
                
                // Check if Quill is loaded
                if (typeof Quill === 'undefined') {
                    console.error('❌ Quill library not loaded!');
                    return;
                }
                
                const toolbarOptions = [
                    ['bold', 'italic', 'underline', 'strike'],        // toggled buttons
                    ['blockquote', 'code-block'],
                    [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                    [{ 'header': [1, 2, 3, false] }],
                    ['link', 'image'],                                 // link and image
                    ['clean']                                          // remove formatting button
                ];

                questionEditor = new Quill('#question-editor-container', {
                    modules: {
                        toolbar: toolbarOptions
                    },
                    placeholder: 'Enter your question here... You can add images and formatting.',
                    theme: 'snow'
                });
                
                console.log('✅ Quill editor initialized successfully');
                console.log('Editor object:', questionEditor);
                
                // Test the editor
                setTimeout(() => {
                    const testText = questionEditor.getText();
                    console.log('📝 Editor test - current text length:', testText.length);
                }, 100);
            } catch (error) {
                console.error('❌ Error initializing Quill editor:', error);
            }
        }

        // Check authentication before initializing
        async function checkAuthenticationAndInit() {
            // Check if user is logged in
            const storedUserData = localStorage.getItem('bees_user_data');
            
            if (!storedUserData) {
                console.log('❌ No user data found, redirecting to home');
                window.location.href = '/';
                return;
            }
            
            try {
                const userData = JSON.parse(storedUserData);
                
                // Verify the user is still authorized
                const response = await fetch(`/api/user/role?email=${encodeURIComponent(userData.email)}`);
                const data = await response.json();
                
                if (!response.ok || !data.success) {
                    console.log('❌ User not authorized');
                    localStorage.removeItem('bees_user_data');
                    window.location.href = '/';
                    return;
                }
                
                // User is authorized, proceed with initialization
                initializeQuillEditor();
                loadStudentData();
                // Initialize question bank tab as inactive
                document.getElementById('question-bank-tab').classList.remove('active');
                // Initialize avatar
                initializeAvatar();
            } catch (error) {
                console.error('Error verifying user authorization:', error);
                localStorage.removeItem('bees_user_data');
                window.location.href = '/';
            }
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            checkAuthenticationAndInit();
        });
    </script>

    <!-- Category Selection Modal -->
    <div id="category-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Add Question to Bank</h3>
                <button class="close-modal" onclick="closeCategoryModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label" for="question-text">Question:</label>
                    <textarea id="modal-question-text" class="form-textarea" rows="3" readonly></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label" for="modal-tags">Tags (comma-separated):</label>
                    <input type="text" id="modal-tags" class="form-input" placeholder="e.g., javascript, algorithms, problem-solving">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeCategoryModal()">Cancel</button>
                <button class="btn btn-primary" onclick="saveToQuestionBank()">Add to Bank</button>
            </div>
        </div>
    </div>


    <!-- Panel Overlay -->
    <div id="panel-overlay" class="panel-overlay" onclick="closeAllPanels()"></div>

    <!-- Custom Question Side Panel -->
    <div id="custom-question-panel" class="side-panel">
        <div class="side-panel-header">
            <h3>Add Custom Question</h3>
            <button class="close-panel-btn" onclick="closeSidePanel('custom-question-panel')">✕</button>
        </div>
        <div class="side-panel-content">
            <div class="form-group">
                <label class="form-label" for="custom-question-editor">Question</label>
                <div class="editor-wrapper">
                    <div id="custom-question-editor"></div>
                </div>
            </div>
            <div class="panel-actions">
                <button class="btn btn-primary" onclick="addCustomQuestion()">Add Question</button>
                <button class="btn btn-secondary" onclick="closeSidePanel('custom-question-panel')">Cancel</button>
            </div>
        </div>
    </div>

    <!-- AI Question Generation Side Panel -->
    <div id="ai-question-panel" class="side-panel">
        <div class="side-panel-header">
            <h3>Generate Question from AI</h3>
            <button class="close-panel-btn" onclick="closeSidePanel('ai-question-panel')">✕</button>
        </div>
        <div class="side-panel-content">
            <div class="form-group">
                <label class="form-label" for="ai-question-tags">Tags for AI Generation</label>
                <input type="text" id="ai-question-tags" class="form-input" placeholder="e.g., javascript, react, algorithms" required>
                <small class="form-help">Enter tags to help AI generate relevant questions</small>
            </div>
            <div class="form-group">
                <label class="form-label" for="ai-difficulty-level">Difficulty Level</label>
                <select id="ai-difficulty-level" class="form-select">
                    <option value="beginner">Beginner</option>
                    <option value="intermediate" selected>Intermediate</option>
                    <option value="advanced">Advanced</option>
                </select>
            </div>
            <div class="form-group">
                <button class="btn btn-info" onclick="generateAIQuestion()" id="generate-ai-btn">
                    <span class="loading-spinner" style="display: none;"></span>
                    🤖 Generate Question
                </button>
            </div>
            <div class="form-group" id="ai-generated-question" style="display: none;">
                <div class="form-label-with-action">
                    <label class="form-label">Generated Question</label>
                    <button class="add-to-bank-btn" onclick="addAIToQuestionBank()" title="Add to Question Bank">📚 Add to Bank</button>
                </div>
                <div class="editor-wrapper">
                    <div id="ai-question-editor"></div>
                </div>
                <div class="panel-actions">
                    <button class="btn btn-primary" onclick="addAIQuestion()">Add Question</button>
                    <button class="btn btn-secondary" onclick="generateAIQuestion()">Generate New</button>
                </div>
            </div>
        </div>
    </div>

<script src="/shared-auth.js"></script>
</body>
</html>