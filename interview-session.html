<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interview Session - Bees Platform</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        @font-face {
            font-family: 'Zoho Puvi';
            src: url('/Zoho Puvi/OpenType-TT/Zoho Puvi Regular.ttf') format('truetype');
            font-weight: 400;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'Zoho Puvi';
            src: url('/Zoho Puvi/OpenType-TT/Zoho Puvi Medium.ttf') format('truetype');
            font-weight: 500;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'Zoho Puvi';
            src: url('/Zoho Puvi/OpenType-TT/Zoho Puvi Semibold.ttf') format('truetype');
            font-weight: 600;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'Zoho Puvi';
            src: url('/Zoho Puvi/OpenType-TT/Zoho Puvi Bold.ttf') format('truetype');
            font-weight: 700;
            font-style: normal;
            font-display: swap;
        }
        body {
            font-family: 'Zoho Puvi', -apple-system, BlinkMacSystemFont, 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f8fafc;
            min-height: 100vh;
            color: #4a5568;
        }
        
        .header {
            background: #ffffff;
            padding: 1rem 2rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 100;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header-actions {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }
        
        .interview-clock {
            background: transparent;
            color: #1f2937;
            padding: 0.25rem 0.5rem;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-weight: 600;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .clock-icon { font-size: 1rem; opacity: 0.75; }

        .timer-wrapper {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0.25rem 2rem 0.5rem;
            display: flex;
            justify-content: flex-end;
        }

        .interview-action-buttons {
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
            margin-top: 0.5rem;
        }
        
        .verdict-section {
            margin-top: 1rem;
        }
        
        .verdict-section.hidden {
            display: none;
        }
        
        .user-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .avatar {
            width: 36px;
            height: 36px;
            background: #2d3748;
            color: #ffffff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            cursor: pointer;
            user-select: none;
        }

        .avatar-menu {
            position: absolute;
            right: 16px;
            top: 56px;
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            display: none;
            min-width: 140px;
            z-index: 150;
        }

        .avatar-menu.active { display: block; }

        .avatar-menu button {
            width: 100%;
            background: #ffffff;
            border: none;
            text-align: left;
            padding: 10px 12px;
            cursor: pointer;
        }

        .avatar-menu button:hover { background: #f3f4f6; }
        
        .user-name {
            font-weight: 600;
            color: #2d3748;
            background: #f7fafc;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            border: 1px solid #e2e8f0;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .user-name:hover {
            background: #edf2f7;
            border-color: #cbd5e0;
        }
        
        .login-btn {
            background: #4299e1;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .login-btn:hover {
            background: #3182ce;
        }
        
        .header-actions .btn {
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
        }
        
        .logo {
            font-size: 2rem;
            font-weight: bold;
            color: #2d3748;
            text-decoration: none;
        }
        
        .back-btn {
            background: #2d3748;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s ease;
        }
        
        .back-btn:hover {
            background: #1a202c;
        }
        
        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1rem;
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 1rem;
            height: calc(100vh - 80px);
            overflow: hidden; /* Prevent main container from scrolling */
        }
        
        .interview-main {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden; /* Prevent main section from scrolling */
        }
        
        .student-info-card {
            background: #f7fafc;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            border: 1px solid #e2e8f0;
        }
        
        .student-info-title {
            font-size: 1.1rem;
            color: #2d3748;
            margin-bottom: 0.5rem;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 0.5rem;
        }
        
        .info-item {
            background: white;
            padding: 0.5rem;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border: 1px solid #e2e8f0;
        }
        
        .info-label {
            font-weight: 600;
            color: #2d3748;
            font-size: 0.8rem;
            margin-bottom: 0.25rem;
        }
        
        .info-value {
            color: #4a5568;
            font-size: 0.9rem;
        }
        
        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
            background: #f8f9fa;
            min-height: 0;
        }
        
        .question-item {
            margin-bottom: 1rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
            border: 1px solid #e2e8f0;
            transition: all 0.3s ease;
        }
        
        .question-item.expanded {
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .question-header {
            background: #f8fafc;
            color: #2d3748;
            padding: 1rem;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            border-bottom: 1px solid #e2e8f0;
            transition: background 0.2s ease;
        }
        
        .question-header:hover {
            background: #edf2f7;
        }
        
        .question-header.expanded {
            background: #2563eb;
            color: white;
        }
        
        .question-number {
            font-size: 0.9rem;
            color: #6b7280;
            margin-right: 0.5rem;
        }
        
        .question-header.expanded .question-number {
            color: rgba(255, 255, 255, 0.8);
        }
        
        .question-preview {
            flex: 1;
            font-size: 1rem;
            line-height: 1.4;
            margin: 0 1rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .question-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .correctness-buttons {
            display: flex;
            gap: 0.25rem;
        }

        .correctness-btn {
            width: 24px;
            height: 24px;
            border: 2px solid #d1d5db;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .correctness-btn:hover {
            transform: scale(1.1);
        }

        .correct-btn {
            color: #059669;
            border-color: #059669;
        }

        .correct-btn.active {
            background: #059669;
            color: white;
        }

        .incorrect-btn {
            color: #dc2626;
            border-color: #dc2626;
        }

        .incorrect-btn.active {
            background: #dc2626;
            color: white;
        }
        
        .expand-icon {
            font-size: 1.2rem;
            transition: transform 0.3s ease;
        }
        
        .question-header.expanded .expand-icon {
            transform: rotate(180deg);
        }
        
        .question-content {
            display: none;
            padding: 0;
        }
        
        .question-content.expanded {
            display: block;
        }
        
        .question-text {
            font-size: 1.1rem;
            line-height: 1.6;
            color: #1f2937;
            padding: 1rem;
            background: #f7fafc;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .answer-section {
            padding: 1rem;
            background: white;
        }
        
        .answer-label {
            font-weight: 600;
            color: #374151;
            margin-bottom: 0.5rem;
            display: block;
        }
        
        .message-header {
            font-weight: 600;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }
        
        .message-text {
            margin-bottom: 0.5rem;
        }
        
        .image-preview {
            position: relative;
            display: inline-block;
            margin-top: 0.5rem;
        }
        
        .message-image {
            max-width: 200px;
            border-radius: 8px;
            cursor: pointer;
            display: block;
        }
        
        .delete-image-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(255, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .delete-image-btn:hover {
            background: rgba(255, 0, 0, 1);
        }
        
        .add-question-form {
            background: #f7fafc;
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            position: sticky;
            bottom: 0;
        }
        
        .form-group {
            margin-bottom: 0.5rem;
        }
        
        .form-label {
            display: block;
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 0.25rem;
            font-size: 0.9rem;
        }
        
        .form-textarea {
            width: 100%;
            min-height: 60px;
            padding: 0.5rem;
            border: 2px solid #e9ecef;
            border-radius: 5px;
            font-size: 0.9rem;
            resize: vertical;
            transition: border-color 0.3s ease;
        }
        
        .form-textarea:focus {
            outline: none;
            border-color: #2d3748;
        }
        
        .textarea-container {
            position: relative;
            display: flex;
            align-items: flex-end;
        }
        
        .add-to-bank-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: #2d3748;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s ease;
            z-index: 10;
        }
        
        .add-to-bank-btn:hover {
            background: #1a202c;
            transform: scale(1.05);
        }
        
        .add-to-bank-btn:disabled {
            background: #a0aec0;
            cursor: not-allowed;
            transform: none;
        }
        
        .question-actions {
            margin-top: 0.5rem;
            display: flex;
            justify-content: flex-end;
        }
        
        .add-to-bank-btn-small {
            background: #2d3748;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s ease;
        }
        
        .add-to-bank-btn-small:hover {
            background: #1a202c;
            transform: scale(1.05);
        }
        
        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .modal-content {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .modal-header h3 {
            margin: 0;
            color: #2d3748;
        }
        
        .close-modal {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #718096;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .close-modal:hover {
            color: #2d3748;
        }
        
        .modal-body {
            padding: 1.5rem;
        }
        
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            padding: 1rem 1.5rem;
            border-top: 1px solid #e2e8f0;
        }
        
        .question-source-tabs {
            display: flex;
            margin-bottom: 1rem;
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid #e2e8f0;
        }
        
        .tab-btn {
            flex: 1;
            padding: 0.5rem 1rem;
            background: #f7fafc;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            border-right: 1px solid #e2e8f0;
        }
        
        .tab-btn:last-child {
            border-right: none;
        }
        
        .tab-btn.active {
            background: #2d3748;
            color: white;
        }
        
        .tab-btn:hover:not(.active) {
            background: #edf2f7;
        }
        
        .question-tab {
            display: none;
        }
        
        .question-tab.active {
            display: block;
        }
        
        
        .question-bank-filters {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        
        .question-bank-list {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .question-bank-item {
            padding: 1rem;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .question-bank-item:hover {
            background: #f3f4f6;
        }
        
        .question-bank-item.selected {
            background: #dbeafe;
            border-color: #2563eb;
        }
        
        .form-select, .form-input {
            width: 100%;
            padding: 0.5rem;
            border: 2px solid #e9ecef;
            border-radius: 5px;
            font-size: 0.9rem;
            transition: border-color 0.3s ease;
        }
        
        .form-select:focus, .form-input:focus {
            outline: none;
            border-color: #2d3748;
        }
        
        .question-bank-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 5px;
            background: white;
            transition: max-height 0.3s ease;
        }
        
        .question-bank-list.expanded {
            max-height: 500px;
        }
        
        .resize-handle {
            height: 4px;
            background: #e2e8f0;
            cursor: ns-resize;
            position: relative;
            margin: 0.5rem 0;
            border-radius: 2px;
            transition: background 0.2s ease;
        }
        
        .resize-handle:hover {
            background: #2563eb;
        }
        
        .resize-handle::before {
            content: '‚ãÆ‚ãÆ';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #9ca3af;
            font-size: 12px;
            line-height: 1;
        }
        
        .delete-question-btn {
            background: #dc2626;
            color: white;
            border: none;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            margin-left: 0.5rem;
            transition: background 0.2s ease;
        }
        
        .delete-question-btn:hover {
            background: #b91c1c;
        }

        /* Question Bank Sliding Panel */
        .question-bank-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: #ffffff;
            box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            z-index: 1000;
            transition: right 0.3s ease;
            overflow-y: auto;
            border-left: 1px solid #e2e8f0;
        }

        .question-bank-panel.open {
            right: 0;
        }

        .question-bank-panel-header {
            padding: 1rem;
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 1001;
        }

        .question-bank-panel-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #1f2937;
        }

        .question-bank-close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6b7280;
            padding: 0.25rem;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .question-bank-close-btn:hover {
            background: #e5e7eb;
            color: #374151;
        }

        .question-bank-panel-content {
            padding: 1rem;
        }

        .question-bank-panel-filters {
            margin-bottom: 1rem;
        }

        .question-bank-panel-list {
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }

        .question-bank-panel-item {
            padding: 0.75rem;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            background: #ffffff;
        }

        .question-bank-panel-item:hover {
            background: #f8fafc;
            border-color: #3b82f6;
        }

        .question-bank-panel-item.selected {
            background: #dbeafe;
            border-color: #2563eb;
        }

        .question-bank-panel-item-text {
            font-size: 0.9rem;
            line-height: 1.4;
            margin-bottom: 0.5rem;
        }

        .question-bank-panel-item-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            color: #6b7280;
        }

        .question-bank-panel-item-category {
            background: #f3f4f6;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
        }

        .question-bank-panel-item-stats {
            display: flex;
            gap: 0.5rem;
        }

        .question-bank-panel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .question-bank-panel-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .question-bank-trigger-btn {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .question-bank-trigger-btn:hover {
            background: #2563eb;
        }
        
        .question-bank-item {
            padding: 0.75rem;
            border-bottom: 1px solid #f1f5f9;
            cursor: pointer;
            transition: background 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .question-bank-item:hover {
            background: #f8fafc;
        }
        
        .question-bank-item:last-child {
            border-bottom: none;
        }
        
        .question-text {
            flex: 1;
            font-size: 0.9rem;
            color: #2d3748;
        }
        
        .question-meta {
            font-size: 0.8rem;
            color: #718096;
            margin-left: 0.5rem;
        }
        
        .question-category {
            background: #e2e8f0;
            color: #4a5568;
            padding: 0.25rem 0.5rem;
            border-radius: 3px;
            font-size: 0.75rem;
            margin-right: 0.5rem;
        }
        
        .question-times-asked {
            color: #718096;
            font-size: 0.75rem;
        }
        
        .btn {
            background: #2d3748;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s ease;
            margin: 0.25rem;
            font-size: 0.9rem;
        }
        
        .btn:hover {
            background: #1a202c;
        }
        
        .btn-primary {
            background: #2d3748;
        }
        
        .btn-success {
            background: #059669;
        }
        
        .btn-success:hover {
            background: #047857;
        }
        
        .btn-danger {
            background: #dc2626;
        }

        /* Use full page with small padding */
        html, body { height: 100%; }
        body { margin: 0; }
        .main-container { width: 100%; max-width: 100%; padding: 0.5rem; box-sizing: border-box; }
        .interview-main, .right-panel { box-sizing: border-box; }
        
        .btn-danger:hover {
            background: #b91c1c;
        }
        
        .btn-warning {
            background: #d97706;
        }
        
        .btn-warning:hover {
            background: #b45309;
        }
        
        .right-panel {
            background: white;
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border: 1px solid #e2e8f0;
            height: 100%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .panel-title {
            font-size: 1.2rem;
            color: #2d3748;
            margin-bottom: 1rem;
            text-align: center;
        }
        
        .verdict-section {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: #f7fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        
        .verdict-title {
            font-size: 1rem;
            color: #2d3748;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }
        
        .verdict-select {
            width: 100%;
            padding: 0.5rem;
            border: 2px solid #e9ecef;
            border-radius: 5px;
            font-size: 0.9rem;
            background: white;
        }
        
        .verdict-select:focus {
            outline: none;
            border-color: #2d3748;
        }
        
        .notes-section {
            margin-bottom: 1.5rem;
        }
        
        .notes-title {
            font-size: 1rem;
            color: #2d3748;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }
        
        .notes-textarea {
            width: 100%;
            min-height: 120px;
            padding: 0.5rem;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 0.9rem;
            resize: vertical;
            transition: border-color 0.3s ease;
        }
        
        .notes-textarea:focus {
            outline: none;
            border-color: #2d3748;
        }
        
        .previous-interviews-section {
            margin-bottom: 1.5rem;
        }
        
        .previous-interviews-title {
            font-size: 1rem;
            color: #2d3748;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }
        
        .previous-interviews-list {
            max-height: 300px;
            overflow-y: auto;
        }
        
        .previous-interview-item {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        
        .previous-interview-item:hover {
            background: #edf2f7;
        }
        
        .previous-interview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.25rem;
        }
        
        .previous-interview-date {
            font-size: 0.8rem;
            color: #6b7280;
        }
        
        .previous-interview-status {
            background: #059669;
            color: white;
            padding: 0.2rem 0.4rem;
            border-radius: 10px;
            font-size: 0.7rem;
        }
        
        .previous-interview-verdict {
            background: #2d3748;
            color: white;
            padding: 0.2rem 0.4rem;
            border-radius: 10px;
            font-size: 0.7rem;
        }

        .status-completed {
            background: #059669 !important;
        }

        .status-in-progress {
            background: #d97706 !important;
        }

        .previous-interview-details {
            margin: 0.5rem 0;
            padding: 0.5rem;
            background: #ffffff;
            border-radius: 6px;
            border: 1px solid #e5e7eb;
        }

        .interview-detail-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.25rem;
            font-size: 0.8rem;
        }

        .interview-detail-row:last-child {
            margin-bottom: 0;
        }

        .detail-label {
            font-weight: 600;
            color: #6b7280;
            min-width: 80px;
        }

        .detail-value {
            color: #374151;
            text-align: right;
            flex: 1;
            margin-left: 0.25rem;
        }
        
        .previous-interview-questions {
            font-size: 0.8rem;
            color: #4a5568;
        }
        
        .previous-interview-questions-count {
            font-weight: 600;
            color: #2d3748;
        }
        
        .no-data-container {
            text-align: center;
            padding: 1rem;
            color: #6b7280;
        }
        
        .no-data-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            opacity: 0.5;
        }
        
        .no-data-text {
            font-size: 0.9rem;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 0.25rem;
        }
        
        .no-data-subtext {
            font-size: 0.8rem;
            color: #6b7280;
        }
        
        .interview-actions {
            text-align: center;
        }
        
        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .hidden {
            display: none;
        }
        
        .loading {
            text-align: center;
            padding: 1rem;
            color: #6b7280;
        }
        
        .error {
            background: #fed7d7;
            color: #c53030;
            padding: 0.5rem;
            border-radius: 6px;
            margin: 0.5rem 0;
            border: 1px solid #feb2b2;
            font-size: 0.9rem;
        }
        
        .success {
            background: #c6f6d5;
            color: #2f855a;
            padding: 0.5rem;
            border-radius: 6px;
            margin: 0.5rem 0;
            border: 1px solid #9ae6b4;
            font-size: 0.9rem;
        }
        
        .photo-capture {
            margin: 0.5rem 0;
            display: flex;
            gap: 0.5rem;
        }
        
        .photo-btn {
            background: #059669;
            color: white;
            border: none;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.8rem;
            flex: 1;
        }

        /* Camera Modal Styles */
        .camera-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .camera-container {
            background: white;
            border-radius: 12px;
            padding: 1rem;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        .camera-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .camera-header h3 {
            margin: 0;
            color: #1e293b;
        }

        .close-camera {
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .camera-preview {
            flex: 1;
            display: flex;
            justify-content: center;
            margin-bottom: 1rem;
        }

        .camera-preview video {
            width: 100%;
            max-width: 400px;
            border-radius: 8px;
            background: #000;
        }

        .camera-controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .camera-controls .btn {
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
        }
        
        .photo-btn:hover {
            background: #047857;
        }
        
        .photo-input {
            display: none;
        }
        
        .upload-loading {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #059669;
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }
        
        .loading-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #e5e7eb;
            border-top: 2px solid #059669;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .photo-gallery {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .photo-item {
            position: relative;
            display: inline-block;
        }
        
        .photo-item img {
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: 4px;
            border: 1px solid #d1d5db;
            cursor: pointer;
        }
        
        .photo-delete {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #dc2626;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .photo-preview {
            max-width: 150px;
            max-height: 150px;
            border-radius: 6px;
            display: none;
            border: 2px solid #e2e8f0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            object-fit: cover;
            margin-top: 0.25rem;
        }
        
        .delete-photo-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #dc2626;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background 0.2s ease;
        }
        
        .delete-photo-btn:hover {
            background: #b91c1c;
        }
        
        .photo-container {
            position: relative;
            display: inline-block;
            margin-top: 0.25rem;
        }
        
        .upload-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 1000;
            font-size: 12px;
        }
        
        .loading-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #ffffff;
            border-top: 2px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @media (max-width: 1024px) {
            .main-container {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .right-panel {
                order: -1;
                max-height: 400px;
            }
        }
        
        @media (max-width: 768px) {
            .main-container {
                padding: 0.5rem;
            }
            
            .interview-main {
                padding: 0.5rem;
            }
            
            .info-grid {
                grid-template-columns: 1fr;
            }
            
            .header-actions {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .header-actions .btn {
                padding: 0.4rem 0.8rem;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-content">
            <a href="/" class="logo">Bees</a>
            
            <div class="header-actions">
                
                <div class="user-info">
                    <div id="avatar" class="avatar hidden">U</div>
                    <div id="avatar-menu" class="avatar-menu">
                        <button id="logout-btn-dropdown">Logout</button>
                    </div>
                    <button id="login-btn" class="login-btn hidden">Sign in with Zoho</button>
                </div>
                
            </div>
        </div>
    </header>

    <!-- Question Bank Sliding Panel -->
    <div class="question-bank-panel-overlay" id="question-bank-overlay" onclick="closeQuestionBankPanel()"></div>
    <div class="question-bank-panel" id="question-bank-panel">
        <div class="question-bank-panel-header">
            <div class="question-bank-panel-title">üìö Question Bank</div>
            <button class="question-bank-close-btn" onclick="closeQuestionBankPanel()">√ó</button>
        </div>
        <div class="question-bank-panel-content">
            <div class="question-bank-panel-filters">
                <div class="form-group">
                    <label class="form-label">Category</label>
                    <select id="panel-category-select" class="form-select" onchange="loadPanelQuestionsByCategory()">
                        <option value="">All Categories</option>
                        <option value="Favorites">My Favorites</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Search</label>
                    <input type="text" id="panel-search-input" class="form-input" placeholder="Search questions..." onkeyup="searchPanelQuestions()">
                </div>
            </div>
            <div id="question-bank-panel-list" class="question-bank-panel-list">
                <div class="loading">Loading questions...</div>
            </div>
        </div>
    </div>

    <main class="main-container">
        <div class="interview-main">
            <div class="student-info-card">
                <h2 class="student-info-title">Candidate Information</h2>
                <div class="info-grid">
                    <div class="info-item">
                        <div class="info-label">Name</div>
                        <div class="info-value" id="candidate-name">Loading...</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Email</div>
                        <div class="info-value" id="candidate-email">Loading...</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Phone</div>
                        <div class="info-value" id="candidate-phone">Loading...</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Zeta ID</div>
                        <div class="info-value" id="candidate-zeta-id">Loading...</div>
                    </div>
                </div>
            </div>
            
            <div class="chat-container">
                <div id="chat-messages" class="chat-messages">
                    <div class="loading">Loading questions...</div>
                </div>
                
                <div class="add-question-form">
                    <div class="form-group">
                        <label class="form-label">Add Question</label>
                        <div class="question-source-tabs">
                            <button class="tab-btn active" onclick="switchQuestionSource('custom')">Custom Question</button>
                            <button class="question-bank-trigger-btn" onclick="openQuestionBankPanel()">
                                üìö Question Bank
                </button>
                        </div>
                    </div>
                    
                    <!-- Custom Question Tab -->
                    <div id="custom-question-tab" class="question-tab active">
                        <div class="form-group">
                            <label class="form-label" for="new-question">Add New Question</label>
                            <div class="textarea-container">
                                <textarea 
                                    id="new-question" 
                                    class="form-textarea" 
                                    placeholder="Enter your question here..."
                                    rows="2"
                                ></textarea>
                                <button class="add-to-bank-btn" onclick="addToQuestionBank()" title="Add to Question Bank">üìö</button>
                            </div>
                        </div>
                        <div style="display:flex;gap:0.5rem;align-items:center;flex-wrap:wrap">
                            <button id="add-question-btn" class="btn btn-primary" onclick="addQuestion()">Add Question</button>
                            <button id="save-interview-btn" class="btn btn-success" onclick="saveInterview()">Save Interview</button>
                            <button class="btn btn-danger" onclick="endInterview()">End Interview</button>
                            <button class="btn btn-warning" onclick="cancelInterview()">Cancel Interview</button>
                            <div class="interview-clock" id="interview-clock">
                                <span class="clock-icon">‚è±Ô∏è</span>
                                <span id="duration-display">00:00:00</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Question Bank Tab -->
                    <div id="question-bank-tab" class="question-tab">
                        <div class="question-bank-filters">
                            <div class="form-group">
                                <label class="form-label">Category</label>
                                <select id="bank-category-select" class="form-select" onchange="loadQuestionsByCategory()">
                                    <option value="">All Categories</option>
                                    <option value="Favorites">My Favorites</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Search</label>
                                <input type="text" id="bank-search-input" class="form-input" placeholder="Search questions..." onkeyup="searchQuestions()">
                            </div>
                        </div>
                        <div class="resize-handle" onmousedown="startResize(event)"></div>
                        <div id="question-bank-list" class="question-bank-list">
                            <div class="loading">Loading questions...</div>
                        </div>
                    </div>

                </div>
            </div>
        </div>
        
        <div class="right-panel">
            <h3 class="panel-title">Interview Management</h3>
            
            <div class="verdict-section" id="verdict-section">
                <h4 class="verdict-title">Interview Verdict</h4>
                <select id="verdict-select" class="verdict-select" onchange="updateVerdict()" required>
                    <option value="">Select Verdict *</option>
                    <option value="Tiger">Tiger</option>
                    <option value="Cow">Cow</option>
                    <option value="Cow+">Cow+</option>
                    <option value="Sheep">Sheep</option>
                </select>
            </div>
            
            <div class="notes-section">
                <h4 class="notes-title">Interview Notes</h4>
                <textarea 
                    id="interview-notes" 
                    class="notes-textarea" 
                    placeholder="Add your overall interview notes here..."
                ></textarea>
                <button id="save-notes-btn" class="btn btn-primary" onclick="saveNotes()">
                    Save Notes
                </button>
            </div>
            
            <div class="previous-interviews-section">
                <h4 class="previous-interviews-title">Previous Interviews</h4>
                <div id="previous-interviews-list" class="previous-interviews-list">
                    <div class="loading">Loading previous interviews...</div>
            </div>
            </div>
            
        </div>
    </main>

    <script>
        let currentInterview = null;
        let currentStudent = null;
        let questions = []; // Session-specific questions for the current interview
        let previousInterviews = [];
        let interviewStartTime = null;
        let durationInterval = null;
        let userRole = 'interviewer'; // Default role

        // Helper function to get current interviewer ID
        async function getCurrentInterviewerId() {
            let interviewerId = null;
            
            // Try to get from URL parameters first (from OAuth callback)
            const urlParams = new URLSearchParams(window.location.search);
            const userEmail = urlParams.get('email');
            
            if (userEmail) {
                // Get user ID from API
                try {
                    const response = await fetch(`/api/user/id?email=${encodeURIComponent(userEmail)}`);
                    const result = await response.json();
                    if (result.success) {
                        interviewerId = result.userId;
                        console.log('‚úÖ Got interviewer ID from API:', interviewerId);
                    }
                } catch (error) {
                    console.error('Error getting user ID from API:', error);
                }
            }
            
            // Fallback: try to get from localStorage
            if (!interviewerId) {
                const storedUserData = localStorage.getItem('bees_user_data');
                if (storedUserData) {
                    try {
                        const userData = JSON.parse(storedUserData);
                        if (userData.email) {
                            const response = await fetch(`/api/user/id?email=${encodeURIComponent(userData.email)}`);
                            const result = await response.json();
                            if (result.success) {
                                interviewerId = result.userId;
                                console.log('‚úÖ Got interviewer ID from localStorage:', interviewerId);
                            }
                        }
                    } catch (error) {
                        console.error('Error getting user ID from localStorage:', error);
                    }
                }
            }
            
            return interviewerId;
        }

        // Load student data and initialize interview
        async function loadStudentData() {
            try {
                console.log('loadStudentData called');
                
                // Reset questions array for this session to prevent cross-session contamination
                questions = [];
                
                // First try to get from sessionStorage
            const studentData = sessionStorage.getItem('currentStudent');
                console.log('sessionStorage studentData:', studentData);
                
            if (studentData) {
                    currentStudent = JSON.parse(studentData);
                    console.log('Loaded student from sessionStorage:', currentStudent);
                    console.log('currentStudent.id after parsing:', currentStudent?.id);
                    displayStudentData(currentStudent);
                    
                    // Add a small delay to ensure DOM is ready
                    setTimeout(async () => {
                        console.log('About to call initializeInterview from sessionStorage path');
                        await initializeInterview();
                    }, 100);
                    return;
                }

                // If not in sessionStorage, try to get from URL parameters
                const urlParams = new URLSearchParams(window.location.search);
                const zetaId = urlParams.get('zeta_id');
                console.log('zeta_id from URL:', zetaId);
                
                if (zetaId) {
                    await fetchStudentByZetaId(zetaId);
                } else {
                    console.error('No zeta_id found in URL');
                    showError('No student information found');
                }
                } catch (error) {
                    console.error('Error loading student data:', error);
                    showError('Error loading student data');
                }
        }

        async function fetchStudentByZetaId(zetaId) {
            try {
                console.log('Fetching student with zeta_id:', zetaId);
                const response = await fetch(`/api/students/search/${zetaId}`);
                const result = await response.json();
                
                console.log('API response:', result);
                
                if (response.ok && result.success && result.data && result.data.length > 0) {
                    currentStudent = result.data[0];
                    console.log('Student data set:', currentStudent);
                    console.log('currentStudent.id after API fetch:', currentStudent?.id);
                    
                    // Ensure the student has an id field - if not, try to get it from the database
                    if (!currentStudent.id) {
                        console.log('Student missing id field, attempting to fetch full student data...');
                        try {
                            const fullStudentResponse = await fetch(`/api/students/zeta/${currentStudent.zeta_id}`);
                            if (fullStudentResponse.ok) {
                                const fullStudentResult = await fullStudentResponse.json();
                                if (fullStudentResult.success && fullStudentResult.data) {
                                    currentStudent = fullStudentResult.data;
                                    console.log('Updated student with id:', currentStudent.id);
                                }
                            }
                        } catch (error) {
                            console.error('Error fetching full student data:', error);
                        }
                    }
                    
                    displayStudentData(currentStudent);
                    
                    // Add a small delay to ensure DOM is ready
                    setTimeout(async () => {
                        console.log('About to call initializeInterview from API fetch path');
                        await initializeInterview();
                    }, 100);
            } else {
                    console.error('Student not found or invalid response:', result);
                    showError('Student not found');
                }
            } catch (error) {
                console.error('Error fetching student:', error);
                showError('Error fetching student data');
            }
        }

        function displayStudentData(student) {
            console.log('displayStudentData called with:', student);
            
            if (!student) {
                console.error('No student data provided to displayStudentData');
                return;
            }
            
            try {
                document.getElementById('candidate-name').textContent = `${student.first_name} ${student.last_name}`;
                document.getElementById('candidate-email').textContent = student.email;
                document.getElementById('candidate-phone').textContent = student.phone || 'N/A';
                document.getElementById('candidate-zeta-id').textContent = student.zeta_id;
                console.log('Student data displayed successfully');
            } catch (error) {
                console.error('Error displaying student data:', error);
            }
        }

        async function initializeInterview() {
            console.log('üïê initializeInterview called, currentStudent:', currentStudent);
            console.log('currentStudent type:', typeof currentStudent);
            console.log('currentStudent.id:', currentStudent?.id);
            
            if (!currentStudent) {
                console.error('currentStudent is null/undefined');
                await loadStudentData();
                return;
            }

            // Check user role for verdict access
            await checkUserRole();
            
            if (!currentStudent.id) {
                console.error('currentStudent exists but has no id property');
                console.error('currentStudent keys:', Object.keys(currentStudent));
                console.error('currentStudent full object:', JSON.stringify(currentStudent, null, 2));
                
                // Try to reload student data as a fallback
                console.log('Attempting to reload student data...');
                const urlParams = new URLSearchParams(window.location.search);
                const zetaId = urlParams.get('zeta_id');
                
                if (zetaId) {
                    console.log('Retrying with zeta_id:', zetaId);
                    await fetchStudentByZetaId(zetaId);
                    return;
                }
                
                showError('No student data available');
                return;
            }

            try {
                console.log('Initializing interview for student:', currentStudent.id);
                
                // Get current interviewer ID
                const currentInterviewerId = await getCurrentInterviewerId();
                if (!currentInterviewerId) {
                    console.error('‚ùå Could not determine interviewer ID');
                    showError('Unable to identify interviewer. Please log in again.');
                    return;
                }
                
                // Check if there's already an active interview for this student
                const response = await fetch(`/api/interviews/student/${currentStudent.id}?interviewer_id=${currentInterviewerId}`);
                const result = await response.json();
                
                if (response.ok && result.success && result.data) {
                    currentInterview = result.data;
                    console.log('Found existing interview:', currentInterview);
                    document.getElementById('verdict-select').value = currentInterview.verdict || '';
                    // Ensure timer starts for existing in-progress interview
                    if (!interviewStartTime && currentInterview.status === 'in_progress') {
                        startDurationTracking();
                    }
                    await loadQuestions();
                } else if (response.status === 400 && result.error) {
                    // Handle the case where another interviewer is already conducting the interview
                    console.error('Interview conflict:', result.error);
                    showError(result.error);
                    return;
                } else {
                    console.log('No existing interview found, creating new one');
                    // Create new interview
                    await createInterview();
                }
                
                // Load previous interviews
                await loadPreviousInterviews();
            } catch (error) {
                console.error('Error initializing interview:', error);
                showError('Error initializing interview');
            }
        }

        async function createInterview() {
            console.log('üïê createInterview called, currentStudent:', currentStudent);
            try {
                if (!currentStudent || !currentStudent.id) {
                    console.error('No student data available for creating interview');
                    showError('No student data available');
                    return;
                }

                // Get current interviewer ID using helper function
                const interviewerId = await getCurrentInterviewerId();
                
                if (!interviewerId) {
                    console.error('‚ùå Could not determine interviewer ID');
                    showError('Unable to identify interviewer. Please log in again.');
                    return;
                }
                
                // Get session ID from URL or student data
                const sessionId = getUrlParameter('session_id') || currentStudent.sessionId;
                
                console.log('Creating interview for student:', currentStudent.id, 'interviewer:', interviewerId, 'session:', sessionId);
                
                const response = await fetch('/api/interviews', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        student_id: currentStudent.id,
                        interviewer_id: interviewerId,
                        session_id: sessionId
                    })
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    currentInterview = result.data;
                    console.log('Interview created:', currentInterview);
                    
                    // Start duration tracking
                    startDurationTracking();
                    
                    // Load questions for this new interview (will be empty initially)
                    await loadQuestions();
                } else {
                    console.error('Error creating interview:', result);
                    showError('Error creating interview: ' + (result.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error creating interview:', error);
                showError('Error creating interview');
            }
        }

        // Duration tracking functions
        function startDurationTracking() {
            console.log('üïê startDurationTracking called, interviewStartTime:', interviewStartTime);
            if (interviewStartTime) {
                console.log('‚è±Ô∏è Timer already started, returning');
                return; // Already started
            }
            
            // Check if this is a resume scenario
            const urlParams = new URLSearchParams(window.location.search);
            const isResume = urlParams.get('resume') === '1';
            
            if (isResume && currentInterview && currentInterview.duration_seconds) {
                // For resume, set start time to account for existing duration
                const existingDurationMs = currentInterview.duration_seconds * 1000;
                interviewStartTime = new Date(Date.now() - existingDurationMs);
                console.log('‚è±Ô∏è Resuming interview with existing duration:', currentInterview.duration_seconds, 'seconds');
                console.log('‚è±Ô∏è Adjusted start time:', interviewStartTime);
            } else {
                // For new interviews, start from current time
                interviewStartTime = new Date();
                console.log('‚è±Ô∏è New interview started at:', interviewStartTime);
            }
            
            // Update clock every second
            durationInterval = setInterval(updateDurationDisplay, 1000);
            console.log('‚è±Ô∏è Timer interval set:', durationInterval);
            updateDurationDisplay();
        }

        function stopDurationTracking() {
            if (durationInterval) {
                clearInterval(durationInterval);
                durationInterval = null;
            }
            
            if (interviewStartTime) {
                const endTime = new Date();
                const duration = Math.floor((endTime - interviewStartTime) / 1000);
                console.log('‚è±Ô∏è Interview ended. Duration:', duration, 'seconds');
                
                // Update database with duration
                updateInterviewDuration(duration, endTime);
            }
        }

        function updateDurationDisplay() {
            console.log('üïê updateDurationDisplay called, interviewStartTime:', interviewStartTime);
            if (!interviewStartTime) {
                console.log('‚è±Ô∏è No interview start time, returning');
                    return;
                }
            
            const now = new Date();
            const duration = Math.floor((now - interviewStartTime) / 1000);
            console.log('‚è±Ô∏è Duration calculated:', duration, 'seconds');
            
            const hours = Math.floor(duration / 3600);
            const minutes = Math.floor((duration % 3600) / 60);
            const seconds = duration % 60;
            
            const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            console.log('‚è±Ô∏è Time string:', timeString);
            
            const durationDisplay = document.getElementById('duration-display');
            console.log('‚è±Ô∏è Duration display element:', durationDisplay);
            if (durationDisplay) {
                durationDisplay.textContent = timeString;
                console.log('‚è±Ô∏è Updated display to:', timeString);
            } else {
                console.error('‚è±Ô∏è Duration display element not found!');
            }
        }

        async function updateInterviewDuration(durationSeconds, endTime) {
            if (!currentInterview) return;
            
            try {
                const response = await fetch(`/api/interviews/${currentInterview.id}/duration`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        duration_seconds: durationSeconds,
                        end_time: endTime.toISOString()
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    console.log('‚úÖ Interview duration updated:', durationSeconds, 'seconds');
                }
            } catch (error) {
                console.error('Error updating interview duration:', error);
            }
        }

        // Role-based access control
        async function checkUserRole() {
            try {
                // Get user role from server
                // Prefer email from URL or localStorage to resolve role accurately
                const urlParams = new URLSearchParams(window.location.search);
                const urlEmail = urlParams.get('email');
                let email = urlEmail;
                if (!email) {
                    try {
                        const stored = localStorage.getItem('bees_user_data');
                        const data = stored ? JSON.parse(stored) : null;
                        email = data?.email || '';
                    } catch {}
                }
                const roleEndpoint = email ? `/api/user/role?email=${encodeURIComponent(email)}` : '/api/user/role';
                const response = await fetch(roleEndpoint);
                const result = await response.json();
                
                if (result.success) {
                    userRole = result.role;
                    console.log('User role:', userRole);
                    
                    // Show verdict section for all users
                    const verdictSection = document.getElementById('verdict-section');
                    if (verdictSection) {
                        verdictSection.classList.remove('hidden');
                    }

                    // Show role-appropriate dashboard button in header
                    const dashboardBtn = document.getElementById('dashboard-btn');
                    if (dashboardBtn) {
                        const urlParams = new URLSearchParams(window.location.search);
                        const email = urlParams.get('email') || '';
                        const name = urlParams.get('name') || '';
                        const qs = `?${[email?`email=${encodeURIComponent(email)}`:'', name?`name=${encodeURIComponent(name)}`:''].filter(Boolean).join('&')}`;
                        const isAdmin = userRole === 'admin' || userRole === 'superadmin';
                        const target = isAdmin ? `/admin-dashboard.html${qs}` : `/interviewer-dashboard.html${qs}`;
                        dashboardBtn.classList.remove('hidden');
                        dashboardBtn.onclick = () => {
                            const isSafe = !currentInterview || (currentInterview && currentInterview.status === 'completed');
                            if (isSafe) {
                                window.location.href = target;
                                return;
                            }
                            const overlay = document.createElement('div');
                            overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.35);display:flex;align-items:center;justify-content:center;z-index:2000;';
                            overlay.innerHTML = `
                              <div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;min-width:280px;max-width:90%;padding:16px;box-shadow:0 10px 20px rgba(0,0,0,0.15)">
                                <div style=\"font-weight:600;margin-bottom:8px;color:#111827\">Leave without saving?</div>
                                <div style=\"font-size:14px;color:#374151;margin-bottom:12px\">You have an active interview. Unsaved changes may be lost. Continue to Dashboard?</div>
                                <div style=\"display:flex;gap:8px;justify-content:flex-end\">
                                  <button id=\"db-cancel\" style=\"border:1px solid #e5e7eb;background:#fff;padding:6px 10px;border-radius:6px;cursor:pointer\">Cancel</button>
                                  <button id=\"db-continue\" style=\"background:#111827;color:#fff;border:none;padding:6px 10px;border-radius:6px;cursor:pointer\">Continue</button>
                                </div>
                              </div>`;
                            document.body.appendChild(overlay);
                            overlay.querySelector('#db-cancel').onclick = ()=> overlay.remove();
                            overlay.querySelector('#db-continue').onclick = ()=> { overlay.remove(); window.location.href = target; };
                        };
                        // Init avatar
                        const avatar = document.getElementById('avatar');
                        const avatarMenu = document.getElementById('avatar-menu');
                        const loginBtn = document.getElementById('login-btn');
                        if (avatar) {
                            // Get user ID from API to ensure consistent avatar
                            try {
                                const userIdResponse = await fetch('/api/user/id');
                                const userIdData = await userIdResponse.json();
                                const userId = userIdData.success ? userIdData.userId : null;
                                const initial = userId ? userId.toString().charAt(0).toUpperCase() : (email || name || 'U').trim().charAt(0).toUpperCase();
                                avatar.textContent = initial || 'U';
                            } catch (error) {
                                console.error('Error fetching user ID:', error);
                                const initial = (email || name || 'U').trim().charAt(0).toUpperCase();
                                avatar.textContent = initial || 'U';
                            }
                            avatar.classList.remove('hidden');
                            if (loginBtn) loginBtn.classList.add('hidden');
                            avatar.onclick = () => {
                                avatarMenu.classList.toggle('active');
                            };
                            document.addEventListener('click', (e)=>{
                                if (!avatar.contains(e.target) && !avatarMenu.contains(e.target)) {
                                    avatarMenu.classList.remove('active');
                                }
                            });
                            const logoutBtn = document.getElementById('logout-btn-dropdown');
                            if (logoutBtn) {
                                logoutBtn.onclick = () => {
                                    const overlay = document.createElement('div');
                                    overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.35);display:flex;align-items:center;justify-content:center;z-index:2000;';
                                    overlay.innerHTML = `
                                      <div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;min-width:280px;max-width:90%;padding:16px;box-shadow:0 10px 20px rgba(0,0,0,0.15)">
                                        <div style=\"font-weight:600;margin-bottom:8px;color:#111827\">Logout?</div>
                                        <div style=\"font-size:14px;color:#374151;margin-bottom:12px\">Are you sure you want to logout?</div>
                                        <div style=\"display:flex;gap:8px;justify-content:flex-end\">
                                          <button id=\"lg-cancel\" style=\"border:1px solid #e5e7eb;background:#fff;padding:6px 10px;border-radius:6px;cursor:pointer\">Cancel</button>
                                          <button id=\"lg-confirm\" style=\"background:#111827;color:#fff;border:none;padding:6px 10px;border-radius:6px;cursor:pointer\">Logout</button>
                                        </div>
                                      </div>`;
                                    document.body.appendChild(overlay);
                                    overlay.querySelector('#lg-cancel').onclick = ()=> overlay.remove();
                                    overlay.querySelector('#lg-confirm').onclick = ()=> {
                                        overlay.remove();
                                        try { localStorage.removeItem('bees_user_data'); } catch {}
                window.location.href = '/';
                                    };
                                };
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Error checking user role:', error);
                // Default to showing verdict section for all users
                const verdictSection = document.getElementById('verdict-section');
                if (verdictSection) {
                    verdictSection.classList.remove('hidden');
                }
            }
        }

        function getUrlParameter(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }

        function formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            
            if (hours > 0) {
                return `${hours}h ${minutes}m ${secs}s`;
            } else if (minutes > 0) {
                return `${minutes}m ${secs}s`;
                } else {
                return `${secs}s`;
            }
        }

        async function addQuestion() {
            const questionText = document.getElementById('new-question').value.trim();
            console.log('‚ûï Adding custom question:', questionText);
            console.log('‚ûï Current questions count before adding:', questions.length);
            
            if (!questionText) {
                showError('Please enter a question');
                    return;
                }

            if (!currentInterview) {
                showError('No active interview found');
                return;
            }

            // Show loading state
            const addButton = document.getElementById('add-question-btn');
            const originalText = addButton.textContent;
            addButton.textContent = 'Adding...';
            addButton.disabled = true;

            try {
                console.log('üì§ Sending POST request to save custom question...');
                const response = await fetch(`/api/interviews/${currentInterview.id}/questions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        question_text: questionText
                    })
                });
                
                const result = await response.json();
                console.log('üì• Server response for custom question:', result);
                
                if (response.ok && result.success) {
                    console.log('‚úÖ Custom question saved successfully, reloading questions...');
                    // Reload questions from server to get the latest state for this specific interview
                    await loadQuestions();
                    document.getElementById('new-question').value = '';
                    showSuccess('Question added successfully!');
                } else {
                    console.error('‚ùå Error saving custom question:', result);
                    showError('Error adding question');
                }
            } catch (error) {
                console.error('‚ùå Error adding custom question:', error);
                showError('Error adding question');
            } finally {
                // Restore button state
                addButton.textContent = originalText;
                addButton.disabled = false;
            }
        }

        async function loadQuestions() {
            if (!currentInterview) return;

            try {
                console.log('üîÑ Loading questions for interview:', currentInterview.id);
                const response = await fetch(`/api/interviews/${currentInterview.id}/questions`);
                const result = await response.json();
                
                if (response.ok && result.success) {
                    console.log('üìã Loaded questions from server:', result.data.length, 'questions');
                    console.log('üìã Questions data:', result.data);
                    questions = result.data;
                    displayQuestions();
                } else {
                    console.error('‚ùå Error loading questions:', result);
                    showError('Error loading questions');
                }
            } catch (error) {
                console.error('‚ùå Error loading questions:', error);
                showError('Error loading questions');
            }
        }

        function displayQuestions() {
            const chatMessages = document.getElementById('chat-messages');
            
            console.log('displayQuestions called with questions:', questions);
            questions.forEach((q, i) => {
                console.log(`Question ${i}:`, {
                    id: q.id,
                    text: q.question_text,
                    answer_photo_url: q.answer_photo_url
                });
                if (q.answer_photo_url) {
                    console.log(`üì∏ Question ${i} has image:`, q.answer_photo_url);
                }
            });
            
            if (questions.length === 0) {
                chatMessages.innerHTML = '<div class="loading">No questions added yet</div>';
                    return;
                }

            chatMessages.innerHTML = questions.map((question, index) => `
                <div class="question-item" data-question-id="${question.id}">
                    <div class="question-header" onclick="toggleQuestion(${question.id})">
                        <span class="question-number">Q${index + 1}</span>
                        <div class="question-preview">${question.question_text}</div>
                        <div class="question-actions">
                            <div class="correctness-buttons">
                                <button class="correctness-btn correct-btn ${question.is_correct === true ? 'active' : ''}" 
                                        onclick="event.stopPropagation(); markQuestionCorrect(${question.id}, true)" 
                                        title="Mark as correct">
                                    ‚úì
                                </button>
                                <button class="correctness-btn incorrect-btn ${question.is_correct === false ? 'active' : ''}" 
                                        onclick="event.stopPropagation(); markQuestionCorrect(${question.id}, false)" 
                                        title="Mark as incorrect">
                                    ‚úó
                                </button>
                            </div>
                            <button class="add-to-bank-btn-small" onclick="event.stopPropagation(); addQuestionToBank('${question.question_text.replace(/'/g, "\\'")}')" title="Add to Question Bank">
                                üìö
                            </button>
                            <button class="delete-question-btn" onclick="event.stopPropagation(); deleteQuestion(${question.id})" title="Delete Question">
                                üóëÔ∏è
                            </button>
                            <span class="expand-icon">‚ñº</span>
                        </div>
                    </div>
                    <div class="question-content" id="content-${question.id}">
                        <div class="question-text">${question.question_text}</div>
                        <div class="answer-section">
                            <label class="answer-label">Student Answer</label>
                            <textarea 
                                class="form-textarea" 
                                placeholder="Enter student's answer here..."
                                onchange="updateAnswer(${question.id}, this.value)"
                                style="background: white; border: 1px solid #d1d5db; color: #1f2937; resize: vertical; min-height: 80px;"
                            >${question.student_answer || ''}</textarea>
                            ${question.answer_photo_url ? `
                                <div class="photo-gallery">
                                    ${(() => {
                                        try {
                                            const photoUrls = JSON.parse(question.answer_photo_url);
                                            if (Array.isArray(photoUrls)) {
                                                return photoUrls.map((url, index) => `
                                                    <div class="photo-item">
                                                        <img src="${url}" class="message-image" onclick="openImageModal('${url}')" title="Click to view full size" onerror="console.error('Image failed to load:', this.src)" onload="console.log('‚úÖ Image loaded successfully:', this.src)">
                                                        <button class="photo-delete" onclick="deletePhoto(${question.id}, ${index})" title="Delete image">√ó</button>
                                                    </div>
                                                `).join('');
                                            } else {
                                                // Handle single image (backward compatibility)
                                                return `
                                                    <div class="photo-item">
                                                        <img src="${question.answer_photo_url}" class="message-image" onclick="openImageModal('${question.answer_photo_url}')" title="Click to view full size" onerror="console.error('Image failed to load:', this.src)" onload="console.log('‚úÖ Image loaded successfully:', this.src)">
                                                        <button class="photo-delete" onclick="deletePhoto(${question.id})" title="Delete image">√ó</button>
                                                    </div>
                                                `;
                                            }
                                        } catch (e) {
                                            // Handle single image (backward compatibility)
                                            return `
                                                <div class="photo-item">
                                                    <img src="${question.answer_photo_url}" class="message-image" onclick="openImageModal('${question.answer_photo_url}')" title="Click to view full size" onerror="console.error('Image failed to load:', this.src)" onload="console.log('‚úÖ Image loaded successfully:', this.src)">
                                                    <button class="photo-delete" onclick="deletePhoto(${question.id})" title="Delete image">√ó</button>
                                                </div>
                                            `;
                                        }
                                    })()}
                                </div>
                            ` : ''}
                            <div class="photo-capture">
                                <button class="photo-btn" onclick="document.getElementById('photo-input-${question.id}').click()">
                                    üìÅ Upload Image
                                </button>
                                <button class="photo-btn" onclick="openCamera('${question.id}')">
                                    üì∑ Camera
                                </button>
                                <input type="file" class="photo-input" id="photo-input-${question.id}" 
                                       accept="image/*" multiple onchange="handlePhotoUpload('${question.id}', this)">
                                <input type="file" class="photo-input" id="camera-input-${question.id}" 
                                       accept="image/*" capture="environment" onchange="handlePhotoUpload('${question.id}', this)">
                            </div>
                        </div>
                    </div>
                </div>
            `).join('');
        }


        async function updateVerdict() {
            if (!currentInterview) return;

            const verdict = document.getElementById('verdict-select').value;
            
            try {
                const response = await fetch(`/api/interviews/${currentInterview.id}/verdict`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        verdict: verdict
                    })
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    currentInterview.verdict = verdict;
                    showSuccess('Verdict updated successfully!');
                } else {
                    showError('Error updating verdict');
                }
            } catch (error) {
                console.error('Error updating verdict:', error);
                showError('Error updating verdict');
            }
        }

        async function loadPreviousInterviews() {
            if (!currentStudent || !currentStudent.id) {
                console.log('No student data available for loading previous interviews');
                displayPreviousInterviews();
                return;
            }

            try {
                console.log('Loading previous interviews for student:', currentStudent.id);
                const response = await fetch(`/api/interviews/student/${currentStudent.id}/history`);
                const result = await response.json();
                
                if (response.ok && result.success) {
                    previousInterviews = result.data;
                    displayPreviousInterviews();
                } else {
                    console.log('No previous interviews found');
                    previousInterviews = [];
                    displayPreviousInterviews();
                }
            } catch (error) {
                console.error('Error loading previous interviews:', error);
                previousInterviews = [];
                displayPreviousInterviews();
            }
        }

        function displayPreviousInterviews() {
            const previousInterviewsList = document.getElementById('previous-interviews-list');
            
            if (previousInterviews.length === 0) {
                previousInterviewsList.innerHTML = `
                    <div class="no-data-container">
                        <div class="no-data-icon">üìã</div>
                        <div class="no-data-text">No Previous Interviews</div>
                        <div class="no-data-subtext">This student hasn't completed any interviews yet</div>
                    </div>
                `;
                return;
            }

            // Check if user is admin/superadmin to show verdict
            const isAdmin = userRole === 'admin' || userRole === 'superadmin';

            previousInterviewsList.innerHTML = previousInterviews.map(interview => {
                const date = new Date(interview.created_at).toLocaleDateString();
                const sessionName = interview.session_name || 'General Interview';
                const interviewerName = interview.interviewer_name || 'Unknown Interviewer';
                const duration = interview.duration_seconds ? formatDuration(interview.duration_seconds) : 'N/A';
                const status = interview.status || 'completed';
                const statusClass = status === 'completed' ? 'status-completed' : 'status-in-progress';
                const statusText = status === 'completed' ? 'Completed' : 'In Progress';
                
                return `
                    <div class="previous-interview-item" onclick="viewPreviousInterview(${interview.id})">
                        <div class="previous-interview-header">
                            <span class="previous-interview-date">${date}</span>
                            <div>
                                <span class="previous-interview-status ${statusClass}">${statusText}</span>
                                ${isAdmin && interview.verdict ? `<span class="previous-interview-verdict">${interview.verdict}</span>` : ''}
                            </div>
                        </div>
                        <div class="previous-interview-details">
                            <div class="interview-detail-row">
                                <span class="detail-label">Session:</span>
                                <span class="detail-value">${sessionName}</span>
                            </div>
                            <div class="interview-detail-row">
                                <span class="detail-label">Interviewer:</span>
                                <span class="detail-value">${interviewerName}</span>
                            </div>
                            <div class="interview-detail-row">
                                <span class="detail-label">Duration:</span>
                                <span class="detail-value">${duration}</span>
                            </div>
                        </div>
                        <div class="previous-interview-questions">
                            <span class="previous-interview-questions-count">Interview #${interview.id}</span>
                            ${interview.overall_notes ? `<br><small>Notes: ${interview.overall_notes.substring(0, 50)}${interview.overall_notes.length > 50 ? '...' : ''}</small>` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        async function viewPreviousInterview(interviewId) {
            try {
                // Load questions for the previous interview
                const response = await fetch(`/api/interviews/${interviewId}/questions`);
                const result = await response.json();
                
                if (response.ok && result.success) {
                    const previousQuestions = result.data;
                    showPreviousInterviewModal(interviewId, previousQuestions);
                } else {
                    showError('Error loading previous interview details');
                }
            } catch (error) {
                console.error('Error loading previous interview:', error);
                showError('Error loading previous interview');
            }
        }

        function openImageModal(imageUrl) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 2000;
                cursor: pointer;
            `;
            
            modal.innerHTML = `
                <div style="position: relative; max-width: 90vw; max-height: 90vh;">
                    <img src="${imageUrl}" style="max-width: 100%; max-height: 100%; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
                    <button onclick="this.closest('div').parentElement.remove()" 
                            style="position: absolute; top: -10px; right: -10px; background: #dc3545; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 18px; font-weight: bold;">
                        √ó
                    </button>
                </div>
            `;
            
            modal.onclick = function(e) {
                if (e.target === modal) {
                    modal.remove();
                }
            };
            
            document.body.appendChild(modal);
        }

        function showPreviousInterviewModal(interviewId, questions) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
            `;
            
            modal.innerHTML = `
                <div style="background: white; padding: 2rem; border-radius: 8px; max-width: 800px; max-height: 80vh; overflow-y: auto; margin: 1rem;">
                    <h3 style="margin-bottom: 1rem; color: #2d3748;">Previous Interview #${interviewId}</h3>
                    <div style="margin-bottom: 1rem;">
                        ${questions.map((q, index) => `
                            <div style="margin-bottom: 1rem; padding: 1rem; background: #f7fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
                                <div style="font-weight: 600; color: #2d3748; margin-bottom: 0.5rem;">
                                    Q${index + 1}: ${q.question_text}
                                </div>
                                <div style="color: #4a5568; margin-bottom: 0.5rem;">
                                    <strong>Answer:</strong> ${q.student_answer || 'No answer provided'}
                                </div>
                                ${q.answer_photo_url ? `
                                    <div style="margin-top: 0.5rem; padding: 0.5rem; background: #e8f5e8; border-radius: 6px; border: 1px solid #c3e6c3;">
                                        <div style="font-weight: 600; color: #28a745; margin-bottom: 0.5rem; font-size: 0.9rem;">
                                            üì∑ Answer Sheet
                                        </div>
                                        <img src="${q.answer_photo_url}" style="max-width: 300px; max-height: 300px; border-radius: 6px; border: 2px solid #dee2e6; object-fit: cover; cursor: pointer;" 
                                             onclick="openImageModal('${q.answer_photo_url}')" 
                                             title="Click to view full size">
                                    </div>
                                ` : ''}
                            </div>
                        `).join('')}
                    </div>
                    <button onclick="this.closest('div').parentElement.remove()" 
                            style="background: #2d3748; color: white; border: none; padding: 0.5rem 1rem; border-radius: 5px; cursor: pointer;">
                        Close
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
        }


        function openCamera(questionId) {
            // Check if getUserMedia is supported
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                // Fallback to file input with camera capture
                document.getElementById(`camera-input-${questionId}`).click();
                return;
            }

            // Request camera access
            navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: 'environment' // Prefer rear camera on mobile
                } 
            })
            .then(stream => {
                // Create a video element to show camera feed
                const video = document.createElement('video');
                video.style.width = '100%';
                video.style.maxWidth = '400px';
                video.style.borderRadius = '8px';
                video.srcObject = stream;
                video.play();

                // Create a modal for camera capture
                const modal = document.createElement('div');
                modal.className = 'camera-modal';
                modal.innerHTML = `
                    <div class="camera-container">
                        <div class="camera-header">
                            <h3>Take Photo</h3>
                            <button class="close-camera" onclick="closeCamera()">√ó</button>
                        </div>
                        <div class="camera-preview">
                            <video id="camera-video" autoplay playsinline></video>
                        </div>
                        <div class="camera-controls">
                            <button class="btn btn-danger" onclick="closeCamera()">Cancel</button>
                            <button class="btn btn-success" onclick="capturePhoto('${questionId}')">Capture</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);
                document.getElementById('camera-video').srcObject = stream;

                // Store the stream globally so we can stop it later
                window.currentCameraStream = stream;
            })
            .catch(error => {
                console.error('Error accessing camera:', error);
                showError('Could not access camera. Please check permissions or use Upload Image instead.');
                // Fallback to file input
                document.getElementById(`camera-input-${questionId}`).click();
            });
        }

        function closeCamera() {
            // Stop the camera stream
            if (window.currentCameraStream) {
                window.currentCameraStream.getTracks().forEach(track => track.stop());
                window.currentCameraStream = null;
            }

            // Remove the modal
            const modal = document.querySelector('.camera-modal');
            if (modal) {
                modal.remove();
            }
        }

        function capturePhoto(questionId) {
            const video = document.getElementById('camera-video');
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');

            // Set canvas dimensions to match video
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            // Draw the current video frame to canvas
            context.drawImage(video, 0, 0, canvas.width, canvas.height);

            // Convert canvas to blob
            canvas.toBlob(blob => {
                if (blob) {
                    // Create a file from the blob
                    const file = new File([blob], `camera-capture-${Date.now()}.jpg`, {
                        type: 'image/jpeg'
                    });

                    // Create a mock input element with the captured file
                    const mockInput = {
                        files: [file]
                    };

                    // Close camera and upload the photo
                    closeCamera();
                    handlePhotoUpload(questionId, mockInput);
                } else {
                    showError('Failed to capture photo');
                }
            }, 'image/jpeg', 0.8);
        }

        // Note: Cloudinary ping endpoint doesn't support CORS, so we skip the connection test
        // and go directly to the upload endpoint which does support CORS

        async function handlePhotoUpload(questionId, input) {
            console.log('handlePhotoUpload called with questionId:', questionId, 'type:', typeof questionId);
            console.log('currentStudent:', currentStudent);
            console.log('currentStudent.id:', currentStudent?.id);
            
            // Validate questionId
            if (!questionId || questionId === 'undefined' || questionId === 'null') {
                console.error('Invalid questionId:', questionId);
                showError('Invalid question ID. Please refresh the page and try again.');
                return;
            }
            
            const files = Array.from(input.files);
            if (!files || files.length === 0) {
                console.log('No files selected');
                return;
            }

            console.log('Files selected:', files.length, 'files');

            // Show loading indicator
            showUploadLoading(questionId, files.length);

            try {
                const uploadedUrls = [];
                const cloudName = 'dokomrjyc';
                const uploadPreset = 'ml_default';

                // Upload each file
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    console.log(`Uploading file ${i + 1}/${files.length}:`, file.name, file.type, file.size);

                    const formData = new FormData();
                    formData.append('file', file);
                    formData.append('upload_preset', uploadPreset);
                    formData.append('folder', 'interview-answers');

                    const response = await fetch(`https://api.cloudinary.com/v1_1/${cloudName}/image/upload`, {
                        method: 'POST',
                        body: formData,
                        mode: 'cors'
                    });

                    const result = await response.json();

                    if (response.ok && result.secure_url) {
                        uploadedUrls.push(result.secure_url);
                        console.log(`‚úÖ File ${i + 1} uploaded successfully:`, result.secure_url);
                    } else {
                        console.error(`‚ùå File ${i + 1} upload failed:`, result);
                        showError(`Failed to upload ${file.name}: ${result.error?.message || 'Unknown error'}`);
                    }
                }

                if (uploadedUrls.length > 0) {
                    // Update the question with all uploaded URLs
                    const currentAnswer = questions.find(q => q.id === questionId)?.student_answer || '';
                    const questionIndex = questions.findIndex(q => q.id == questionId);
                    
                    if (questionIndex !== -1) {
                        // Store multiple URLs as JSON string
                        questions[questionIndex].answer_photo_url = JSON.stringify(uploadedUrls);
                        console.log('‚úÖ Updated local question with multiple photo URLs:', uploadedUrls);
                    }
                    
                    // Update the database
                    await updateAnswer(questionId, currentAnswer, JSON.stringify(uploadedUrls));
                    
                    // Hide loading indicator
                    hideUploadLoading(questionId);
                    
                    // Refresh the display
                    displayQuestions();
                    showSuccess(`${uploadedUrls.length} image(s) uploaded successfully!`);
                } else {
                    hideUploadLoading(questionId);
                    showError('No images were uploaded successfully');
                }

            } catch (error) {
                console.error('Error uploading photos to Cloudinary:', error);
                hideUploadLoading(questionId);
                
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    showError('Network error: Unable to connect to Cloudinary. Please check your internet connection and try again.');
                } else if (error.name === 'NetworkError') {
                    showError('Network error: Please check your internet connection and try again.');
                } else {
                    showError('Error uploading photos to Cloudinary: ' + error.message);
                }
            }
        }

        function showUploadLoading(questionId, fileCount) {
            const questionElement = document.querySelector(`[data-question-id="${questionId}"]`);
            if (!questionElement) return;

            const photoCapture = questionElement.querySelector('.photo-capture');
            if (!photoCapture) return;

            // Create loading indicator
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'upload-loading';
            loadingDiv.id = `upload-loading-${questionId}`;
            loadingDiv.innerHTML = `
                <div class="loading-spinner"></div>
                <span>Uploading ${fileCount} image(s)...</span>
            `;

            // Disable upload buttons
            const uploadBtn = photoCapture.querySelector('.photo-btn');
            if (uploadBtn) uploadBtn.disabled = true;

            photoCapture.appendChild(loadingDiv);
        }

        function hideUploadLoading(questionId) {
            const loadingDiv = document.getElementById(`upload-loading-${questionId}`);
            if (loadingDiv) {
                loadingDiv.remove();
            }

            // Re-enable upload buttons
            const questionElement = document.querySelector(`[data-question-id="${questionId}"]`);
            if (questionElement) {
                const uploadBtn = questionElement.querySelector('.photo-btn');
                if (uploadBtn) uploadBtn.disabled = false;
            }
        }

        async function updateAnswer(questionId, answer, photoUrl = null) {
            try {
                const requestBody = {
                    student_answer: answer
                };
                
                if (photoUrl) {
                    requestBody.answer_photo_url = photoUrl;
                }
                
                const response = await fetch(`/api/interview-questions/${questionId}/answer`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    // Update local questions array
                    const questionIndex = questions.findIndex(q => q.id === questionId);
                    if (questionIndex !== -1) {
                        questions[questionIndex] = result.data;
                    }
                } else {
                    console.error('Error updating answer:', result);
                }
            } catch (error) {
                console.error('Error updating answer:', error);
            }
        }

        async function deletePhoto(questionId, imageIndex = null) {
            try {
                const questionIndex = questions.findIndex(q => q.id == questionId);
                if (questionIndex === -1) {
                    showError('Question not found');
                    return;
                }

                const currentPhotoUrl = questions[questionIndex].answer_photo_url;
                if (!currentPhotoUrl) {
                    showError('No images to delete');
                    return;
                }

                let newPhotoUrl = null;
                let deletedCount = 0;

                try {
                    const photoUrls = JSON.parse(currentPhotoUrl);
                    if (Array.isArray(photoUrls)) {
                        // Multiple images - delete specific one or all
                        if (imageIndex !== null && imageIndex >= 0 && imageIndex < photoUrls.length) {
                            photoUrls.splice(imageIndex, 1);
                            deletedCount = 1;
                            newPhotoUrl = photoUrls.length > 0 ? JSON.stringify(photoUrls) : null;
                        } else {
                            // Delete all images
                            newPhotoUrl = null;
                            deletedCount = photoUrls.length;
                        }
                    } else {
                        // Single image (backward compatibility)
                        newPhotoUrl = null;
                        deletedCount = 1;
                    }
                } catch (e) {
                    // Single image (backward compatibility)
                    newPhotoUrl = null;
                    deletedCount = 1;
                }

                const response = await fetch(`/api/interview-questions/${questionId}/answer`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        student_answer: questions[questionIndex].student_answer || '',
                        answer_photo_url: newPhotoUrl
                    })
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    // Update local questions array
                    questions[questionIndex].answer_photo_url = newPhotoUrl;
                    
                    // Refresh the display
                    displayQuestions();
                    showSuccess(`${deletedCount} image(s) deleted successfully!`);
                } else {
                    console.error('Error deleting photo:', result);
                    showError('Failed to delete image');
                }
            } catch (error) {
                console.error('Error deleting photo:', error);
                showError('Error deleting image');
            }
        }

        async function saveNotes() {
            if (!currentInterview) return;

            const notes = document.getElementById('interview-notes').value;
            
            // Show loading state
            const saveButton = document.getElementById('save-notes-btn');
            const originalText = saveButton.textContent;
            saveButton.textContent = 'Saving...';
            saveButton.disabled = true;
            
            try {
                const response = await fetch(`/api/interviews/${currentInterview.id}/notes`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        notes: notes
                    })
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    showSuccess('Notes saved successfully!');
                } else {
                    showError('Error saving notes');
                }
            } catch (error) {
                console.error('Error saving notes:', error);
                showError('Error saving notes');
            } finally {
                // Restore button state
                saveButton.textContent = originalText;
                saveButton.disabled = false;
            }
        }

        async function saveInterview() {
            if (!currentInterview) {
                showError('No active interview found');
                return;
            }

            // Show loading state
            const saveButton = document.getElementById('save-interview-btn');
            const originalText = saveButton.textContent;
            saveButton.textContent = 'Saving...';
            saveButton.disabled = true;

            try {
                // Save notes first
                const notes = document.getElementById('interview-notes').value;
                if (notes) {
                    await saveNotes();
                }

                // Save current duration
                if (interviewStartTime) {
                    const currentTime = new Date();
                    const durationSeconds = Math.floor((currentTime - interviewStartTime) / 1000);
                    await updateInterviewDuration(durationSeconds, currentTime);
                    console.log('‚úÖ Interview duration saved:', durationSeconds, 'seconds');
                }

                showSuccess('Interview saved successfully!');
            } catch (error) {
                console.error('Error saving interview:', error);
                showError('Error saving interview');
            } finally {
                // Restore button state
                saveButton.textContent = originalText;
                saveButton.disabled = false;
            }
        }

        async function endInterview() {
            if (!currentInterview) return;

            // Check if verdict is selected
            const verdictSelect = document.getElementById('verdict-select');
            if (!verdictSelect.value) {
                showError('Please select a verdict before ending the interview.');
                verdictSelect.focus();
                return;
            }

            // Stop duration tracking
            stopDurationTracking();

            try {
                // Confirm if they want to exit without explicitly saving
                const proceed = await (async () => {
                    return new Promise((resolve) => {
                        const overlay = document.createElement('div');
                        overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.35);display:flex;align-items:center;justify-content:center;z-index:2000;';
                        overlay.innerHTML = `
                          <div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;min-width:280px;max-width:90%;padding:16px;box-shadow:0 10px 20px rgba(0,0,0,0.15)">
                            <div style="font-weight:600;margin-bottom:8px;color:#111827">Exit Interview?</div>
                            <div style="font-size:14px;color:#374151;margin-bottom:12px">Have you saved your notes and answers? You can still continue and mark interview completed.</div>
                            <div style="display:flex;gap:8px;justify-content:flex-end">
                              <button id="exit-cancel" style="border:1px solid #e5e7eb;background:#fff;padding:6px 10px;border-radius:6px;cursor:pointer">Cancel</button>
                              <button id="exit-continue" style="background:#dc2626;color:#fff;border:none;padding:6px 10px;border-radius:6px;cursor:pointer">Continue</button>
                            </div>
                          </div>`;
                        document.body.appendChild(overlay);
                        overlay.querySelector('#exit-cancel').onclick = ()=> { overlay.remove(); resolve(false); };
                        overlay.querySelector('#exit-continue').onclick = ()=> { overlay.remove(); resolve(true); };
                    });
                })();
                if (!proceed) return;

                const response = await fetch(`/api/interviews/${currentInterview.id}/complete`, {
                    method: 'PUT'
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    showSuccess('Interview completed successfully!');
                    // Refresh previous interviews list
                    await loadPreviousInterviews();
                    setTimeout(() => { goBack(); }, 1000);
                } else {
                    showError('Error completing interview');
                }
            } catch (error) {
                console.error('Error completing interview:', error);
                showError('Error completing interview');
            }
        }

        async function cancelInterview() {
            if (!currentInterview) return;

            // Show confirmation dialog
            const proceed = await (async () => {
                return new Promise((resolve) => {
                    const overlay = document.createElement('div');
                    overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.35);display:flex;align-items:center;justify-content:center;z-index:2000;';
                    overlay.innerHTML = `
                        <div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;min-width:320px;max-width:90%;padding:20px;box-shadow:0 10px 20px rgba(0,0,0,0.15)">
                            <div style="font-weight:600;margin-bottom:8px;color:#111827;font-size:1.1rem">Cancel Interview?</div>
                            <div style="font-size:14px;color:#374151;margin-bottom:16px">Are you sure you want to cancel this interview? All progress will be lost and the interview will not be saved.</div>
                            <div style="display:flex;gap:8px;justify-content:flex-end">
                                <button id="cancel-cancel" style="border:1px solid #e5e7eb;background:#fff;padding:8px 16px;border-radius:6px;cursor:pointer">Keep Interview</button>
                                <button id="cancel-confirm" style="background:#d97706;color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer">Cancel Interview</button>
                            </div>
                        </div>`;
                    document.body.appendChild(overlay);
                    overlay.querySelector('#cancel-cancel').onclick = ()=> { overlay.remove(); resolve(false); };
                    overlay.querySelector('#cancel-confirm').onclick = ()=> { overlay.remove(); resolve(true); };
                });
            })();
            
            if (!proceed) return;

            try {
                // Stop duration tracking
                stopDurationTracking();

                // Delete the interview from the database
                const response = await fetch(`/api/interviews/${currentInterview.id}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    showSuccess('Interview cancelled successfully!');
                    setTimeout(() => { goBack(); }, 1000);
                } else {
                    showError('Error cancelling interview');
                }
            } catch (error) {
                console.error('Error cancelling interview:', error);
                showError('Error cancelling interview');
            }
        }
            
        function goBack() {
            const isAdmin = userRole === 'admin' || userRole === 'superadmin';
            const params = new URLSearchParams(window.location.search);
            const email = params.get('email') || '';
            const name = params.get('name') || '';
            const qs = `?tab=my-interviews${email?`&email=${encodeURIComponent(email)}`:''}${name?`&name=${encodeURIComponent(name)}`:''}`;
            window.location.href = isAdmin ? `/admin-dashboard.html${qs}` : `/interviewer-dashboard.html${qs}`;
        }

        function showError(message) {
            // Remove existing messages
            const existingError = document.querySelector('.error');
            if (existingError) existingError.remove();
            
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            document.querySelector('.interview-main').insertBefore(errorDiv, document.querySelector('.chat-container'));
            
            setTimeout(() => errorDiv.remove(), 5000);
        }

        function showSuccess(message) {
            // Remove existing messages
            const existingSuccess = document.querySelector('.success');
            if (existingSuccess) existingSuccess.remove();
            
            const successDiv = document.createElement('div');
            successDiv.className = 'success';
            successDiv.textContent = message;
            document.querySelector('.interview-main').insertBefore(successDiv, document.querySelector('.chat-container'));
            
            setTimeout(() => successDiv.remove(), 3000);
        }

        // Question Bank Functions
        let questionBankData = [];
        let currentCategory = '';
        let panelQuestionBankData = [];
        let panelCurrentCategory = '';

        // Test function for debugging
        window.testQuestionBank = function() {
            console.log('Testing question bank functionality...');
            switchQuestionSource('bank');
        };

        // Additional test functions
        window.testLoadQuestions = function() {
            console.log('Testing loadQuestionBankData...');
            loadQuestionBankData();
        };

        window.testDisplayQuestions = function() {
            console.log('Testing displayQuestionBankList...');
            displayQuestionBankList([{id: 1, question: 'Test question', category: 'Test', times_asked: 0}]);
        };

        function toggleQuestion(questionId) {
            const questionItem = document.querySelector(`[data-question-id="${questionId}"]`);
            const header = questionItem.querySelector('.question-header');
            const content = questionItem.querySelector('.question-content');
            
            if (content.classList.contains('expanded')) {
                // Collapse
                content.classList.remove('expanded');
                header.classList.remove('expanded');
                questionItem.classList.remove('expanded');
            } else {
                // Expand
                content.classList.add('expanded');
                header.classList.add('expanded');
                questionItem.classList.add('expanded');
            }
        }

        function switchQuestionSource(source) {
            console.log('switchQuestionSource called with:', source);
            
            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            const activeBtn = document.querySelector(`[onclick="switchQuestionSource('${source}')"]`);
            if (activeBtn) {
                activeBtn.classList.add('active');
            } else {
                console.error('Could not find tab button for source:', source);
            }
            
            // Update tab content
            document.querySelectorAll('.question-tab').forEach(tab => tab.classList.remove('active'));
            let activeTab;
            if (source === 'bank') {
                activeTab = document.getElementById('question-bank-tab');
            } else {
                activeTab = document.getElementById(`${source}-question-tab`);
            }
            if (activeTab) {
                activeTab.classList.add('active');
                console.log('Activated tab:', activeTab.id);
            } else {
                console.error('Could not find tab for source:', source);
            }
            
            // Load question bank data if switching to bank tab
            if (source === 'bank' && questionBankData.length === 0) {
                console.log('Loading question bank data...');
                loadQuestionBankData();
            } else if (source === 'bank') {
                console.log('Question bank data already loaded, displaying...');
                displayQuestionBankList(questionBankData);
            }
        }


        async function loadQuestionBankData() {
            console.log('üîç loadQuestionBankData called');
            try {
                // Load categories
                console.log('üìÇ Fetching categories...');
                const categoriesResponse = await fetch('/api/question-bank/categories');
                console.log('üìÇ Categories response status:', categoriesResponse.status);
                
                if (!categoriesResponse.ok) {
                    throw new Error(`HTTP ${categoriesResponse.status}: ${categoriesResponse.statusText}`);
                }
                
                const categoriesResult = await categoriesResponse.json();
                console.log('üìÇ Categories result:', categoriesResult);
                
                if (categoriesResult.success) {
                    const categorySelect = document.getElementById('bank-category-select');
                    if (categorySelect) {
                        categorySelect.innerHTML = '<option value="">All Categories</option>';
                        // Add Favorites option
                        const favoritesOption = document.createElement('option');
                        favoritesOption.value = 'Favorites';
                        favoritesOption.textContent = 'My Favorites';
                        categorySelect.appendChild(favoritesOption);
                        
                        // Add all categories
                        categoriesResult.data.forEach(category => {
                            const option = document.createElement('option');
                            option.value = category.category;
                            option.textContent = `${category.category} (${category.question_count})`;
                            categorySelect.appendChild(option);
                        });
                        console.log('‚úÖ Categories loaded into dropdown');
                    } else {
                        console.error('‚ùå Category select element not found');
                    }
                } else {
                    console.error('‚ùå Failed to load categories:', categoriesResult.error);
                }
                
                // Load all questions
                console.log('‚ùì Fetching questions...');
                const questionsResponse = await fetch('/api/question-bank');
                console.log('‚ùì Questions response status:', questionsResponse.status);
                
                if (!questionsResponse.ok) {
                    throw new Error(`HTTP ${questionsResponse.status}: ${questionsResponse.statusText}`);
                }
                
                const questionsResult = await questionsResponse.json();
                console.log('‚ùì Questions result:', questionsResult);
                
                if (questionsResult.success) {
                    questionBankData = questionsResult.data;
                    console.log('Question bank data loaded:', questionBankData.length, 'questions');
                    displayQuestionBankList(questionBankData);
                } else {
                    console.error('Failed to load questions:', questionsResult.error);
                }
            } catch (error) {
                console.error('Error loading question bank data:', error);
                showError('Error loading question bank');
            }
        }

        async function loadQuestionsByCategory() {
            const selectEl = document.getElementById('bank-category-select');
            if (!selectEl) return;
            const category = selectEl.value;
            try {
                let data = [];
                if (!category) {
                    // All
                    data = questionBankData || [];
                } else if (category === 'Favorites') {
                    const email = (JSON.parse(localStorage.getItem('bees_user_data') || '{}')?.email) || '';
                    const res = await fetch(`/api/interviewer/favorites${email ? `?email=${encodeURIComponent(email)}` : ''}`);
                    const json = await res.json();
                    if (json.success) {
                        data = (json.data || []).map(f => ({
                            id: f.id || f.question_id,
                            question: f.question,
                            question_text: f.question,
                            category: f.category,
                            times_asked: f.times_asked ?? 0
                        }));
                    }
                } else {
                    const res = await fetch(`/api/question-bank/category/${encodeURIComponent(category)}`);
                    const json = await res.json();
                    if (json.success) data = json.data || [];
                    console.log('[Panel] Questions by category =', data.length);
                    console.log('[Panel] Questions by category =', JSON.stringify(data.slice(0,3), null, 2));
                }
                displayQuestionBankList(data);
            } catch (error) {
                console.error('Error loading questions by category:', error);
                showError('Error loading questions');
            }
        }

        async function searchQuestions() {
            const searchTerm = document.getElementById('bank-search-input').value.trim();
            if (!searchTerm) {
                displayQuestionBankList(questionBankData);
                return;
            }
            
            try {
                const response = await fetch(`/api/question-bank/search?q=${encodeURIComponent(searchTerm)}`);
                const result = await response.json();
                
                if (result.success) {
                    displayQuestionBankList(result.data);
                }
            } catch (error) {
                console.error('Error searching questions:', error);
                showError('Error searching questions');
            }
        }

        function displayQuestionBankList(questions) {
            console.log('displayQuestionBankList called with:', questions);
            const listContainer = document.getElementById('question-bank-list');
            
            if (!listContainer) {
                console.error('Question bank list container not found');
                return;
            }
            
            if (questions.length === 0) {
                console.log('No questions to display');
                listContainer.innerHTML = '<div class="loading">No questions found</div>';
                return;
            }
            
            console.log('Displaying', questions.length, 'questions');
            listContainer.innerHTML = questions.map(question => {
                const qText = (question.question || question.question_text || '').toString();
                const escapedQuestion = qText.replace(/'/g, "\\'").replace(/"/g, '\\"').replace(/\n/g, '\\n');
                return `
                <div class="question-bank-item" onclick="selectQuestionFromBank(${question.id}, '${escapedQuestion}', this)">
                    <div class="question-text">${qText}</div>
                    <div class="question-meta">
                        <span class="question-category">${question.category || 'Uncategorized'}</span>
                        <span class="question-times-asked">Asked ${(question.times_asked ?? question.count_of_times_asked ?? 0)} times</span>
                    </div>
                </div>
            `;
            }).join('');
            console.log('Question bank list updated in DOM');
        }

        async function selectQuestionFromBank(questionId, questionText, el) {
            console.log('üîç selectQuestionFromBank called with:', { 
                questionId, 
                questionText, 
                questionTextType: typeof questionText,
                currentInterview: currentInterview?.id 
            });
            
            if (!currentInterview) {
                console.error('‚ùå No current interview found');
                showError('No active interview found. Please start an interview first.');
                return;
            }
            
            // Validate questionText
            if (!questionText || questionText.trim() === '') {
                console.error('‚ùå Invalid question text:', questionText);
                showError('Invalid question text. Please try again.');
                return;
            }
            
            // Check for duplicate questions
            const isDuplicate = questions.some(q => 
                q.question_text && q.question_text.trim().toLowerCase() === questionText.trim().toLowerCase()
            );
            
            if (isDuplicate) {
                showError('This question has already been added to the interview. Please select a different question.');
                return;
            }
            
            try {
                // Show inline loading on clicked item
                if (el) {
                    el.style.pointerEvents = 'none';
                    const originalHtml = el.innerHTML;
                    el.setAttribute('data-original-html', originalHtml);
                    el.innerHTML = '<div class="question-text">Adding...</div><div class="question-meta">Please wait</div>';
                }
                // Add the question to the current interview
                console.log('üì§ Sending request to add question to interview:', currentInterview.id);
                const response = await fetch(`/api/interviews/${currentInterview.id}/questions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        question_text: questionText
                    })
                });
                
                console.log('üì• Response status:', response.status);
                const result = await response.json();
                console.log('üì• Response result:', result);
                
                if (!response.ok) {
                    console.error('‚ùå HTTP Error:', response.status, response.statusText);
                }
                
                if (result.success) {
                    console.log('‚úÖ Question added successfully, proceeding with increment...');
                    
                    // Increment the times asked counter (don't fail if this doesn't work)
                    try {
                        console.log('üì§ Attempting to increment times asked for question:', questionId);
                        const incrementResponse = await fetch(`/api/question-bank/${questionId}/increment`, {
                            method: 'POST'
                        });
                        const incrementResult = await incrementResponse.json();
                        console.log('üì• Increment response:', incrementResult);
                        
                        if (!incrementResponse.ok) {
                            console.warn('‚ö†Ô∏è Increment failed but question was added:', incrementResult);
                        }
                    } catch (incrementError) {
                        console.warn('‚ö†Ô∏è Failed to increment times asked:', incrementError);
                        // Don't show error to user, question was added successfully
                    }
                    
                    console.log('üîÑ Reloading questions from server...');
                    // Reload questions from server to get the latest state for this specific interview
                    await loadQuestions();
                    console.log('‚úÖ Questions reloaded, showing success message');
                    showSuccess('Question added successfully');
                    
                    // Collapse question bank back to normal height
                    collapseQuestionBank();
                    
                    // Switch back to custom question tab
                    switchQuestionSource('custom');
                } else {
                    console.error('‚ùå Error adding question from bank:', result);
                    showError('Error adding question from bank');
                }
            } catch (error) {
                console.error('Error adding question from bank:', error);
                showError('Error adding question');
            } finally {
                if (el) {
                    // Restore item
                    const html = el.getAttribute('data-original-html');
                    if (html) el.innerHTML = html;
                    el.style.pointerEvents = '';
                }
            }
        }

        // Resize functionality for question bank
        let isResizing = false;
        let startY = 0;
        let startHeight = 0;

        function startResize(e) {
            isResizing = true;
            startY = e.clientY;
            const questionBankList = document.getElementById('question-bank-list');
            startHeight = questionBankList.offsetHeight;
            
            document.addEventListener('mousemove', doResize);
            document.addEventListener('mouseup', stopResize);
            e.preventDefault();
        }

        function doResize(e) {
            if (!isResizing) return;
            
            const questionBankList = document.getElementById('question-bank-list');
            const newHeight = startHeight + (e.clientY - startY);
            const minHeight = 200;
            const maxHeight = 600;
            
            if (newHeight >= minHeight && newHeight <= maxHeight) {
                questionBankList.style.maxHeight = newHeight + 'px';
                questionBankList.classList.add('expanded');
            }
        }

        function stopResize() {
            isResizing = false;
            document.removeEventListener('mousemove', doResize);
            document.removeEventListener('mouseup', stopResize);
        }

        function collapseQuestionBank() {
            const questionBankList = document.getElementById('question-bank-list');
            questionBankList.style.maxHeight = '300px';
            questionBankList.classList.remove('expanded');
        }

        // Delete question functionality
        async function deleteQuestion(questionId) {
            if (!confirm('Are you sure you want to delete this question? This action cannot be undone.')) {
                return;
            }

            try {
                const response = await fetch(`/api/interview-questions/${questionId}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Remove from local questions array
                    questions = questions.filter(q => q.id !== questionId);
                    
                    // Refresh the display
                    displayQuestions();
                    showSuccess('Question deleted successfully');
                } else {
                    showError('Error deleting question');
                }
            } catch (error) {
                console.error('Error deleting question:', error);
                showError('Error deleting question');
            }
        }

        // Mark question as correct/incorrect
        async function markQuestionCorrect(questionId, isCorrect) {
            try {
                const response = await fetch(`/api/interview-questions/${questionId}/correctness`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        is_correct: isCorrect
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Update local questions array
                    const questionIndex = questions.findIndex(q => q.id === questionId);
                    if (questionIndex !== -1) {
                        questions[questionIndex].is_correct = isCorrect;
                    }
                    
                    // Refresh the display
                    displayQuestions();
                    showSuccess(`Question marked as ${isCorrect ? 'correct' : 'incorrect'}`);
                } else {
                    showError('Error updating question correctness');
                }
            } catch (error) {
                console.error('Error updating question correctness:', error);
                showError('Error updating question correctness');
            }
        }

        // Add to Question Bank Functions
        function addToQuestionBank() {
            const questionText = document.getElementById('new-question').value.trim();
            
            if (!questionText) {
                showError('Please enter a question first');
                return;
            }
            
            // Show the modal with the question text
            document.getElementById('modal-question-text').value = questionText;
            document.getElementById('modal-category-select').value = '';
            document.getElementById('custom-category').value = '';
            document.getElementById('custom-category-group').style.display = 'none';
            document.getElementById('category-modal').style.display = 'flex';
        }

        function addQuestionToBank(questionText) {
            // Show the modal with the question text
            document.getElementById('modal-question-text').value = questionText;
            document.getElementById('modal-category-select').value = '';
            document.getElementById('custom-category').value = '';
            document.getElementById('custom-category-group').style.display = 'none';
            document.getElementById('category-modal').style.display = 'flex';
        }

        function handleCategoryChange() {
            const categorySelect = document.getElementById('modal-category-select');
            const customCategoryGroup = document.getElementById('custom-category-group');
            
            if (categorySelect.value === 'Other') {
                customCategoryGroup.style.display = 'block';
                document.getElementById('custom-category').focus();
            } else {
                customCategoryGroup.style.display = 'none';
            }
        }

        function closeCategoryModal() {
            document.getElementById('category-modal').style.display = 'none';
        }

        async function saveToQuestionBank() {
            const questionText = document.getElementById('modal-question-text').value.trim();
            const categorySelect = document.getElementById('modal-category-select');
            const customCategory = document.getElementById('custom-category').value.trim();
            
            if (!questionText) {
                showError('Question text is required');
                return;
            }
            
            let category = categorySelect.value;
            if (category === 'Other') {
                if (!customCategory) {
                    showError('Please enter a custom category');
                    return;
                }
                category = customCategory;
            }
            
            if (!category) {
                showError('Please select a category');
                return;
            }
            
            try {
                const response = await fetch('/api/question-bank', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        question: questionText,
                        category: category
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showSuccess('Question added to question bank successfully');
                    closeCategoryModal();
                    
                    // Clear the question textarea
                    document.getElementById('new-question').value = '';
                    
                    // Refresh question bank data if it's loaded
                    if (questionBankData.length > 0) {
                        await loadQuestionBankData();
                    }
                } else {
                    showError('Error adding question to bank: ' + (result.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error adding question to bank:', error);
                showError('Error adding question to bank');
            }
        }

        // Question Bank Panel Functions
        function openQuestionBankPanel() {
            const panel = document.getElementById('question-bank-panel');
            const overlay = document.getElementById('question-bank-overlay');
            
            panel.classList.add('open');
            overlay.classList.add('active');
            
            // Load question bank data if not already loaded
            if (panelQuestionBankData.length === 0) {
                loadPanelQuestionBankData();
            } else {
                displayPanelQuestionBankList(panelQuestionBankData);
            }
        }

        function closeQuestionBankPanel() {
            const panel = document.getElementById('question-bank-panel');
            const overlay = document.getElementById('question-bank-overlay');
            
            panel.classList.remove('open');
            overlay.classList.remove('active');
        }

        async function loadPanelQuestionBankData() {
            console.log('üîç Loading panel question bank data...');
            try {
                // Load categories
                console.log('üìÇ Fetching categories...');
                const categoriesResponse = await fetch('/api/question-bank/categories');
                console.log('üìÇ Categories response status:', categoriesResponse.status);
                
                if (!categoriesResponse.ok) {
                    throw new Error(`HTTP ${categoriesResponse.status}: ${categoriesResponse.statusText}`);
                }
                
                const categoriesResult = await categoriesResponse.json();
                console.log('üìÇ Categories result:', categoriesResult);
                
                if (categoriesResult.success && categoriesResult.data) {
                    const categorySelect = document.getElementById('panel-category-select');
                    // Clear existing options except "All Categories" and "My Favorites"
                    categorySelect.innerHTML = '<option value="">All Categories</option><option value="Favorites">My Favorites</option>';
                    
                    categoriesResult.data.forEach(categoryData => {
                        const option = document.createElement('option');
                        // Handle both string and object formats
                        const categoryName = typeof categoryData === 'string' ? categoryData : categoryData.category;
                        const questionCount = typeof categoryData === 'object' ? categoryData.question_count : '';
                        option.value = categoryName;
                        option.textContent = questionCount ? `${categoryName} (${questionCount})` : categoryName;
                        categorySelect.appendChild(option);
                    });
                }
                
                // Load all questions
                console.log('‚ùì Fetching questions...');
                const questionsResponse = await fetch('/api/question-bank');
                console.log('‚ùì Questions response status:', questionsResponse.status);
                
                if (!questionsResponse.ok) {
                    throw new Error(`HTTP ${questionsResponse.status}: ${questionsResponse.statusText}`);
                }
                
                const questionsResult = await questionsResponse.json();
                console.log('‚ùì Questions result:', questionsResult);
                
                if (questionsResult.success && questionsResult.data) {
                    panelQuestionBankData = questionsResult.data;
                    console.log('‚úÖ Loaded questions:', panelQuestionBankData.length);
                    displayPanelQuestionBankList(panelQuestionBankData);
                } else {
                    throw new Error(questionsResult.error || 'Failed to load questions');
                }
                
            } catch (error) {
                console.error('‚ùå Error loading panel question bank data:', error);
                document.getElementById('question-bank-panel-list').innerHTML = 
                    `<div class="error">Error loading questions: ${error.message}</div>`;
            }
        }

        async function loadPanelQuestionsByCategory() {
            const selectEl = document.getElementById('panel-category-select');
            if (!selectEl) return;
            const category = (selectEl.value || '').trim();
            console.log('[Panel] Category changed ->', category);
            // persist current category for search filtering
            try { window.panelCurrentCategory = category; } catch {}
            try {
                let data = [];
                if (!category) {
                    data = panelQuestionBankData || [];
                    console.log('[Panel] Using all questions, count =', data.length);
                } else if (category.toLowerCase().includes('favorite')) {
                    const email = (JSON.parse(localStorage.getItem('bees_user_data') || '{}')?.email) || '';
                    console.log('[Panel][Favorites] Using email =', email);
                    const url = `/api/interviewer/favorites${email ? `?email=${encodeURIComponent(email)}` : ''}`;
                    console.log('[Panel][Favorites] Fetch URL =', url);
                    const res = await fetch(url , {
                        headers: email ? { 'x-user-email': email } : {}
                    });
                    console.log('[Panel][Favorites] Response status =', res.status);
                    const json = await res.json();
                    console.log('[Panel][Favorites] JSON =', json);
                    try { console.log('[Panel][Favorites] JSON (stringified) =', JSON.stringify(json, null, 2)); } catch {}
                    if (json && json.success) {
                        const favs = json.data || [];
                        console.log('[Panel][Favorites] Raw favorites count =', favs.length);
                        try { console.log('[Panel][Favorites] Raw favorites array =', JSON.stringify(favs, null, 2)); } catch { console.log('[Panel][Favorites] Raw favorites array (non-string) =', favs); }
                        // Normalize ID keys to strings to avoid number/string mismatch
                        const byId = new Map((panelQuestionBankData || []).map(q => [String(q.id), q]));
                        data = favs.map(f => {
                            const fid = String(f.question_id != null ? f.question_id : f.id);
                            const base = byId.get(fid) || {};
                            const text = f.question || base.question || base.question_text || `Favorite Question #${fid}`;
                            return {
                                id: Number(fid),
                                question: text,
                                question_text: text,
                                category: f.category || base.category || 'Uncategorized',
                                times_asked: (f.times_asked ?? base.times_asked ?? 0),
                                success_rate: (f.success_rate ?? base.success_rate ?? 0)
                            };
                        });
                        // If enrichment produced empty list but we had raw favorites, fall back to building rows from raw favorites directly
                        if (data.length === 0 && favs.length > 0) {
                            console.warn('[Panel][Favorites] Enrichment yielded empty; attempting backend details join');
                            try {
                                const ids = favs.map(f => (f.question_id != null ? f.question_id : f.id)).filter(Boolean);
                                // Fallback 1: if backend supports bulk by ids
                                let built = [];
                                try {
                                    const bulkUrl = `/api/admin/questions/details?ids=${encodeURIComponent(ids.join(','))}`;
                                    console.log('[Panel][Favorites] Trying bulk details URL =', bulkUrl);
                                    const bulkRes = await fetch(bulkUrl);
                                    if (bulkRes.ok) {
                                        const bulkJson = await bulkRes.json();
                                        if (bulkJson && bulkJson.success && Array.isArray(bulkJson.data)) {
                                            built = bulkJson.data.map(q => ({
                                                id: q.id,
                                                question: q.question || q.question_text || `Favorite Question #${q.id}`,
                                                question_text: q.question || q.question_text || `Favorite Question #${q.id}`,
                                                category: q.category || 'Uncategorized',
                                                times_asked: q.times_asked ?? 0,
                                                success_rate: q.success_rate ?? 0
                                            }));
                                        }
                                    }
                                } catch (e) {
                                    console.warn('[Panel][Favorites] Bulk details not available:', e);
                                }
                                // Fallback 2: per-id details as last resort
                                if (built.length === 0) {
                                    console.log('[Panel][Favorites] Falling back to per-id details fetch');
                                    const details = await Promise.all(ids.map(async (qid) => {
                                        try {
                                            const r = await fetch(`/api/admin/questions/${qid}/details`);
                                            if (!r.ok) return null;
                                            const j = await r.json();
                                            const q = j.data || j;
                                            return {
                                                id: qid,
                                                question: q.question || q.question_text || `Favorite Question #${qid}`,
                                                question_text: q.question || q.question_text || `Favorite Question #${qid}`,
                                                category: q.category || 'Uncategorized',
                                                times_asked: q.times_asked ?? 0,
                                                success_rate: q.success_rate ?? 0
                                            };
                                        } catch {
                                            return null;
                                        }
                                    }));
                                    built = details.filter(Boolean);
                                    console.log('[Panel][Favorites] Built via per-id details count =', built.length);
                                }
                                if (built.length > 0) {
                                    data = built;
                                    try { console.log('[Panel][Favorites] Built data sample =', JSON.stringify(data.slice(0,3), null, 2)); } catch {}
                                } else {
                                    // Final fallback: raw favorites
                                    data = favs.map(f => {
                                        const fid = Number(f.question_id != null ? f.question_id : f.id);
                                        const text = f.question || `Favorite Question #${fid}`;
                                        return {
                                            id: fid,
                                            question: text,
                                            question_text: text,
                                            category: f.category || 'Uncategorized',
                                            times_asked: f.times_asked ?? 0,
                                            success_rate: f.success_rate ?? 0
                                        };
                                    });
                                    try { console.log('[Panel][Favorites] Raw mapped data sample =', JSON.stringify(data.slice(0,3), null, 2)); } catch {}
                                }
                            } catch (e) {
                                console.warn('[Panel][Favorites] Details join fallback failed:', e);
                                // Keep raw favorites rendering as last resort
                                data = favs.map(f => {
                                    const fid = Number(f.question_id != null ? f.question_id : f.id);
                                    const text = f.question || `Favorite Question #${fid}`;
                                    return {
                                        id: fid,
                                        question: text,
                                        question_text: text,
                                        category: f.category || 'Uncategorized',
                                        times_asked: f.times_asked ?? 0,
                                        success_rate: f.success_rate ?? 0
                                    };
                                });
                                try { console.log('[Panel][Favorites] Raw mapped data sample (fallback) =', JSON.stringify(data.slice(0,3), null, 2)); } catch {}
                            }
                        }
                        console.log('[Panel][Favorites] Enriched favorites count =', data.length);
                    } else {
                        console.warn('[Panel][Favorites] Favorite API not success');
                    }
                } else {
                    const catUrl = `/api/question-bank/category/${encodeURIComponent(category)}`;
                    console.log('[Panel][Category] Fetch URL =', catUrl);
                    const res = await fetch(catUrl);
                    console.log('[Panel][Category] Response status =', res.status);
                    const json = await res.json();
                    console.log('[Panel][Category] JSON =', json);
                    if (json && json.success) data = json.data || [];
                }
                console.log('[Panel] Final list length =', data.length);
                displayPanelQuestionBankList(data);
            } catch (e) {
                console.error('[Panel] Error filtering panel questions:', e);
            }
        }

        function displayPanelQuestionBankList(questions) {
            const listContainer = document.getElementById('question-bank-panel-list');
            
            if (!questions || questions.length === 0) {
                console.warn('[Panel] No questions to display for current filter');
                listContainer.innerHTML = '<div class="empty-state">No questions found</div>';
                return;
            }
            
            listContainer.innerHTML = questions.map(question => `
                <div class="question-bank-panel-item" data-question-id="${question.id}" onclick="selectPanelQuestion(${question.id})">
                    <div class="question-bank-panel-item-text">${question.question_text}</div>
                    <div class="question-bank-panel-item-meta">
                        <span class="question-bank-panel-item-category">${question.category || 'Uncategorized'}</span>
                        <div class="question-bank-panel-item-stats">
                            <span>Asked: ${question.times_asked || 0}</span>
                            <span>Success: ${question.success_rate || 0}%</span>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        async function selectPanelQuestion(questionId) {
            // Remove previous selection
            document.querySelectorAll('.question-bank-panel-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            // Add selection to clicked item
            const selectedItem = document.querySelector(`[data-question-id="${questionId}"]`);
            if (selectedItem) {
                selectedItem.classList.add('selected');
                
                // Find the question data
                const question = panelQuestionBankData.find(q => q.id === questionId);
                if (question) {
                    // Add the question to the interview
                    await addQuestionFromPanel(question.question_text);
                    
                    // Close the panel
                    closeQuestionBankPanel();
                }
            }
        }

        async function addQuestionFromPanel(questionText) {
            console.log('‚ûï Adding question from panel:', questionText);
            console.log('‚ûï Current interview ID:', currentInterview?.id);
            console.log('‚ûï Current questions count before adding:', questions.length);
            
            if (!currentInterview) {
                showError('No active interview found');
                return;
            }

            // Check for duplicate questions
            const isDuplicate = questions.some(q => 
                q.question_text && q.question_text.trim().toLowerCase() === questionText.trim().toLowerCase()
            );
            
            if (isDuplicate) {
                showError('This question has already been added to the interview. Please select a different question.');
                return;
            }

            try {
                // Save the question to the server first
                console.log('üì§ Sending POST request to save question...');
                const response = await fetch(`/api/interviews/${currentInterview.id}/questions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        question_text: questionText
                    })
                });
                
                const result = await response.json();
                console.log('üì• Server response:', result);
                
                if (response.ok && result.success) {
                    console.log('‚úÖ Question saved successfully, reloading questions...');
                    // Reload questions from server to get the latest state
                    await loadQuestions();
                    showSuccess('Question added from Question Bank!');
                } else {
                    console.error('‚ùå Error saving question:', result);
                    showError('Error adding question from bank');
                }
            } catch (error) {
                console.error('‚ùå Error adding question from panel:', error);
                showError('Error adding question from bank');
            }
        }

        // removed old simple loadPanelQuestionsByCategory (replaced by async version above)

        function searchPanelQuestions() {
            const searchInput = document.getElementById('panel-search-input');
            const searchTerm = searchInput.value.toLowerCase().trim();
            
            let filteredQuestions = [...panelQuestionBankData];
            
            // Apply category filter first
            if (panelCurrentCategory === 'Favorites') {
                filteredQuestions = filteredQuestions.filter(q => q.is_favorite);
            } else if (panelCurrentCategory) {
                filteredQuestions = filteredQuestions.filter(q => q.category === panelCurrentCategory);
            }
            
            // Apply search filter
            if (searchTerm) {
                filteredQuestions = filteredQuestions.filter(q => 
                    q.question_text.toLowerCase().includes(searchTerm)
                );
            }
            
            displayPanelQuestionBankList(filteredQuestions);
        }

        // Close panel when clicking outside
        document.addEventListener('click', function(event) {
            const panel = document.getElementById('question-bank-panel');
            const overlay = document.getElementById('question-bank-overlay');
            
            if (event.target === overlay) {
                closeQuestionBankPanel();
            }
        });

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            loadStudentData();
            // Initialize question bank tab as inactive
            document.getElementById('question-bank-tab').classList.remove('active');
        });
    </script>

    <!-- Category Selection Modal -->
    <div id="category-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Add Question to Bank</h3>
                <button class="close-modal" onclick="closeCategoryModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label" for="question-text">Question:</label>
                    <textarea id="modal-question-text" class="form-textarea" rows="3" readonly></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label" for="modal-category-select">Category:</label>
                    <select id="modal-category-select" class="form-select" onchange="handleCategoryChange()">
                        <option value="">Select a category...</option>
                        <option value="Math Aptitude">Math Aptitude</option>
                        <option value="Generic HR">Generic HR</option>
                        <option value="English">English</option>
                        <option value="Technical">Technical</option>
                        <option value="Problem Solving">Problem Solving</option>
                        <option value="Other">Other</option>
                    </select>
                </div>
                <div class="form-group" id="custom-category-group" style="display: none;">
                    <label class="form-label" for="custom-category">Custom Category:</label>
                    <input type="text" id="custom-category" class="form-input" placeholder="Enter custom category...">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeCategoryModal()">Cancel</button>
                <button class="btn btn-primary" onclick="saveToQuestionBank()">Add to Bank</button>
            </div>
        </div>
    </div>


<script src="/shared-auth.js"></script>
</body>
</html>